/**
  ******************************************************************************
  * @file    stm32wb05n_types.h
  * @author  System Research & Applications Team - Agrate/Catania Lab.
  * @version V1.3.0
  * @date    06-Feb-2024
  * @brief   Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#ifndef _STM32WB05N_TYPES_H_
#define _STM32WB05N_TYPES_H_

#include "compiler.h"
#include "ble_const.h"
#include "ble_types.h"
#include "stm32wb_conf.h"

typedef uint8_t tBleStatus;
typedef uint8_t ble_status_t;

#include <stdint.h>
typedef tBleStatus (*hci_event_process)(uint8_t *buffer_in);
typedef struct hci_command_table_type_s {
  uint16_t evt_code;
  hci_event_process process;
} hci_events_table_type, hci_le_meta_events_table_type, hci_vendor_specific_events_table_type;

extern const hci_events_table_type hci_events_table[8];
extern const hci_le_meta_events_table_type hci_le_meta_events_table[40];
extern const hci_vendor_specific_events_table_type hci_vendor_specific_events_table[46];
#include <stdint.h>

/** Documentation for C struct Advertising_Set_Parameters_t */
typedef PACKED(struct) packed_Advertising_Set_Parameters_t_s {
  /** It is used to identify an advertising set.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t Advertising_Handle;
  /** The Duration[i] parameter indicates the duration for which that advertising set
   *  is enabled. The duration begins at the start of the first advertising
   *  event of this advertising set. The Controller should not start an extended
   *  advertising event that it cannot complete within the duration. Time = N *
   *  10 ms 0x00 means no advertising duration: advertising will continue until
   *  the Host disables it.
   *  Values:
   *  - 0x0000 (0 ms) : No advertising duration
   *  - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
   */
  uint16_t Duration;
  /** The Max_Extended_Advertising_Events[i] parameter, if non-zero, indicates the
   *  maximum number of extended advertising events that shall be sent prior to
   *  disabling the extended advertising set even if the Duration[i] parameter
   *  has not expired.
   *  Values:
   *  - 0x00: No maximum number of advertising events.
   *  - 0x01 ... 0xFF: Maximum number of extended advertising events.
   */
  uint8_t Max_Extended_Advertising_Events;
} packed_Advertising_Set_Parameters_t;

/** Documentation for C struct Extended_Scan_Parameters_t */
typedef PACKED(struct) packed_Extended_Scan_Parameters_t_s {
  /** The Scan_Type parameter specifies the type of scan to perform. 0: Passive
   *  Scanning. No scan request PDUs shall be sent. 1: Active Scanning. Scan
   *  request PDUs may be sent.
   *  Values:
   *  - 0x00: Passive Scanning
   *  - 0x01: Active Scanning
   */
  uint8_t Scan_Type;
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Window;
} packed_Extended_Scan_Parameters_t;

/** Documentation for C struct Extended_Create_Connection_Parameters_t */
typedef PACKED(struct) packed_Extended_Create_Connection_Parameters_t_s {
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Window;
  /** Minimum value for the connection interval. This shall be less than or equal to
   *  Connection_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   */
  uint16_t Connection_Interval_Min;
  /** Maximum value for the connection interval. This shall be less than or equal to
   *  Connection_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   */
  uint16_t Connection_Interval_Max;
  /** Peripheral latency for the connection in number of connection events
   *  Values:
   *  - 0x0000 ... 0x01F3
   */
  uint16_t Max_Latency;
  /** Supervision timeout for the LE Link. (See [Vol 6] Part B, Section 4.5.2) Time =
   *  N * 10 ms; Time Range: 100 ms to 32 s.
   *  Values:
   *  - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
   */
  uint16_t Supervision_Timeout;
  /** Informative parameter recommending the minimum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Min_CE_Length;
  /** Informative parameter recommending the maximum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Max_CE_Length;
} packed_Extended_Create_Connection_Parameters_t;

/** Documentation for C struct CIS_Param_t */
typedef PACKED(struct) packed_CIS_Param_t_s {
  /** Used to identify a CIS.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t CIS_ID;
  /** Maximum size, in octets, of the payload from the Central's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_P_To_C;
  /** PHY to use for transmission from the Central to the Peripheral.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_C_To_P;
  /** PHY to use for transmission from the Peripheral to the Central.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_P_To_C;
  /** Number of times every CIS Data PDU should be retransmitted from the Central to
   *  the Peripheral.
   */
  uint8_t RTN_C_To_P;
  /** Number of times every CIS Data PDU should be retransmitted from the Peripheral
   *  to the Central.
   */
  uint8_t RTN_P_To_C;
} packed_CIS_Param_t;

/** Documentation for C struct CIS_Param_Test_t */
typedef PACKED(struct) packed_CIS_Param_Test_t_s {
  /** Used to identify a CIS.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t CIS_ID;
  /** Maximum number of subevents in each CIS event.
   *  Values:
   *  - 0x01 ... 0x1F
   */
  uint8_t NSE;
  /** Maximum size, in octets, of the payload from the Central's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_P_To_C;
  /** Maximum size, in octets, of the payload from the Central's Link Layer to the
   *  Peripheral's Link Layer.
   *  Values:
   *  - 0x0000 ... 0x00FB
   */
  uint16_t Max_PDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Link Layer to the
   *  Central's Link Layer.
   *  Values:
   *  - 0x0000 ... 0x00FB
   */
  uint16_t Max_PDU_P_To_C;
  /** PHY to use for transmission from the Central to the Peripheral.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_C_To_P;
  /** PHY to use for transmission from the Peripheral to the Central.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_P_To_C;
  /** The burst number for Central to Peripheral.
   *  Values:
   *  - 0x00: No data
   *  - 0x01 ... 0x0F
   */
  uint8_t BN_C_To_P;
  /** The burst number for Peripheral to Central.
   *  Values:
   *  - 0x00: No data
   *  - 0x01 ... 0x0F
   */
  uint8_t BN_P_To_C;
} packed_CIS_Param_Test_t;

/** Documentation for C struct CIS_Handles_t */
typedef PACKED(struct) packed_CIS_Handles_t_s {
  /** Connection handle of a CIS.
   *  Values:
   *  - 0x0000 ... 0x0EFF
   */
  uint16_t CIS_Connection_Handle;
  /** Connection handle of an ACL connection.
   *  Values:
   *  - 0x0000 ... 0x0EFF
   */
  uint16_t ACL_Connection_Handle;
} packed_CIS_Handles_t;

/** Documentation for C struct Subevent_Data_Parameters_t */
typedef PACKED(struct) packed_Subevent_Data_Parameters_t_s {
  /** The subevent index of the data.
   *  Values:
   *  - 0x00 ... 0x7F
   */
  uint8_t Subevent;
  /** The first response slots to be used in this subevent.
   */
  uint8_t Response_Slot_Start;
  /** The number of response slots to be used.
   */
  uint8_t Response_Slot_Count;
  /** The number of octets in the Subevent_Data parameter.
   *  Values:
   *  - 0x00 ... 0xFB
   */
  uint8_t Subevent_Data_Length;
  /** Advertising data formatted as defined in [Vol 3] Part C, Section 11.
   */
  uint8_t Subevent_Data[1];
} packed_Subevent_Data_Parameters_t;

/** Documentation for C struct Bonded_Device_Entry_t */
typedef PACKED(struct) packed_Bonded_Device_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Address_Type;
  /** Identity Address (Public or Random) of the device.
   */
  uint8_t Address[6];
} packed_Bonded_Device_Entry_t;

/** Documentation for C struct List_Entry_t */
typedef PACKED(struct) packed_List_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Peer_Address_Type;
  /** Public Device Address or Random Device Address of the device to be added to the
   *  list.
   */
  uint8_t Peer_Address[6];
} packed_List_Entry_t;

/** Documentation for C union Service_UUID_t */
typedef PACKED(union) packed_Service_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t Service_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Service_UUID_128[16];
} packed_Service_UUID_t;

/** Documentation for C union Char_UUID_t */
typedef PACKED(union) packed_Char_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t Char_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Char_UUID_128[16];
} packed_Char_UUID_t;

/** Documentation for C union Char_Desc_Uuid_t */
typedef PACKED(union) packed_Char_Desc_Uuid_t_s {
  /** 16-bit UUID
   */
  uint16_t Char_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Char_UUID_128[16];
} packed_Char_Desc_Uuid_t;

/** Documentation for C union UUID_t */
typedef PACKED(union) packed_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t UUID_16;
  /** 128-bit UUID
   */
  uint8_t UUID_128[16];
} packed_UUID_t;

/** Documentation for C struct Gatt_Srv_Notify_Attr_t */
typedef PACKED(struct) packed_Gatt_Srv_Notify_Attr_t_s {
  /** 
   */
  uint16_t Handle;
  /** 
   */
  uint16_t Val_Length;
  /** 
   */
  uint8_t Val[1];
} packed_Gatt_Srv_Notify_Attr_t;

/** Documentation for C struct Handle_Packets_Pair_Entry_t */
typedef PACKED(struct) packed_Handle_Packets_Pair_Entry_t_s {
  /** Connection handle
   */
  uint16_t Connection_Handle;
  /** The number of HCI Data Packets that have been completed (transmitted or flushed)
   *  for the associated Connection_Handle since the previous time the event was
   *  returned.
   */
  uint16_t HC_Num_Of_Completed_Packets;
} packed_Handle_Packets_Pair_Entry_t;

/** Documentation for C struct Attribute_Group_Handle_Pair_t */
typedef PACKED(struct) packed_Attribute_Group_Handle_Pair_t_s {
  /** Found Attribute handle
   */
  uint16_t Found_Attribute_Handle;
  /** Group End handle
   */
  uint16_t Group_End_Handle;
} packed_Attribute_Group_Handle_Pair_t;

/** Documentation for C struct Advertising_Report_t */
typedef PACKED(struct) packed_Advertising_Report_t_s {
  /** Type of advertising report event: ADV_IND: Connectable undirected advertising',
   *  ADV_DIRECT_IND: Connectable directed advertising, ADV_SCAN_IND: Scannable
   *  undirected advertising, ADV_NONCONN_IND: Non connectable undirected
   *  advertising, SCAN_RSP: Scan response.
   *  Values:
   *  - 0x00: ADV_IND
   *  - 0x01: ADV_DIRECT_IND
   *  - 0x02: ADV_SCAN_IND
   *  - 0x03: ADV_NONCONN_IND
   *  - 0x04: SCAN_RSP
   */
  uint8_t Event_Type;
  /** 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
   *  Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
   *  Identity Address (Corresponds to Resolved Private Address)
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address
   *  - 0x03: Random (Static) Identity Address
   */
  uint8_t Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the advertising device.
   */
  uint8_t Address[6];
  /** Length of the Data[i] field for each device which responded.
   *  Values:
   *  - 0 ... 31
   */
  uint8_t Data_Length;
  /** Data_Length octets of advertising or scan response data formatted as defined in
   *  [Vol 3] Part C, Section 8.
   */
  uint8_t Data[1];
  /** N Size: 1 Octet (signed integer) Units: dBm
   *  Values:
   *  - -127 ... 20
   *  - 127: RSSI not available
   */
  int8_t RSSI;
} packed_Advertising_Report_t;

/** Documentation for C struct Direct_Advertising_Report_t */
typedef PACKED(struct) packed_Direct_Advertising_Report_t_s {
  /** Advertising type
   *  Values:
   *  - 0x01: Connectable directed advertising (ADV_DIRECT_IND)
   */
  uint8_t Event_Type;
  /** 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
   *  Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
   *  Identity Address (Corresponds to Resolved Private Address)
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address
   *  - 0x03: Random (Static) Identity Address
   */
  uint8_t Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the advertising device.
   */
  uint8_t Address[6];
  /** 0x01 Random Device Address
   *  Values:
   *  - 0x01: Random Device Address
   */
  uint8_t Direct_Address_Type;
  /** Random Device Address
   */
  uint8_t Direct_Address[6];
  /** N Size: 1 Octet (signed integer) Units: dBm
   *  Values:
   *  - -127 ... 20
   *  - 127: RSSI not available
   */
  int8_t RSSI;
} packed_Direct_Advertising_Report_t;

/** Documentation for C struct Extended_Advertising_Report_t */
typedef PACKED(struct) packed_Extended_Advertising_Report_t_s {
  /** Event Type parameter. Bits from 0 to 4: 0 Connectable advertising 1 Scannable
   *  advertising 2 Directed advertising 3 Scan response 4 Legacy advertising
   *  PDUs used Bits 5-6 Data status: 00b = Complete 01b = Incomplete, more data
   *  to come 10b = Incomplete, data truncated, no more to come 11b = Reserved
   *  for future use
   *  Flags:
   *  - 0x0001: Connectable advertising
   *  - 0x0002: Scannable advertising
   *  - 0x0004: Directed advertising
   *  - 0x0008: Scan response
   *  - 0x0010: Legacy advertising PDUs used
   */
  uint16_t Event_Type;
  /** Address Type
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address (corresponds to Resolved Private Address)
   *  - 0x03: Random (static) Identity Address (corresponds to Resolved Private
Address)
   *  - 0xFF: No address provided (anonymous advertisement)
   */
  uint8_t Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the advertising device.
   */
  uint8_t Address[6];
  /** PHY used to send the advertising PDU on the primary advertising physical
   *  channel.
   *  Values:
   *  - 0x01: LE_1M_PHY
   *  - 0x03: LE_CODED_PHY
   */
  uint8_t Primary_PHY;
  /** This parameter indicates the PHY used to send the advertising PDU(s), if any, on
   *  the secondary advertising physical channel.
   *  Values:
   *  - 0x00: No packets
   *  - 0x01: LE_1M_PHY
   *  - 0x02: LE_2M_PHY
   *  - 0x03: LE_CODED_PHY
   */
  uint8_t Secondary_PHY;
  /** Advertising SID subfield in the ADI field of the PDU
   *  Values:
   *  - 0x00 ... 0x0F
   *  - 0xFF: NA
   */
  uint8_t Advertising_SID;
  /** Tx Power. Units: dBm.
   *  Values:
   *  - -127 ... 126
   *  - 127: NA
   */
  int8_t TX_Power;
  /** RSSI value; Units: dBm; All other values Reserved for future use.
   *  Values:
   *  - -127 ... 20
   *  - 127: NA
   */
  int8_t RSSI;
  /** Interval of the periodic advertising. Time = N * 1.25 ms; Time Range: 7.5 ms to
   *  81,918.75 s.
   *  Values:
   *  - 0x0000 (NaN) : NA
   *  - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
   */
  uint16_t Periodic_Advertising_Interval;
  /** Direct address type
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address (Corresponds to Resolved PrivateAddress)
   *  - 0x03: Random (static) Identity Address (Corresponds to Resolved PrivateAddress)
   *  - 0x04 ... 0xFD: Reserved for future use
   *  - 0xFE: Random Device Address (Controller unable to resolve)
   *  - 0xFF: Reserved for future use
   */
  uint8_t Direct_Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the target device
   */
  uint8_t Direct_Address[6];
  /** Length of the Data[i] field for each device which responded
   *  Values:
   *  - 0 ... 229
   */
  uint8_t Data_Length;
  /** Data_Length[i] octets of advertising or scan response data formatted as defined
   *  in [Vol 3] Part C, Section 11. Note: Each element of this array has a
   *  variable length.
   */
  uint8_t Data[1];
} packed_Extended_Advertising_Report_t;

/** Documentation for C struct Samples_t */
typedef PACKED(struct) packed_Samples_t_s {
  /** The list of I samples for the reported packet. Each sample is a signed integer.
   *  The list is in the order of the sampling points within the packet.
   */
  int8_t I_Sample;
  /** The list of Q samples for the reported packet. Each sample is a signed integer.
   *  The list is in the order of the sampling points within the packet.
   */
  int8_t Q_Sample;
} packed_Samples_t;

/** Documentation for C struct Periodic_Advertising_Response_t */
typedef PACKED(struct) packed_Periodic_Advertising_Response_t_s {
  /** Range: -127 to +20 (units: dBm). If 0x7F, Tx Power information is not available.
   *  Values:
   *  - -127 ... 20
   *  - 127: NA
   */
  int8_t TX_Power;
  /** Range: -127 to +20 (units: dBm) If 0x7F, RSSI is not available.
   *  Values:
   *  - -127 ... 20
   *  - 127: NA
   */
  int8_t RSSI;
  /** CTE type in the response.
   *  Values:
   *  - 0x00: AoA
   *  - 0x01: AoD_1us
   *  - 0x02: AoD_2us
   *  - 0xFF: NO_CTE
   */
  uint8_t CTE_Type;
  /** The response slot the data was received in.
   */
  uint8_t Response_Slot;
  /** 0x00: Data complete 0x01: Data incomplete, more data to come 0xFF: Failed to
   *  receive an AUX_SYNC_SUBEVENT_RSP PDU
   *  Values:
   *  - 0x00: DATA_COMPLETE
   *  - 0x01: MORE_DATA
   *  - 0xFF: RX_FAILED
   */
  uint8_t Data_Status;
  /** Length of the Data field.
   */
  uint8_t Data_Length;
  /** Periodic advertising response data formatted as defined in [Vol 3] Part C,
   *  Section 11. Note: Each element of this array has a variable length.
   */
  uint8_t Data[1];
} packed_Periodic_Advertising_Response_t;

typedef PACKED(struct) hci_disconnect_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The reason for ending the connection.
 * Values:
 * - 0x05: Authentication Failure
 * - 0x13: Remote User Terminated Connection
 * - 0x14: Remote Device Terminated Connection due to Low Resources
 * - 0x15: Remote Device Terminated Connection due to Power Off
 * - 0x1A: Unsupported Remote Feature
 * - 0x3B: Unacceptable Connection Parameters
 */
  uint8_t Reason;
} hci_disconnect_cp0;

typedef PACKED(struct) hci_disconnect_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_disconnect_rp0;

typedef PACKED(struct) hci_read_remote_version_information_cp0_s {
/**
 * Specifies which Connection_Handle's version information to get.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_read_remote_version_information_cp0;

typedef PACKED(struct) hci_read_remote_version_information_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_read_remote_version_information_rp0;

typedef PACKED(struct) hci_set_event_mask_cp0_s {
/**
 * Event mask. Default: 0x00001FFFFFFFFFFF
 * Flags:
 * - 0x0000000000000000: No events specified
 * - 0x0000000000000001: Inquiry Complete Event
 * - 0x0000000000000002: Inquiry Result Event
 * - 0x0000000000000004: Connection Complete Event
 * - 0x0000000000000008: Connection Request Event
 * - 0x0000000000000010: Disconnection Complete Event
 * - 0x0000000000000020: Authentication Complete Event
 * - 0x0000000000000040: Remote Name Request Complete Event
 * - 0x0000000000000080: Encryption Change Event
 * - 0x0000000000000100: Change Connection Link Key Complete Event
 * - 0x0000000000000200: Central Link Key Complete Event
 * - 0x0000000000000400: Read Remote Supported Features Complete Event
 * - 0x0000000000000800: Read Remote Version Information Complete Event
 * - 0x0000000000001000: QoS Setup Complete Event
 * - 0x0000000000008000: Hardware Error Event
 * - 0x0000000000010000: Flush Occurred Event
 * - 0x0000000000020000: Role Change Event
 * - 0x0000000000080000: Mode Change Event
 * - 0x0000000000100000: Return Link Keys Event
 * - 0x0000000000200000: PIN Code Request Event
 * - 0x0000000000400000: Link Key Request Event
 * - 0x0000000000800000: Link Key Notification Event
 * - 0x0000000001000000: Loopback Command Event
 * - 0x0000000002000000: Data Buffer Overflow Event
 * - 0x0000000004000000: Max Slots Change Event
 * - 0x0000000008000000: Read Clock Offset Complete Event
 * - 0x0000000010000000: Connection Packet Type Changed Event
 * - 0x0000000020000000: QoS Violation Event
 * - 0x0000000040000000: Page Scan Mode Change Event
 * - 0x0000000080000000: Page Scan Repetition Mode Change Event
 * - 0x0000000100000000: Flow Specification Complete Event
 * - 0x0000000200000000: Inquiry Result with RSSI Event
 * - 0x0000000400000000: Read Remote Extended Features Complete Event
 * - 0x0000080000000000: Synchronous Connection Complete Event
 * - 0x0000100000000000: Synchronous Connection Changed Event
 * - 0x0000200000000000: Sniff Subrating Event
 * - 0x0000400000000000: Extended Inquiry Result Event
 * - 0x0000800000000000: Encryption Key Refresh Complete Event
 * - 0x0001000000000000: IO Capability Request Event
 * - 0x0002000000000000: IO Capability Request Reply Event
 * - 0x0004000000000000: User Confirmation Request Event
 * - 0x0008000000000000: User Passkey Request Event
 * - 0x0010000000000000: Remote OOB Data Request Event
 * - 0x0020000000000000: Simple Pairing Complete Event
 * - 0x0080000000000000: Link Supervision Timeout Changed Event
 * - 0x0100000000000000: Enhanced Flush Complete Event
 * - 0x0400000000000000: User Passkey Notification Event
 * - 0x0800000000000000: Keypress Notification Event
 * - 0x1000000000000000: Remote Host Supported Features Notification Event
 * - 0x2000000000000000: LE Meta-Event
 */
  uint8_t Event_Mask[8];
} hci_set_event_mask_cp0;

typedef PACKED(struct) hci_set_event_mask_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_set_event_mask_rp0;

typedef PACKED(struct) hci_reset_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_reset_rp0;

typedef PACKED(struct) hci_read_connection_accept_timeout_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection Accept Timeout. Interval Length = N * 0.625 ms
 * Values:
 * - 0x0001 (0.625 ms)  ... 0xB540 (29000.000 ms) 
 */
  uint16_t Connection_Accept_Timeout;
} hci_read_connection_accept_timeout_rp0;

typedef PACKED(struct) hci_write_connection_accept_timeout_cp0_s {
/**
 * Connection Accept Timeout. Interval Length = N * 0.625 ms Default: 0x1FA0
 * Time = 5.06 s Mandatory Range for Controller: 0x00A0 to 0xB540
 * Values:
 * - 0x0001 (0.625 ms)  ... 0xB540 (29000.000 ms) 
 */
  uint16_t Connection_Accept_Timeout;
} hci_write_connection_accept_timeout_cp0;

typedef PACKED(struct) hci_write_connection_accept_timeout_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_write_connection_accept_timeout_rp0;

typedef PACKED(struct) hci_read_transmit_power_level_cp0_s {
/**
 * Specifies which Connection_Handle's Transmit Power Level setting to read.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Current or maximum transmit power level.
 * Values:
 * - 0x00: Read Current Transmit Power Level.
 * - 0x01: Read Maximum Transmit Power Level.
 */
  uint8_t Type;
} hci_read_transmit_power_level_cp0;

typedef PACKED(struct) hci_read_transmit_power_level_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Size: 1 Octet (signed integer) Units: dBm
 * Values:
 * - -30 ... 20
 */
  int8_t Transmit_Power_Level;
} hci_read_transmit_power_level_rp0;

typedef PACKED(struct) hci_read_afh_channel_assessment_mode_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Enable or disable channel assessment scheme.
 * Values:
 * - 0x00: DISABLED
 * - 0x01: ENABLED
 */
  uint8_t AFH_Channel_Assessment_Mode;
} hci_read_afh_channel_assessment_mode_rp0;

typedef PACKED(struct) hci_write_afh_channel_assessment_mode_cp0_s {
/**
 *
 * Values:
 * - 0x00: DISABLED
 * - 0x01: ENABLED
 */
  uint8_t AFH_Channel_Assessment_Mode;
} hci_write_afh_channel_assessment_mode_cp0;

typedef PACKED(struct) hci_write_afh_channel_assessment_mode_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_write_afh_channel_assessment_mode_rp0;

typedef PACKED(struct) hci_set_event_mask_page_2_cp0_s {
/**
 * For the complete list of bits that can be set, see Core v5.1, Vol 2, part E,
 * chapter 7.3.69. The only bit that is not ignored is: Bit 23: Authenticated
 * Payload Timeout Expired event.
 * Flags:
 * - 0x0000000000800000: AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED_EVENT
 */
  uint8_t Event_Mask_Page_2[8];
} hci_set_event_mask_page_2_cp0;

typedef PACKED(struct) hci_set_event_mask_page_2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_set_event_mask_page_2_rp0;

typedef PACKED(struct) hci_read_authenticated_payload_timeout_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_read_authenticated_payload_timeout_cp0;

typedef PACKED(struct) hci_read_authenticated_payload_timeout_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Maximum amount of time specified between packets authenticated by a MIC. Time
 * = N * 10 ms.
 * Values:
 * - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
 */
  uint16_t Authenticated_Payload_Timeout;
} hci_read_authenticated_payload_timeout_rp0;

typedef PACKED(struct) hci_write_authenticated_payload_timeout_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Maximum amount of time specified between packets authenticated by a valid
 * MIC. Time = N * 10 ms.
 * Values:
 * - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
 */
  uint16_t Authenticated_Payload_Timeout;
} hci_write_authenticated_payload_timeout_cp0;

typedef PACKED(struct) hci_write_authenticated_payload_timeout_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_write_authenticated_payload_timeout_rp0;

typedef PACKED(struct) hci_read_local_version_information_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-
 * us/specification/assigned-numbers)
 */
  uint8_t HCI_Version;
/**
 * Revision of the Current HCI in the BR/EDR Controller.
 */
  uint16_t HCI_Revision;
/**
 * Version of the Current LMP or PAL in the Controller. See Bluetooth Assigned
 * Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)
 */
  uint8_t LMP_PAL_Version;
/**
 * Manufacturer Name of the BR/EDR Controller. See Bluetooth Assigned Numbers
 * (https://www.bluetooth.org/en-us/specification/assigned-numbers)
 */
  uint16_t Manufacturer_Name;
/**
 * Subversion of the Current LMP or PAL in the Controller. This value is
 * implementation dependent.
 */
  uint16_t LMP_PAL_Subversion;
} hci_read_local_version_information_rp0;

typedef PACKED(struct) hci_read_local_supported_commands_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Bit mask for each HCI Command. If a bit is 1, the Controller supports the
 * corresponding command and the features required for the command. Unsupported
 * or undefined commands shall be set to 0.
 */
  uint8_t Supported_Commands[64];
} hci_read_local_supported_commands_rp0;

typedef PACKED(struct) hci_read_local_supported_features_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Bit Mask List of LMP features.
 */
  uint8_t LMP_Features[8];
} hci_read_local_supported_features_rp0;

typedef PACKED(struct) hci_read_bd_addr_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * BD_ADDR ( Bluetooth Device Address) of the Device.
 */
  uint8_t BD_ADDR[6];
} hci_read_bd_addr_rp0;

typedef PACKED(struct) hci_read_rssi_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_read_rssi_cp0;

typedef PACKED(struct) hci_read_rssi_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * N Size: 1 Octet (signed integer) Units: dBm
 * Values:
 * - -127 ... 20
 * - 127: RSSI not available
 */
  int8_t RSSI;
} hci_read_rssi_rp0;

typedef PACKED(struct) hci_le_set_event_mask_cp0_s {
/**
 * LE event mask. Default: 0x000000000000001F.
 * Flags:
 * - 0x0000000000000000: No LE events specified
 * - 0x0000000000000001: LE Connection Complete Event
 * - 0x0000000000000002: LE Advertising Report Event
 * - 0x0000000000000004: LE Connection Update Complete Event
 * - 0x0000000000000008: LE Read Remote Used Features Complete Event
 * - 0x0000000000000010: LE Long Term Key Request Event
 * - 0x0000000000000020: LE Remote Connection Parameter Request Event
 * - 0x0000000000000040: LE Data Length Change Event
 * - 0x0000000000000080: LE Read Local P-256 Public Key Complete Event
 * - 0x0000000000000100: LE Generate DHKey Complete Event
 * - 0x0000000000000200: LE Enhanced Connection Complete Event
 * - 0x0000000000000400: LE Directed Advertising Report Event
 * - 0x0000000000000800: LE PHY Update Complete event
 * - 0x0000000000001000: LE Extended Advertising Report event
 * - 0x0000000000002000: LE Periodic Advertising Sync Established event
 * - 0x0000000000004000: LE Periodic Advertising Report event
 * - 0x0000000000008000: LE Periodic Advertising Sync Lost event
 * - 0x0000000000010000: LE Scan Timeout event
 * - 0x0000000000020000: LE Advertising Set Terminated event
 * - 0x0000000000040000: LE Scan Request Received event
 * - 0x0000000000080000: LE Channel Selection Algorithm event
 * - 0x0000000000100000: LE Connectionless IQ Report event
 * - 0x0000000000200000: LE Connection IQ Report event
 * - 0x0000000000400000: LE CTE Request Failed event
 * - 0x0000000000800000: LE Periodic Advertising Sync Transfer Received event
 * - 0x0000000001000000: LE CIS Established event
 * - 0x0000000002000000: LE CIS Request event
 * - 0x0000000004000000: LE Create BIG Complete event
 * - 0x0000000008000000: LE Terminate BIG Complete event
 * - 0x0000000010000000: LE BIG Sync Established event
 * - 0x0000000020000000: LE BIG Sync Lost event
 * - 0x0000000040000000: LE Request Peer SCA Complete event
 * - 0x0000000080000000: LE Path Loss Threshold event
 * - 0x0000000100000000: LE Transmit Power Reporting event
 * - 0x0000000200000000: LE BIGInfo Advertising Report event
 * - 0x0000000400000000: LE Subrate Change event
 * - 0x0000000800000000: LE Periodic Advertising Sync Established event [v2]
 * - 0x0000001000000000: LE Periodic Advertising Report event [v2]
 * - 0x0000002000000000: LE Periodic Advertising Sync Transfer Received event [v2]
 * - 0x0000004000000000: LE Periodic Advertising Subevent Data Request event
 * - 0x0000008000000000: LE Periodic Advertising Response Report event
 * - 0x0000010000000000: LE Enhanced Connection Complete event [v2]
 */
  uint8_t LE_Event_Mask[8];
} hci_le_set_event_mask_cp0;

typedef PACKED(struct) hci_le_set_event_mask_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_event_mask_rp0;

typedef PACKED(struct) hci_le_read_buffer_size_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * 0x0000: No dedicated LE Buffer exists. Use the HCI_Read_Buffer_Size command.
 * 0x001B - 0xFFFF Maximum length (in octets) of the data portion of each HCI
 * ACL data packet.
 * Values:
 * - 0x0000: NO_BUFFER
 * - 0x001B ... 0xFFFF
 */
  uint16_t HC_LE_ACL_Data_Packet_Length;
/**
 * 0x00: No dedicated LE Buffer exists. Use the HCI_Read_Buffer_Size command.
 * 0x01 - 0xFF: Total number of HCI ACL Data Packets that can be stored in the
 * data buffers of the Controller.
 * Values:
 * - 0x00: NO_BUFFER
 * - 0x01 ... 0xFF
 */
  uint8_t HC_Total_Num_LE_ACL_Data_Packets;
} hci_le_read_buffer_size_rp0;

typedef PACKED(struct) hci_le_read_local_supported_features_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Bit Mask List of LE features. See Core v4.1, Vol. 6, Part B, Section 4.6.
 */
  uint8_t LE_Features[8];
} hci_le_read_local_supported_features_rp0;

typedef PACKED(struct) hci_le_set_random_address_cp0_s {
/**
 * Random Device Address.
 */
  uint8_t Random_Address[6];
} hci_le_set_random_address_cp0;

typedef PACKED(struct) hci_le_set_random_address_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_random_address_rp0;

typedef PACKED(struct) hci_le_set_advertising_parameters_cp0_s {
/**
 * Minimum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 msec.
 * Values:
 * - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) 
 */
  uint16_t Advertising_Interval_Min;
/**
 * Maximum advertising interval. Time = N * 0.625 msec.
 * Values:
 * - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) 
 */
  uint16_t Advertising_Interval_Max;
/**
 * Advertising type.
 * Values:
 * - 0x00: ADV_IND (Connectable undirected advertising)
 * - 0x01: ADV_DIRECT_IND, high duty cycle (Connectable high duty cycle directed advertising)
 * - 0x02: ADV_SCAN_IND (Scannable undirected advertising)
 * - 0x03: ADV_NONCONN_IND (Non connectable undirected advertising)
 * - 0x04: ADV_DIRECT_IND, low duty cycle (Connectable low duty cycle directed advertising)
 */
  uint8_t Advertising_Type;
/**
 * Own address type.  - 0x00: Public Device Address  - 0x01 Random Device
 * Address  - 0x02: Controller generates Resolvable Private Address based on the
 * local          IRK from resolving list. If resolving list contains no
 * matching entry,          use public address.  - 0x03: Controller generates
 * Resolvable Private Address based on the local          IRK from resolving
 * list. If resolving list contains no matching entry,          use random
 * address from LE_Set_Random_Address.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Resolvable Private Address or Public Address
 * - 0x03: Resolvable Private Address or Random Address
 */
  uint8_t Own_Address_Type;
/**
 * Peer Address type.
 * Values:
 * - 0x00: Public Device Address or Public Identity Address
 * - 0x01: Random Device Address or Random (static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Advertising channel map. Default: 00000111b (all channels enabled).
 * Flags:
 * - 0x01: ch 37
 * - 0x02: ch 38
 * - 0x04: ch 39
 */
  uint8_t Advertising_Channel_Map;
/**
 * Advertising Filter Policy. This parameter is ignored when directed
 * advertising is enabled.  0x00 Process scan and connection requests from all
 * devices (i.e., the Filter Accept List is not in use) 0x01 Process connection
 * requests from all devices and scan requests only from devices that are in the
 * Filter Accept List 0x02 Process scan requests from all devices and connection
 * requests only from devices that are in the Filter Accept List. 0x03 Process
 * scan and connection requests only from devices in the Filter Accept List. All
 * other values are reserved for future use
 * Values:
 * - 0x00: HCI_ADV_FILTER_NONE
 * - 0x01: HCI_ADV_FILTER_ACCEPT_LIST_SCAN
 * - 0x02: HCI_ADV_FILTER_ACCEPT_LIST_CONNECT
 * - 0x03: HCI_ADV_FILTER_ACCEPT_LIST_SCAN_CONNECT
 */
  uint8_t Advertising_Filter_Policy;
} hci_le_set_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_advertising_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_read_advertising_physical_channel_tx_power_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Size: 1 Octet (signed integer) Units: dBm Accuracy: +/- 4 dBm
 * Values:
 * - -20 ... 10
 */
  int8_t Transmit_Power_Level;
} hci_le_read_advertising_physical_channel_tx_power_rp0;

typedef PACKED(struct) hci_le_set_advertising_data_cp0_s {
/**
 * The number of significant octets in the following data field
 * Values:
 * - 0 ... 31
 */
  uint8_t Advertising_Data_Length;
/**
 * 31 octets of data formatted as defined in [Vol 3] Part C, Section 11.
 */
  uint8_t Advertising_Data[31];
} hci_le_set_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_advertising_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_scan_response_data_cp0_s {
/**
 * The number of significant octets in the following data field
 * Values:
 * - 0 ... 31
 */
  uint8_t Scan_Response_Data_Length;
/**
 * 31 octets of data formatted as defined in [Vol 3] Part C, Section 11.
 */
  uint8_t Scan_Response_Data[31];
} hci_le_set_scan_response_data_cp0;

typedef PACKED(struct) hci_le_set_scan_response_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_scan_response_data_rp0;

typedef PACKED(struct) hci_le_set_advertising_enable_cp0_s {
/**
 * Enable/disable advertise. Default is 0 (disabled).
 * Values:
 * - 0x00: Disable
 * - 0x01: Enable
 */
  uint8_t Advertising_Enable;
} hci_le_set_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_advertising_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_advertising_enable_rp0;

typedef PACKED(struct) hci_le_set_scan_parameters_cp0_s {
/**
 * Passive or active scanning. With active scanning SCAN_REQ packets are sent.
 * Values:
 * - 0x00: Passive Scanning
 * - 0x01: Active scanning
 */
  uint8_t LE_Scan_Type;
/**
 * This is defined as the time interval from when the Controller started its
 * last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec.
 * Values:
 * - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 */
  uint16_t LE_Scan_Interval;
/**
 * The duration of the LE scan. LE_Scan_Window shall be less than or equal to
 * LE_Scan_Interval. Time = N * 0.625 msec.
 * Values:
 * - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 */
  uint16_t LE_Scan_Window;
/**
 * Own address type.  - 0x00: Public Device Address  - 0x01 Random Device
 * Address  - 0x02: Controller generates Resolvable Private Address based on the
 * local          IRK from resolving list. If resolving list contains no
 * matching entry,          use public address.  - 0x03: Controller generates
 * Resolvable Private Address based on the local          IRK from resolving
 * list. If resolving list contains no matching entry,          use random
 * address from LE_Set_Random_Address.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Resolvable Private Address or Public Address
 * - 0x03: Resolvable Private Address or Random Address
 */
  uint8_t Own_Address_Type;
/**
 * See Scanning filter policy in Bluetooth Core specification.
 * Values:
 * - 0x00: Basic unfiltered scanning filter policy
 * - 0x01: Basic filtered scanning filter policy
 * - 0x02: Extended unfiltered scanning filter policy
 * - 0x03: Extended filtered scanning filter policy
 */
  uint8_t Scanning_Filter_Policy;
} hci_le_set_scan_parameters_cp0;

typedef PACKED(struct) hci_le_set_scan_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_scan_parameters_rp0;

typedef PACKED(struct) hci_le_set_scan_enable_cp0_s {
/**
 * Enable/disable scan. Default is 0 (disabled).
 * Values:
 * - 0x00: Scanning disabled
 * - 0x01: Scanning enabled
 */
  uint8_t LE_Scan_Enable;
/**
 * Enable/disable duplicate filtering.
 * Values:
 * - 0x00: Duplicate filtering disabled
 * - 0x01: Duplicate filtering enabled
 */
  uint8_t Filter_Duplicates;
} hci_le_set_scan_enable_cp0;

typedef PACKED(struct) hci_le_set_scan_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_scan_enable_rp0;

typedef PACKED(struct) hci_le_create_connection_cp0_s {
/**
 * This is defined as the time interval from when the Controller started its
 * last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec.
 * Values:
 * - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 */
  uint16_t LE_Scan_Interval;
/**
 * The duration of the LE scan. LE_Scan_Window shall be less than or equal to
 * LE_Scan_Interval. Time = N * 0.625 msec.
 * Values:
 * - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 */
  uint16_t LE_Scan_Window;
/**
 * 0x00 Filter Accept List is not used to determine which advertiser to connect
 * to. Peer_Address_Type and Peer_Address shall be used. 0x01 Filter Accept List
 * is used to determine which advertiser to connect to. Peer_Address_Type and
 * Peer_Address shall be ignored.
 * Values:
 * - 0x00: Filter Accept List not used
 * - 0x01: Filter Accept List used
 */
  uint8_t Initiator_Filter_Policy;
/**
 * 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
 * Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
 * Identity Address (Corresponds to Resolved Private Address)
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address
 * - 0x03: Random (Static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the advertising device.
 */
  uint8_t Peer_Address[6];
/**
 * Own address type.  - 0x00: Public Device Address  - 0x01 Random Device
 * Address  - 0x02: Controller generates Resolvable Private Address based on the
 * local          IRK from resolving list. If resolving list contains no
 * matching entry,          use public address.  - 0x03: Controller generates
 * Resolvable Private Address based on the local          IRK from resolving
 * list. If resolving list contains no matching entry,          use random
 * address from LE_Set_Random_Address.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Resolvable Private Address or Public Address
 * - 0x03: Resolvable Private Address or Random Address
 */
  uint8_t Own_Address_Type;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * The minimum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Min_CE_Length;
/**
 * The maximum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Max_CE_Length;
} hci_le_create_connection_cp0;

typedef PACKED(struct) hci_le_create_connection_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_create_connection_rp0;

typedef PACKED(struct) hci_le_create_connection_cancel_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_create_connection_cancel_rp0;

typedef PACKED(struct) hci_le_read_filter_accept_list_size_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Total number of Filter Accept List entries that can be stored in the
 * Controller.
 */
  uint8_t Filter_Accept_List_Size;
} hci_le_read_filter_accept_list_size_rp0;

typedef PACKED(struct) hci_le_clear_filter_accept_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_clear_filter_accept_list_rp0;

typedef PACKED(struct) hci_le_add_device_to_filter_accept_list_cp0_s {
/**
 * Address type.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 */
  uint8_t Address_Type;
/**
 * Public Device Address or Random Device Address of the device to be added to
 * the list.
 */
  uint8_t Address[6];
} hci_le_add_device_to_filter_accept_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_filter_accept_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_add_device_to_filter_accept_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_filter_accept_list_cp0_s {
/**
 * Address type.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 */
  uint8_t Address_Type;
/**
 * Public Device Address or Random Device Address of the device to be removed
 * from the Filter Accept List.
 */
  uint8_t Address[6];
} hci_le_remove_device_from_filter_accept_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_filter_accept_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_remove_device_from_filter_accept_list_rp0;

typedef PACKED(struct) hci_le_connection_update_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * The minimum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Min_CE_Length;
/**
 * The maximum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Max_CE_Length;
} hci_le_connection_update_cp0;

typedef PACKED(struct) hci_le_connection_update_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_connection_update_rp0;

typedef PACKED(struct) hci_le_set_host_channel_classification_cp0_s {
/**
 * This parameter contains 37 1-bit fields. The nth such field (in the range 0
 * to 36) contains the value for the link layer channel index n. Channel n is
 * bad = 0. Channel n is unknown = 1. The most significant bits are reserved and
 * shall be set to 0. At least one channel shall be marked as unknown.
 * Flags:
 * - 0x0000000000 ... 0x1FFFFFFFFF
 */
  uint8_t LE_Channel_Map[5];
} hci_le_set_host_channel_classification_cp0;

typedef PACKED(struct) hci_le_set_host_channel_classification_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_host_channel_classification_rp0;

typedef PACKED(struct) hci_le_read_channel_map_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_read_channel_map_cp0;

typedef PACKED(struct) hci_le_read_channel_map_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * This parameter contains 37 1-bit fields. The nth such field (in the range 0
 * to 36) contains the value for the link layer channel index n. Channel n is
 * unused = 0. Channel n is used = 1. The most significant bits are reserved and
 * shall be set to 0.
 */
  uint8_t LE_Channel_Map[5];
} hci_le_read_channel_map_rp0;

typedef PACKED(struct) hci_le_read_remote_features_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_read_remote_features_cp0;

typedef PACKED(struct) hci_le_read_remote_features_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_read_remote_features_rp0;

typedef PACKED(struct) hci_le_encrypt_cp0_s {
/**
 * 128 bit key for the encryption of the data given in the command.
 */
  uint8_t Key[16];
/**
 * 128 bit data block that is requested to be encrypted.
 */
  uint8_t Plaintext_Data[16];
} hci_le_encrypt_cp0;

typedef PACKED(struct) hci_le_encrypt_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * 128 bit encrypted data block.
 */
  uint8_t Encrypted_Data[16];
} hci_le_encrypt_rp0;

typedef PACKED(struct) hci_le_rand_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Random Number
 */
  uint8_t Random_Number[8];
} hci_le_rand_rp0;

typedef PACKED(struct) hci_le_enable_encryption_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * 64 bit random number.
 */
  uint8_t Random_Number[8];
/**
 * 16 bit encrypted diversifier.
 */
  uint16_t Encrypted_Diversifier;
/**
 * 128 bit long term key.
 */
  uint8_t Long_Term_Key[16];
} hci_le_enable_encryption_cp0;

typedef PACKED(struct) hci_le_enable_encryption_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_enable_encryption_rp0;

typedef PACKED(struct) hci_le_long_term_key_request_reply_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * 128 bit long term key.
 */
  uint8_t Long_Term_Key[16];
} hci_le_long_term_key_request_reply_cp0;

typedef PACKED(struct) hci_le_long_term_key_request_reply_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_reply_rp0;

typedef PACKED(struct) hci_le_long_term_key_request_negative_reply_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_negative_reply_cp0;

typedef PACKED(struct) hci_le_long_term_key_request_negative_reply_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_negative_reply_rp0;

typedef PACKED(struct) hci_le_read_supported_states_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * State or state combination is supported by the Controller. See Core v4.1,
 * Vol.2, part E, Ch. 7.8.27.
 */
  uint8_t LE_States[8];
} hci_le_read_supported_states_rp0;

typedef PACKED(struct) hci_le_receiver_test_cp0_s {
/**
 *
 * Values:
 * - 0x00 ... 0x27: N = (F - 2402) / 2.Frequency Range : 2402 MHz to 2480 MHz
 */
  uint8_t RX_Frequency;
} hci_le_receiver_test_cp0;

typedef PACKED(struct) hci_le_receiver_test_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_receiver_test_rp0;

typedef PACKED(struct) hci_le_transmitter_test_cp0_s {
/**
 * N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 * Values:
 * - 0x00 ... 0x27
 */
  uint8_t TX_Frequency;
/**
 * Length in bytes of payload data in each packet.     Supported ranges:       -
 * (0x00,0x25) if data length extension is disabled.       - (0x00,0xFF) if data
 * length extension is enabled.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Length_Of_Test_Data;
/**
 * Content of the Payload of the test reference packets.  0: PRBS9 sequence
 * '11111111100000111101...' (in transmission order) 1: Repeated '11110000' (in
 * transmission order) sequence 2: Repeated '10101010' (in transmission order)
 * sequence 3: PRBS15 sequence 4: Repeated '11111111' (in transmission order)
 * sequence 5: Repeated '00000000' (in transmission order) sequence 6: Repeated
 * '00001111' (in transmission order) sequence 7: Repeated '01010101' (in
 * transmission order) sequence
 * Values:
 * - 0x00: PRBS9
 * - 0x01: Repeated '11110000'
 * - 0x02: Repeated '10101010'
 * - 0x03: PRBS15
 * - 0x04: Repeated '11111111'
 * - 0x05: Repeated '00000000'
 * - 0x06: Repeated '00001111'
 * - 0x07: Repeated '01010101'
 */
  uint8_t Packet_Payload;
} hci_le_transmitter_test_cp0;

typedef PACKED(struct) hci_le_transmitter_test_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_transmitter_test_rp0;

typedef PACKED(struct) hci_le_test_end_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Number of packets received.
 */
  uint16_t Number_Of_Packets;
} hci_le_test_end_rp0;

typedef PACKED(struct) hci_le_set_data_length_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Preferred maximum number of payload octets that the local Controller should
 * include in a single Link Layer Data Channel PDU. Range 0x001B-0x00FB (0x0000
 * - 0x001A and 0x00FC - 0xFFFF) Reserved for future use). Default: 27 bytes.
 * Values:
 * - 0x001B ... 0x00FB
 */
  uint16_t TxOctets;
/**
 * Preferred maximum number of microseconds that the local Controller should use
 * to transmit a single Link Layer Data Channel PDU. Range 0x0148-0x0848 (0x0000
 * - 0x0147 and 0x0849 - 0xFFFF Reserved for future use). Default: 328 bytes.
 * Values:
 * - 0x0148 ... 0x0848
 */
  uint16_t TxTime;
} hci_le_set_data_length_cp0;

typedef PACKED(struct) hci_le_set_data_length_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
} hci_le_set_data_length_rp0;

typedef PACKED(struct) hci_le_read_suggested_default_data_length_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The Host suggested value for the Controller maximum transmitted number of
 * payload octets to be used for new connections - connInitialMaxTxOctets. Range
 * 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 * Default: 0x001B
 */
  uint16_t SuggestedMaxTxOctets;
/**
 * The Host suggested value for the Controller maximum packet transmission time
 * to be used for new connections - connInitialMaxTx-Time. Range 0x0148-0x0848
 * (0x0000 - 0x0147 and 0x0849 - 0xFFFF Reserved for future use) Default: 0x0148
 */
  uint16_t SuggestedMaxTxTime;
} hci_le_read_suggested_default_data_length_rp0;

typedef PACKED(struct) hci_le_write_suggested_default_data_length_cp0_s {
/**
 * The Host suggested value for the Controller maximum transmitted number of
 * payload octets to be used for new connections - connInitialMaxTxOctets. Range
 * 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 * Values:
 * - 0x001B ... 0x00FB
 */
  uint16_t SuggestedMaxTxOctets;
/**
 * The Host suggested value for the Controller maximum packet transmission time
 * to be used for new connections - connInitialMaxTx-Time. Range 0x0148-0x0848
 * (0x0000 - 0x0147 and 0x0849 - 0xFFFF Reserved for future use)
 * Values:
 * - 0x0148 ... 0x0848
 */
  uint16_t SuggestedMaxTxTime;
} hci_le_write_suggested_default_data_length_cp0;

typedef PACKED(struct) hci_le_write_suggested_default_data_length_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_write_suggested_default_data_length_rp0;

typedef PACKED(struct) hci_le_read_local_p256_public_key_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_read_local_p256_public_key_rp0;

typedef PACKED(struct) hci_le_generate_dhkey_cp0_s {
/**
 * The remote P-256 public key: X, Y format Octets 31-0: X co-ordinate Octets
 * 63-32: Y co-ordinate Little Endian Format
 */
  uint8_t Remote_P256_Public_Key[64];
} hci_le_generate_dhkey_cp0;

typedef PACKED(struct) hci_le_generate_dhkey_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_generate_dhkey_rp0;

typedef PACKED(struct) hci_le_add_device_to_resolving_list_cp0_s {
/**
 * Identity address type.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Peer_Identity_Address_Type;
/**
 * Public or Random (static) Identity address of the peer device
 */
  uint8_t Peer_Identity_Address[6];
/**
 * IRK of the peer device
 */
  uint8_t Peer_IRK[16];
/**
 * IRK of the local device
 */
  uint8_t Local_IRK[16];
} hci_le_add_device_to_resolving_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_resolving_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_add_device_to_resolving_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_resolving_list_cp0_s {
/**
 * Identity address type.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Peer_Identity_Address_Type;
/**
 * Public or Random (static) Identity address of the peer device
 */
  uint8_t Peer_Identity_Address[6];
} hci_le_remove_device_from_resolving_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_resolving_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_remove_device_from_resolving_list_rp0;

typedef PACKED(struct) hci_le_clear_resolving_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_clear_resolving_list_rp0;

typedef PACKED(struct) hci_le_read_resolving_list_size_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Number of address translation entries in the resolving list
 */
  uint8_t Resolving_List_Size;
} hci_le_read_resolving_list_size_rp0;

typedef PACKED(struct) hci_le_read_peer_resolvable_address_cp0_s {
/**
 * Identity address type.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Peer_Identity_Address_Type;
/**
 * Public or Random (static) Identity address of the peer device
 */
  uint8_t Peer_Identity_Address[6];
} hci_le_read_peer_resolvable_address_cp0;

typedef PACKED(struct) hci_le_read_peer_resolvable_address_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Resolvable Private Address being used by the peer device
 */
  uint8_t Peer_Resolvable_Address[6];
} hci_le_read_peer_resolvable_address_rp0;

typedef PACKED(struct) hci_le_read_local_resolvable_address_cp0_s {
/**
 * Identity address type.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Peer_Identity_Address_Type;
/**
 * Public or Random (static) Identity address of the peer device
 */
  uint8_t Peer_Identity_Address[6];
} hci_le_read_local_resolvable_address_cp0;

typedef PACKED(struct) hci_le_read_local_resolvable_address_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Resolvable Private Address being used by the local device
 */
  uint8_t Local_Resolvable_Address[6];
} hci_le_read_local_resolvable_address_rp0;

typedef PACKED(struct) hci_le_set_address_resolution_enable_cp0_s {
/**
 * Enable/disable address resolution in the controller. 0x00: Address Resolution
 * in controller disabled (default), 0x01: Address Resolution in controller
 * enabled
 * Values:
 * - 0x00: Address Resolution in controller disabled (default)
 * - 0x01: Address Resolution in controller enabled
 */
  uint8_t Address_Resolution_Enable;
} hci_le_set_address_resolution_enable_cp0;

typedef PACKED(struct) hci_le_set_address_resolution_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_address_resolution_enable_rp0;

typedef PACKED(struct) hci_le_set_resolvable_private_address_timeout_cp0_s {
/**
 * RPA_Timeout measured in seconds. Range for N: 0x0001 - 0x0E10 (1 sec - 1
 * hour) Default: N= 0x0384 (900 secs or 15 minutes)
 * Values:
 * - 0x0001 ... 0x0E10
 */
  uint16_t RPA_Timeout;
} hci_le_set_resolvable_private_address_timeout_cp0;

typedef PACKED(struct) hci_le_set_resolvable_private_address_timeout_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_resolvable_private_address_timeout_rp0;

typedef PACKED(struct) hci_le_read_maximum_data_length_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Maximum number of payload octets that the local Controller supports for
 * transmission of a single Link Layer Data Channel PDU. Range 0x001B-0x00FB
 * (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 */
  uint16_t supportedMaxTxOctets;
/**
 * Maximum time, in microseconds, that the local Controller supports for
 * transmission of a single Link Layer Data Channel PDU. Range 0x0148-0x0848
 * (0x0000 - 0x0147 and 0x0849 - 0xFFFF Reserved for future use)
 */
  uint16_t supportedMaxTxTime;
/**
 * Maximum number of payload octets that the local Controller supports for
 * reception of a single Link Layer Data Channel PDU. Range 0x001B-0x00FB
 * (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 */
  uint16_t supportedMaxRxOctets;
/**
 * Maximum time, in microseconds, that the local Controller supports for
 * reception of a single Link Layer Data Channel PDU. Range 0x0148-0x0848
 * (0x0000 - 0x0147 and 0x0849 - 0xFFFF Reserved for future use)
 */
  uint16_t supportedMaxRxTime;
} hci_le_read_maximum_data_length_rp0;

typedef PACKED(struct) hci_le_read_phy_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_read_phy_cp0;

typedef PACKED(struct) hci_le_read_phy_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * Transmitter PHY for the connection 0x01: The transmitter PHY for the
 * connection is LE 1M 0x02: The transmitter PHY for the connection is LE 2M
 * 0x03: The transmitter PHY for the connection is LE Coded
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t TX_PHY;
/**
 * Receiver PHY for the connection. 0x01: The receiver PHY for the connection is
 * LE 1M 0x02: The receiver PHY for the connection is LE 2M 0x03: The receiver
 * PHY for the connection is LE Coded All other values: Reserved for future use
 * Values:
 * - 0x01: The receiver PHY for the connection is LE 1M
 * - 0x02: The receiver PHY for the connection is LE 2M
 * - 0x03: The receiver PHY for the connection is LE Coded
 */
  uint8_t RX_PHY;
} hci_le_read_phy_rp0;

typedef PACKED(struct) hci_le_set_default_phy_cp0_s {
/**
 * The ALL_PHYS parameter is a bit field that allows the Host to specify, for
 * each direction, whether it has no preference among the PHYs that the
 * Controller supports in a given direction or whether it has specified
 * particular PHYs that it prefers in the TX_PHYS or RX_PHYS parameter. Bits: 0:
 * The Host has no preference among the transmitter PHYs supported by the
 * Controller 1: The Host has no preference among the receiver PHYs supported by
 * the Controller
 * Flags:
 * - 0x01: No preference for TX
 * - 0x02: No preference for RX
 */
  uint8_t ALL_PHYS;
/**
 * The TX_PHYS parameter is a bit field that indicates the transmitter PHYs that
 * the Host prefers the Controller to use. If the ALL_PHYS parameter specifies
 * that the Host has no preference, the TX_PHYS parameter is ignored; otherwise
 * at least one bit shall be set to 1. Bits: 0: The Host prefers to use the LE
 * 1M transmitter PHY (possibly among others) 1: The Host prefers to use the LE
 * 2M transmitter PHY (possibly among others) 2: The Host prefers to use the LE
 * Coded transmitter PHY (possibly among others) 3-7: Reserved for future use
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t TX_PHYS;
/**
 * The RX_PHYS parameter is a bit field that indicates the receiver PHYs that
 * the Host prefers the Controller to use. If the ALL_PHYS parameter specifies
 * that the Host has no preference, the RX_PHYS parameter is ignored; otherwise
 * at least one bit shall be set to 1. Bits: 0: The Host prefers to use the LE
 * 1M receiver PHY (possibly among others) 1: The Host prefers to use the LE 2M
 * receiver PHY (possibly among others) 2: The Host prefers to use the LE Coded
 * receiver PHY (possibly among others) 3-7: Reserved for future use
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t RX_PHYS;
} hci_le_set_default_phy_cp0;

typedef PACKED(struct) hci_le_set_default_phy_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_default_phy_rp0;

typedef PACKED(struct) hci_le_set_phy_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The ALL_PHYS parameter is a bit field that allows the Host to specify, for
 * each direction, whether it has no preference among the PHYs that the
 * Controller supports in a given direction or whether it has specified
 * particular PHYs that it prefers in the TX_PHYS or RX_PHYS parameter. Bits: 0:
 * The Host has no preference among the transmitter PHYs supported by the
 * Controller 1: The Host has no preference among the receiver PHYs supported by
 * the Controller
 * Flags:
 * - 0x01: No preference for TX
 * - 0x02: No preference for RX
 */
  uint8_t ALL_PHYS;
/**
 * The TX_PHYS parameter is a bit field that indicates the transmitter PHYs that
 * the Host prefers the Controller to use. If the ALL_PHYS parameter specifies
 * that the Host has no preference, the TX_PHYS parameter is ignored; otherwise
 * at least one bit shall be set to 1. Bits: 0: The Host prefers to use the LE
 * 1M transmitter PHY (possibly among others) 1: The Host prefers to use the LE
 * 2M transmitter PHY (possibly among others) 2: The Host prefers to use the LE
 * Coded transmitter PHY (possibly among others) 3-7: Reserved for future use
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t TX_PHYS;
/**
 * The RX_PHYS parameter is a bit field that indicates the receiver PHYs that
 * the Host prefers the Controller to use. If the ALL_PHYS parameter specifies
 * that the Host has no preference, the RX_PHYS parameter is ignored; otherwise
 * at least one bit shall be set to 1. Bits: 0: The Host prefers to use the LE
 * 1M receiver PHY (possibly among others) 1: The Host prefers to use the LE 2M
 * receiver PHY (possibly among others) 2: The Host prefers to use the LE Coded
 * receiver PHY (possibly among others) 3-7: Reserved for future use
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t RX_PHYS;
/**
 * The PHY_options parameter is a bit field that allows the Host to specify
 * options for PHYs. The default value for a new connection shall be all zero
 * bits. The Controller may override any preferred coding for transmitting on
 * the LE Coded PHY. The Host may specify a preferred coding even if it prefers
 * not to use the LE Coded transmitter PHY since the Controller may override the
 * PHY preference.  0 = the Host has no preferred coding when transmitting on
 * the LE Coded PHY 1 = the Host prefers that S=2 coding be used when
 * transmitting on the LE Coded PHY 2 = the Host prefers that S=8 coding be used
 * when transmitting on the LE Coded PHY
 * Values:
 * - 0: No preferred LE Coded PHY
 * - 1: S=2 preferred on LE Coded PHY
 * - 2: S=8 preferred on LE Coded PHY
 */
  uint16_t PHY_options;
} hci_le_set_phy_cp0;

typedef PACKED(struct) hci_le_set_phy_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_phy_rp0;

typedef PACKED(struct) hci_le_receiver_test_v2_cp0_s {
/**
 * Frequency Range : 2402 MHz to 2480 MHz N = (F - 2402) / 2.
 * Values:
 * - 0x00 ... 0x27: Frequency Range : 2402 MHz to 2480 MHz
 */
  uint8_t RX_Channel;
/**
 * PHY to be used by the receiver.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY;
/**
 * The Modulation_Index parameter specifies whether or not the Controller should
 * assume the receiver has a stable modulation index.
 * Values:
 * - 0x00: Standard modulation index
 * - 0x01: Stable modulation index
 */
  uint8_t Modulation_index;
} hci_le_receiver_test_v2_cp0;

typedef PACKED(struct) hci_le_receiver_test_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_receiver_test_v2_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v2_cp0_s {
/**
 * Frequency Range: 2402 MHz to 2480 MHz N = (F-2402) / 2
 * Values:
 * - 0x00 ... 0x27: Frequency Range: 2402 MHz to 2480 MHz
 */
  uint8_t TX_Channel;
/**
 * Length in bytes of payload data in each packet.     Supported ranges:       -
 * (0x00,0x25) if data length extension is disabled.       - (0x00,0xFF) if data
 * length extension is enabled.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Length_Of_Test_Data;
/**
 * Content of the Payload of the test reference packets.  0: PRBS9 sequence
 * '11111111100000111101...' (in transmission order) 1: Repeated '11110000' (in
 * transmission order) sequence 2: Repeated '10101010' (in transmission order)
 * sequence 3: PRBS15 sequence 4: Repeated '11111111' (in transmission order)
 * sequence 5: Repeated '00000000' (in transmission order) sequence 6: Repeated
 * '00001111' (in transmission order) sequence 7: Repeated '01010101' (in
 * transmission order) sequence
 * Values:
 * - 0x00: PRBS9
 * - 0x01: Repeated '11110000'
 * - 0x02: Repeated '10101010'
 * - 0x03: PRBS15
 * - 0x04: Repeated '11111111'
 * - 0x05: Repeated '00000000'
 * - 0x06: Repeated '00001111'
 * - 0x07: Repeated '01010101'
 */
  uint8_t Packet_Payload;
/**
 * PHY to be used by the transmitter.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
} hci_le_transmitter_test_v2_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_transmitter_test_v2_rp0;

typedef PACKED(struct) hci_le_set_advertising_set_random_address_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * Random Device Address as defined by [Vol 6] Part B, Section 1.3.2
 */
  uint8_t Advertising_Random_Address[6];
} hci_le_set_advertising_set_random_address_cp0;

typedef PACKED(struct) hci_le_set_advertising_set_random_address_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_advertising_set_random_address_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_cp0_s {
/**
 * The Advertising_Handle parameter identifies the advertising set whose
 * parameters are being configured.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * The Advertising_Event_Properties parameter describes the type of advertising
 * event that is being configured and its basic properties. The type shall be
 * one supported by the Controller. Bits: 0 Connectable advertising 1 Scannable
 * advertising 2 Directed advertising 3 High Duty Cycle Directed Connectable
 * advertising (<= 3.75 ms Advertising Interval) 4 Use legacy advertising PDUs 5
 * Omit advertiser's address from all PDUs ("anonymous advertising") 6 Include
 * TxPower in the extended header of the advertising PDU
 * Flags:
 * - 0x0001: Connectable
 * - 0x0002: Scannable
 * - 0x0004: Directed
 * - 0x0008: HDC Directed Connectable
 * - 0x0010: Legacy
 * - 0x0020: Anonymous
 * - 0x0040: TxPower in ext header
 */
  uint16_t Advertising_Event_Properties;
/**
 * Minimum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 ms; Time Range: 20 ms to 10,485.759375 s.
 * Values:
 * - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 */
  uint8_t Primary_Advertising_Interval_Min[3];
/**
 * Maximum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 ms; Time Range: 20 ms to 10,485.759375 s.
 * Values:
 * - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 */
  uint8_t Primary_Advertising_Interval_Max[3];
/**
 * The Primary_Advertising_Channel_Map is a bit field that indicates the
 * advertising channels that shall be used when transmitting advertising
 * packets. At least one channel bit shall be set in the
 * Primary_Advertising_Channel_Map parameter.
 * Flags:
 * - 0x01: CH_37
 * - 0x02: CH_38
 * - 0x04: CH_39
 */
  uint8_t Primary_Advertising_Channel_Map;
/**
 * The Own_Address_Type parameter specifies the type of address being used in
 * the advertising packets. For random addresses, the address is specified by
 * the LE_Set_Advertising_Set_Random_Address command.  0x00 Public Device
 * Address 0x01 Random Device Address 0x02 Controller generates the Resolvable
 * Private Address based on the local IRK from the resolving list. If the
 * resolving list contains no matching entry, use the public address. 0x03
 * Controller generates the Resolvable Private Address based on the local IRK
 * from the resolving list. If the resolving list contains no matching entry,
 * use the random address from LE_Set_Advertising_Set_Random_Address. All other
 * values Reserved for future use
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Resolvable Private Address / Public Address
 * - 0x03: Resolvable Private Address / Random Address
 */
  uint8_t Own_Address_Type;
/**
 * Peer Address type
 * Values:
 * - 0x00: Public Device Address or Public Identity Address
 * - 0x01: Random Device Address or Random (static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Advertising Filter Policy. This parameter is ignored when directed
 * advertising is enabled.  0x00 Process scan and connection requests from all
 * devices (i.e., the Filter Accept List is not in use) 0x01 Process connection
 * requests from all devices and scan requests only from devices that are in the
 * Filter Accept List 0x02 Process scan requests from all devices and connection
 * requests only from devices that are in the Filter Accept List. 0x03 Process
 * scan and connection requests only from devices in the Filter Accept List. All
 * other values are reserved for future use
 * Values:
 * - 0x00: HCI_ADV_FILTER_NONE
 * - 0x01: HCI_ADV_FILTER_ACCEPT_LIST_SCAN
 * - 0x02: HCI_ADV_FILTER_ACCEPT_LIST_CONNECT
 * - 0x03: HCI_ADV_FILTER_ACCEPT_LIST_SCAN_CONNECT
 */
  uint8_t Advertising_Filter_Policy;
/**
 * Units: dBm  The Advertising_Tx_Power parameter indicates the maximum power
 * level at which the advertising packets are to be transmitted on the
 * advertising channels. The Controller shall choose a power level lower than or
 * equal to the one specified by the Host.
 * Values:
 * - -127 ... 126
 * - 127: No preference
 */
  int8_t Advertising_Tx_Power;
/**
 * The Primary_Advertising_PHY parameter indicates the PHY on which the
 * advertising packets are transmitted on the primary advertising channel. If
 * legacy advertising PDUs are being used, the Primary_Advertising_PHY shall
 * indicate the LE 1M PHY.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t Primary_Advertising_PHY;
/**
 * The Secondary_Advertising_Max_Skip parameter is the maximum number of
 * advertising events that can be skipped before the AUX_ADV_IND can be sent.
 * 0x00 AUX_ADV_IND shall be sent prior to the next advertising event 0x01-0xFF
 * Maximum advertising events the Controller can skip before sending the
 * AUX_ADV_IND packets on the secondary advertising channel
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Secondary_Advertising_Max_Skip;
/**
 * The Secondary_Advertising_PHY parameter indicates the PHY on which the
 * advertising packets are transmitted on the secondary advertising channel.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t Secondary_Advertising_PHY;
/**
 * The Advertising_SID parameter specifies the value to be transmitted in the
 * Advertising SID subfield of the ADI field of the Extended Header of those
 * advertising channel PDUs that have an ADI field. If the advertising set only
 * uses PDUs that do not contain an ADI field, Advertising_SID is ignored.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t Advertising_SID;
/**
 * The Scan_Request_Notification_Enable parameter indicates whether the
 * Controller shall send notifications upon the receipt of a scan request PDU
 * that is in response to an advertisement from the specified advertising set
 * that contains its device address and is from a scanner that is allowed by the
 * advertising filter policy.
 * Values:
 * - 0x00: Scan request notifications disabled
 * - 0x01: Scan request notifications enabled
 */
  uint8_t Scan_Request_Notification_Enable;
} hci_le_set_extended_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Units: dBm. The Selected_Tx_Power return parameter indicates the transmit
 * power selected by the Controller. The Controller shall not change the
 * transmit power for this advertising set without being directed to by the
 * Host.
 * Values:
 * - -127 ... 126
 */
  int8_t Selected_Tx_Power;
} hci_le_set_extended_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_data_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * The Host may set the advertising data in one or more operations using this
 * parameter. 0x00: Intermediate fragment of fragmented extended advertising
 * data 0x01: First fragment of fragmented extended advertising data 0x02: Last
 * fragment of fragmented extended advertising data 0x03: Complete extended
 * advertising data 0x04: Unchanged data (just update the Advertising DID) All
 * other values: Reserved for future use
 * Values:
 * - 0x00: Intermediate fragment
 * - 0x01: First fragment
 * - 0x02: Last fragment
 * - 0x03: Complete data
 * - 0x04: Unchanged data
 */
  uint8_t Operation;
/**
 * The Fragment_Preference parameter provides a hint to the Controller as to
 * whether advertising data should be fragmented.
 * Values:
 * - 0x00: The Controller may fragment
 * - 0x01: The Controller should not fragment or should minimize fragmentation
 */
  uint8_t Fragment_Preference;
/**
 * The number of octets in the Advertising Data parameter
 * Values:
 * - 0 ... 251
 */
  uint8_t Advertising_Data_Length;
/**
 * Advertising data formatted as defined in [Vol 3] Part C, Section 11 Note:
 * This parameter has a variable length.
 */
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_extended_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_extended_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_response_data_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 */
  uint8_t Advertising_Handle;
/**
 * The Host may set the scan response data in one or more operations using the
 * Operation parameter in the command. 0x00: Intermediate fragment of fragmented
 * scan response data 0x01: First fragment of fragmented scan response data
 * 0x02: Last fragment of fragmented scan response data 0x03: Complete scan
 * response data All other values: Reserved for future use
 * Values:
 * - 0x00: Intermediate fragment
 * - 0x01: First fragment
 * - 0x02: Last fragment
 * - 0x03: Complete data
 */
  uint8_t Operation;
/**
 * The Fragment_Preference parameter provides a hint to the Controller as to
 * whether advertising data should be fragmented.
 * Values:
 * - 0x00: The Controller may fragment all scan response data
 * - 0x01: The Controller should not fragment or should minimize fragmentation of
scan response data
 */
  uint8_t Fragment_Preference;
/**
 * The number of octets in the Scan_Response Data parameter
 * Values:
 * - 0x00 ... 0xFB: The number of octets in the Scan_Response Data parameter
 */
  uint8_t Scan_Response_Data_Length;
/**
 * Scan response data formatted as defined in [Vol 3] Part C, Section 11 Note:
 * This parameter has a variable length.
 */
  uint8_t Scan_Response_Data[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_extended_scan_response_data_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_response_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_extended_scan_response_data_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_enable_cp0_s {
/**
 * It allows to enable or disable one or more advertising sets using the
 * advertising sets identified by the Advertising_Handle[i] parameter.
 * Values:
 * - 0x00: Disable
 * - 0x01: Enable
 */
  uint8_t Enable;
/**
 * The Number_of_Sets parameter is the number of advertising sets contained in
 * the parameter arrays.
 * Values:
 * - 0x00: Disable all advertising sets
 * - 0x01 ... 0x3F: Number of advertising sets to enable or disable
 */
  uint8_t Number_of_Sets;
/**
 * See @ref Advertising_Set_Parameters_t
 */
  packed_Advertising_Set_Parameters_t Advertising_Set_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Advertising_Set_Parameters_t)];
} hci_le_set_extended_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_extended_advertising_enable_rp0;

typedef PACKED(struct) hci_le_read_maximum_advertising_data_length_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Maximum length of data supported by the Controller for use as advertisement
 * data or scan response data in an advertising event or as periodic
 * advertisement data.
 * Values:
 * - 0x001F ... 0x0672: Maximum supported advertising data length
 */
  uint16_t Maximum_Advertising_Data_Length;
} hci_le_read_maximum_advertising_data_length_rp0;

typedef PACKED(struct) hci_le_read_number_of_supported_advertising_sets_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Maximum number of advertising sets supported by the advertising Controller at
 * the same time.
 * Values:
 * - 0x01 ... 0xF0: Number of advertising sets supported at the same time
 */
  uint8_t Num_Supported_Advertising_Sets;
} hci_le_read_number_of_supported_advertising_sets_rp0;

typedef PACKED(struct) hci_le_remove_advertising_set_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 */
  uint8_t Advertising_Handle;
} hci_le_remove_advertising_set_cp0;

typedef PACKED(struct) hci_le_remove_advertising_set_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_remove_advertising_set_rp0;

typedef PACKED(struct) hci_le_clear_advertising_sets_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_clear_advertising_sets_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify a periodic advertisement
 */
  uint8_t Advertising_Handle;
/**
 * Minimum advertising interval for periodic advertising. Time = N * 1.25 ms;
 * Time Range: 7.5ms to 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval_Min;
/**
 * Maximum advertising interval for periodic advertising. Time = N * 1.25 ms;
 * Time Range: 7.5ms to 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval_Max;
/**
 * The Periodic_Advertising_Properties parameter indicates which fields should
 * be included in the advertising packet.
 * Flags:
 * - 0x0040: Include TxPower in the advertising PDU
 */
  uint16_t Periodic_Advertising_Properties;
} hci_le_set_periodic_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_periodic_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_data_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 */
  uint8_t Advertising_Handle;
/**
 * The Host may set the periodic advertising data in one or more operations
 * using the Operation parameter in the command.
 * Values:
 * - 0x00: Intermediate fragment of fragmented periodic advertising data
 * - 0x01: First fragment of fragmented periodic advertising data
 * - 0x02: Last fragment of fragmented periodic advertising data
 * - 0x03: Complete periodic advertising data
 */
  uint8_t Operation;
/**
 * The number of octets in the Advertising Data parameter
 * Values:
 * - 0 ... 252: The number of octets in the Advertising Data parameter
 */
  uint8_t Advertising_Data_Length;
/**
 * Periodic advertising data formatted as defined in [Vol 3] Part C, Section 11.
 * Note: This parameter has a variable length.
 */
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} hci_le_set_periodic_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_periodic_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_enable_cp0_s {
/**
 * It is used to enabled advertising and include ADI field. If bit 0 is set,
 * enable periodic advertising. if bit 1 is set, Include the ADI field in
 * AUX_SYNC_IND PDUs.
 * Flags:
 * - 0x01: ENABLE_PERIODIC_ADV
 * - 0x02: INCLUDE_ADI_FIELD
 */
  uint8_t Enable;
/**
 * Used to identify an advertising set.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_periodic_advertising_enable_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_parameters_cp0_s {
/**
 * The Own_Address_Type parameter indicates the type of address being used in
 * the scan request packets.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 * - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from LE_Set_Random_Address.
 */
  uint8_t Own_Address_Type;
/**
 * 0x00 Accept all advertisement packets. Directed advertising packets which are
 * not addressed for this device shall be ignored. 0x01 Ignore advertisement
 * packets from devices not in the Filter Accept List Only. Directed advertising
 * packets which are not addressed for this device shall be ignored 0x02 Accept
 * all undirected advertisement packets. Directed advertisement packets where
 * initiator address is a RPA and  Directed advertisement packets addressed to
 * this device shall be accepted. 0x03 Accept all undirected advertisement
 * packets from devices that are in the Filter Accept List.Directed
 * advertisement packets where initiator address is RPA and Directed
 * advertisement packets addressed to this device shall be accepted.
 * Values:
 * - 0x00: Accept all
 * - 0x01: Ignore devices not in the Filter Accept List
 * - 0x02: Accept all (use resolving list)
 * - 0x03: Ignore devices not in the Filter Accept List (use resolving list)
 */
  uint8_t Scanning_Filter_Policy;
/**
 * The Scanning_PHYs parameter indicates the PHY(s) on which the advertising
 * packets should be received on the primary advertising channel. The Host may
 * enable one or more scanning PHYs.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t Scanning_PHYs;
/**
 * See @ref Extended_Scan_Parameters_t
 */
  packed_Extended_Scan_Parameters_t Extended_Scan_Parameters[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_Extended_Scan_Parameters_t)];
} hci_le_set_extended_scan_parameters_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_extended_scan_parameters_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_enable_cp0_s {
/**
 * The Enable parameter determines whether scanning is enabled or disabled. If
 * it is disabled, the remaining parameters are ignored.
 * Values:
 * - 0x00: Scanning disabled
 * - 0x01: Scanning enabled
 */
  uint8_t Enable;
/**
 * The Filter_Duplicates parameter controls whether the Link Layer should filter
 * out duplicate advertising reports (filtering duplicates enabled) to the Host
 * or if the Link Layer should generate advertising reports for each packet
 * received (filtering duplicates disabled). See [Vol 6] Part B, Section
 * 4.4.3.5.
 * Values:
 * - 0x00: Duplicate filtering disabled
 * - 0x01: Duplicate filtering enabled
 * - 0x02: Duplicate filtering enabled, reset for each scan period
 */
  uint8_t Filter_Duplicates;
/**
 * Scan duration. Time = N * 10 ms; Time Range: 10 ms to 655.35 s.
 * Values:
 * - 0x0000 (0.000 ms) : Scan continuously until explicitly disable
 * - 0x0001 (0.625 ms)  ... 0xFFFF (40959.375 ms) : Scan duration
 */
  uint16_t Duration;
/**
 * Time interval from when the Controller started its last Scan_Duration until
 * it begins the subsequent Scan_Duration. Time = N * 1.28 sec; Time Range: 1.28
 * s to 83,884.8 s.
 * Values:
 * - 0x0000: Periodic scanning disabled
 * - 0x0001 ... 0xFFFF: Time interval from when the Controller started its last Scan_Duration
until it begins the subsequent Scan_Duration
 */
  uint16_t Period;
} hci_le_set_extended_scan_enable_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_extended_scan_enable_rp0;

typedef PACKED(struct) hci_le_extended_create_connection_cp0_s {
/**
 * The Initiator_Filter_Policy parameter is used to determine whether the Filter
 * Accept List is used. If the Filter Accept List is not used, the
 * Peer_Address_Type and the Peer_Address parameters specify the address type
 * and address of the advertising device to connect to. 0x00 - Filter Accept
 * List is not used to determine which advertiser to connect to.
 * Peer_Address_Type and Peer_Address shall be used. 0x01 - Filter Accept List
 * is used to determine which advertiser to connect to. Peer_Address_Type and
 * Peer_Address shall be ignored.
 * Values:
 * - 0x00: FILTER_ACCEPT_LIST_NOT_USED
 * - 0x01: FILTER_ACCEPT_LIST_USED
 */
  uint8_t Initiator_Filter_Policy;
/**
 * The Own_Address_Type parameter indicates the type of address being used in
 * the connection request packets.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 * - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from the most recent successful
LE_Set_Random_Address Command.
 */
  uint8_t Own_Address_Type;
/**
 * The Peer_Address_Type parameter indicates the type of address used in the
 * connectable advertisement sent by the peer. 0x00: Public Device Address or
 * Public Identity Address 0x01: Random Device Address or Random (static)
 * Identity Address
 * Values:
 * - 0x00: Public Address
 * - 0x01: Random Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * The Initiating_PHYs parameter indicates the PHY(s) on which the advertising
 * packets should be received on the primary advertising channel and the PHYs
 * for which connection parameters have been specified. The Host may enable one
 * or more initiating PHYs. 0x01: Scan connectable advertisements on the LE 1M
 * PHY. Connection parameters for the LE 1M PHY are provided. 0x02: Connection
 * parameters for the LE 2M PHY are provided 0x04: Scan connectable
 * advertisements on the LE Coded PHY. Connection parameters for the LE Coded
 * PHY are provided.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t Initiating_PHYs;
/**
 * See @ref Extended_Create_Connection_Parameters_t
 */
  packed_Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(packed_Extended_Create_Connection_Parameters_t)];
} hci_le_extended_create_connection_cp0;

typedef PACKED(struct) hci_le_extended_create_connection_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_extended_create_connection_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_cp0_s {
/**
 * The Options parameter is a bitmask used to determine whether the Periodic
 * Advertiser List is used, whether HCI_LE_Periodic_Advertising_Report events
 * for this periodic advertising train are initially enabled or disabled, and
 * whether duplicate reports are filtered or not. If bit 0 is 0: use the
 * Advertising_SID, Advertiser_Address_Type, and Advertiser_Address parameters
 * to determine which advertiser to listen to. If bit 0 is 1: use the Periodic
 * Advertiser List to determine which advertiser to listen to. If bit 1 is 0,
 * reporting is initially enabled, otherwise it is enabled. If bit 2 is 0,
 * duplicate filtering is initially disabled, otherwise it is enabled.
 * Flags:
 * - 0x01: USE_PERIODIC_ADV_LIST
 * - 0x02: DISABLE_REPORTING
 * - 0x04: ENABLE_DUPLICATE_FILTERING
 */
  uint8_t Options;
/**
 * The Advertising_SID parameter, if used, specifies the value that must match
 * the Advertising SID subfield in the ADI field of the received advertisement
 * for it to be used to synchronize.
 * Values:
 * - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
Advertising
 */
  uint8_t Advertising_SID;
/**
 * Advertising address type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * The Skip parameter specifies the number of consecutive periodic advertising
 * packets that the receiver may skip after successfully receiving a periodic
 * advertising packet.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Skip;
/**
 * Synchronization timeout for the periodic advertising train. Time = N*10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 */
  uint16_t Sync_Timeout;
/**
 * The Sync_CTE_Type parameter specifies whether to only synchronize to periodic
 * advertising with certain types of Constant Tone Extension (a value of 0
 * indicates that the presence or absence of a Constant Tone Extension is
 * irrelevant). If the periodic advertising has the wrong type of Constant Tone
 * Extension then: - If bit 0 of Options is set, the Controller shall ignore
 * this address and SID and continue to search for other periodic
 * advertisements. - Otherwise, the Controller shall cancel the synchronization
 * with the error code Unsupported Remote Feature/Unsupported LMP Feature
 * (0x1A).
 * Flags:
 * - 0x01: Do not sync to packets with an AoA Constant Tone Extension
 * - 0x02: Do not sync to packets with an AoD Constant Tone Extension with 1 microsecondslots
 * - 0x04: Do not sync to packets with an AoD Constant Tone Extension with 2 microsecondsslots
 * - 0x08: Do not sync to packets with a type 3 Constant Tone Extension (currentlyreserved for future use)
 * - 0x10: Do not sync to packets without a Constant Tone Extension
 */
  uint8_t Sync_CTE_Type;
} hci_le_periodic_advertising_create_sync_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_periodic_advertising_create_sync_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_cancel_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_periodic_advertising_create_sync_cancel_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_terminate_sync_cp0_s {
/**
 * It is used to identify the periodic advertiser
 * Values:
 * - 0x0000 ... 0x0EFF: Sync_Handle to be used to identify the periodic advertiser
 */
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_terminate_sync_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_terminate_sync_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_periodic_advertising_terminate_sync_rp0;

typedef PACKED(struct) hci_le_add_device_to_periodic_advertiser_list_cp0_s {
/**
 * Advertiser Address Type
 * Values:
 * - 0x00: Public Device Address or Public Identity Address
 * - 0x01: Random Device Address or Random (static) Identity Address
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * Advertising SID subfield in the ADI field used to identify the Periodic
 * Advertising
 * Values:
 * - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
Advertising
 */
  uint8_t Advertising_SID;
} hci_le_add_device_to_periodic_advertiser_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_periodic_advertiser_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_add_device_to_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_periodic_advertiser_list_cp0_s {
/**
 * Advertising Address type
 * Values:
 * - 0x00: Public Device Address or Public Identity Address
 * - 0x01: Random Device Address or Random (static) Identity Address
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * It is used to  identify the Periodic Advertising
 * Values:
 * - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
Advertising
All other values Reserved for future
 */
  uint8_t Advertising_SID;
} hci_le_remove_device_from_periodic_advertiser_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_periodic_advertiser_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_remove_device_from_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_clear_periodic_advertiser_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_clear_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_read_periodic_advertiser_list_size_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Total number of Periodic Advertiser list entries that can be stored in the
 * Controller
 * Values:
 * - 0x1F ... 0xFF: Total number of Periodic Advertiser list entries that can be stored in the
Controller
 */
  uint8_t Periodic_Advertiser_List_Size;
} hci_le_read_periodic_advertiser_list_size_rp0;

typedef PACKED(struct) hci_le_read_transmit_power_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Minimum supported TX power (units: dBm).
 * Values:
 * - -127 ... 20
 */
  int8_t Min_Tx_Power;
/**
 * Maximum supported TX power (units: dBm).
 * Values:
 * - -127 ... 20
 */
  int8_t Max_Tx_Power;
} hci_le_read_transmit_power_rp0;

typedef PACKED(struct) hci_le_read_rf_path_compensation_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  int16_t RF_TX_Path_Compensation_Value;
/**
 *
 */
  int16_t RF_RX_Path_Compensation_Value;
} hci_le_read_rf_path_compensation_rp0;

typedef PACKED(struct) hci_le_write_rf_path_compensation_cp0_s {
/**
 *
 */
  int16_t RF_TX_Path_Compensation_Value;
/**
 *
 */
  int16_t RF_RX_Path_Compensation_Value;
} hci_le_write_rf_path_compensation_cp0;

typedef PACKED(struct) hci_le_write_rf_path_compensation_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_write_rf_path_compensation_rp0;

typedef PACKED(struct) hci_le_set_privacy_mode_cp0_s {
/**
 * Peer Address type
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Peer_Identity_Address_Type;
/**
 * Public Identity Address or Random (static) Identity Address of the advertiser
 */
  uint8_t Peer_Identity_Address[6];
/**
 * 0x00 Use Network Privacy Mode for this peer device (default) 0x01 Use Device
 * Privacy Mode for this peer device
 * Values:
 * - 0x00: Network Privacy Mode
 * - 0x01: Device Privacy Mode
 */
  uint8_t Privacy_Mode;
} hci_le_set_privacy_mode_cp0;

typedef PACKED(struct) hci_le_set_privacy_mode_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_privacy_mode_rp0;

typedef PACKED(struct) hci_le_receiver_test_v3_cp0_s {
/**
 *
 * Values:
 * - 0x00 ... 0x27: N = (F - 2402) / 2.Frequency Range : 2402 MHz to 2480 MHz
 */
  uint8_t RX_Channel;
/**
 * PHY to be used by the receiver.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY;
/**
 *
 * Values:
 * - 0x00: Assume transmitter will have a standard modulation index
 * - 0x01: Assume transmitter will have a stable modulation index
 */
  uint8_t Modulation_Index;
/**
 *
 * Values:
 * - 0x00: No Constant Tone Extension expected (default)
 * - 0x02 ... 0x14: Expected length of the Constant Tone Extension in 8 microseconds units.
 */
  uint8_t Expected_CTE_Length;
/**
 *
 * Values:
 * - 0x00: Expect AoA Constant Tone Extension
 * - 0x01: Expect AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: Expect AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t Expected_CTE_Type;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 *
 * Values:
 * - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_receiver_test_v3_cp0;

typedef PACKED(struct) hci_le_receiver_test_v3_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_receiver_test_v3_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v3_cp0_s {
/**
 * N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 * Values:
 * - 0x00 ... 0x27
 */
  uint8_t TX_Channel;
/**
 * Length in bytes of payload data in each packet.     Supported ranges:       -
 * (0x00,0x25) if data length extension is disabled.       - (0x00,0xFF) if data
 * length extension is enabled.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Test_Data_Length;
/**
 * Content of the Payload of the test reference packets.  0: PRBS9 sequence
 * '11111111100000111101...' (in transmission order) 1: Repeated '11110000' (in
 * transmission order) sequence 2: Repeated '10101010' (in transmission order)
 * sequence 3: PRBS15 sequence 4: Repeated '11111111' (in transmission order)
 * sequence 5: Repeated '00000000' (in transmission order) sequence 6: Repeated
 * '00001111' (in transmission order) sequence 7: Repeated '01010101' (in
 * transmission order) sequence
 * Values:
 * - 0x00: PRBS9
 * - 0x01: Repeated '11110000'
 * - 0x02: Repeated '10101010'
 * - 0x03: PRBS15
 * - 0x04: Repeated '11111111'
 * - 0x05: Repeated '00000000'
 * - 0x06: Repeated '00001111'
 * - 0x07: Repeated '01010101'
 */
  uint8_t Packet_Payload;
/**
 * PHY to be used by the transmitter.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 *
 * Values:
 * - 0x00: No Constant Tone Extension expected (default)
 * - 0x02 ... 0x14: Expected length of the Constant Tone Extension in 8 microseconds units.
 */
  uint8_t CTE_Length;
/**
 *
 * Values:
 * - 0x00: Expect AoA Constant Tone Extension
 * - 0x01: Expect AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: Expect AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t CTE_Type;
/**
 * The number of Antenna IDs in the pattern.
 * Values:
 * - 0x02 ... 0x4B
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_transmitter_test_v3_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v3_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_transmitter_test_v3_rp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_parameters_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 *
 * Values:
 * - 0x02 ... 0x14: Constant Tone Extension length in 8 microseconds units
 */
  uint8_t CTE_Length;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t CTE_Type;
/**
 * The CTE_Count parameter specifies how many packets with a Constant Tone
 * Extension are to be transmitted in each periodic advertising event. If the
 * number of packets that would otherwise be transmitted is less than this, the
 * Controller shall transmit sufficient AUX_CHAIN_IND PDUs with no AdvData to
 * make up the number. However, if a change in circumstances since this command
 * was issued means that the Controller can no longer schedule all of these
 * packets, it should transmit as many as possible.
 * Values:
 * - 0x01 ... 0x10: The number of Constant Tone Extensions to transmit in each periodic advertising interval
 */
  uint8_t CTE_Count;
/**
 *
 * Values:
 * - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_connectionless_cte_transmit_parameters_cp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_connectionless_cte_transmit_parameters_rp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_enable_cp0_s {
/**
 * Identifier for the advertising set in which Constant Tone Extension is being
 * enabled or disabled
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * It enables or disables the use of Constant Tone Extensions.
 * Values:
 * - 0x00: Advertising with Constant Tone Extension is disabled (default)
 * - 0x01: Advertising with Constant Tone Extension is enabled
 */
  uint8_t CTE_Enable;
} hci_le_set_connectionless_cte_transmit_enable_cp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_connectionless_cte_transmit_enable_rp0;

typedef PACKED(struct) hci_le_set_connectionless_iq_sampling_enable_cp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * If the Sampling_Enable parameter is set to 0x01 (sampling is enabled), the
 * Controller starts attempting to capture IQ samples from the periodic
 * advertisements.
 * Values:
 * - 0x00: DISABLE
 * - 0x01: ENABLE
 */
  uint8_t Sampling_Enable;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 * It specifies the maximum number of Constant Tone Extensions in each periodic
 * advertising event that the Controller should collect and report IQ samples
 * from. The Controller should sample all Constant Tone Extensions up to this
 * number.
 * Values:
 * - 0x00: REPORT_ALL_CTES
 * - 0x01 ... 0x10
 */
  uint8_t Max_Sampled_CTEs;
/**
 * The number of Antenna IDs in the pattern.
 * Values:
 * - 0x02 ... 0x4B
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} hci_le_set_connectionless_iq_sampling_enable_cp0;

typedef PACKED(struct) hci_le_set_connectionless_iq_sampling_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
} hci_le_set_connectionless_iq_sampling_enable_rp0;

typedef PACKED(struct) hci_le_set_connection_cte_receive_parameters_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x00: Connection IQ sampling is disabled (default)
 * - 0x01: Connection IQ sampling is enabled
 */
  uint8_t Sampling_Enable;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 *
 * Values:
 * - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_connection_cte_receive_parameters_cp0;

typedef PACKED(struct) hci_le_set_connection_cte_receive_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_set_connection_cte_receive_parameters_rp0;

typedef PACKED(struct) hci_le_set_connection_cte_transmit_parameters_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Flags:
 * - 0x01: Allow AoA Constant Tone Extension Response
 * - 0x02: Allow AoD Constant Tone Extension Response with 1 microsecond slots
 * - 0x04: Allow AoD Constant Tone Extension Response with 2 microseconds slots
 */
  uint8_t CTE_Type;
/**
 *
 * Values:
 * - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_connection_cte_transmit_parameters_cp0;

typedef PACKED(struct) hci_le_set_connection_cte_transmit_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_set_connection_cte_transmit_parameters_rp0;

typedef PACKED(struct) hci_le_connection_cte_request_enable_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * If it is set to 0x00, the remaining parameters shall be ignored.
 * Values:
 * - 0x00: Disable Constant Tone Extension Request for the connection (default)
 * - 0x01: Enable Constant Tone Extension Request for the connection
 */
  uint8_t Enable;
/**
 * It defines whether the Constant Tone Extension Request procedure is initiated
 * only once or periodically. In the case of periodic operation, the procedure
 * is initiated every CTE_Request_Interval. However, the Controller may delay
 * initiating the procedure beyond the requested interval (e.g., in order to
 * prioritize other activities).
 * Values:
 * - 0x0000: Initiate the Constant Tone Extension Request procedure once, at the nearliest practical opportunity.
 * - 0x0001 ... 0xFFFF: Requested interval for initiating the Constant Tone Extension Request procedure in number of connection events.
 */
  uint16_t CTE_Request_Interval;
/**
 * It indicates the minimum length of the Constant Tone Extension and the
 * Requested_CTE_Type parameter indicates the type of Constant Tone Extension
 * that the Controller shall request from the remote device.
 * Values:
 * - 0x02 ... 0x14: Minimum length of the Constant Tone Extension being requested in 8 nmicroseconds units
 */
  uint8_t Requested_CTE_Length;
/**
 *
 * Flags:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t Requested_CTE_Type;
} hci_le_connection_cte_request_enable_cp0;

typedef PACKED(struct) hci_le_connection_cte_request_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_connection_cte_request_enable_rp0;

typedef PACKED(struct) hci_le_connection_cte_response_enable_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x00: Disable Constant Tone Extension Response for the connection (default)
 * - 0x01: Enable Constant Tone Extension Response for the connection
 */
  uint8_t Enable;
} hci_le_connection_cte_response_enable_cp0;

typedef PACKED(struct) hci_le_connection_cte_response_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_connection_cte_response_enable_rp0;

typedef PACKED(struct) hci_le_read_antenna_information_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 * Flags:
 * - 0x00: 1 microsecond switching supported for AoD transmission
 * - 0x02: 1 microsecond switching supported for AoD reception
 * - 0x04: 1 microsecond switching and sampling supported for AoA reception
 */
  uint8_t Supported_Switching_Sampling_Rates;
/**
 *
 * Values:
 * - 0x01 ... 0x4B: The number of antennae supported by the Controller
 */
  uint8_t Num_Antennae;
/**
 *
 * Values:
 * - 0x02 ... 0x4B: Maximum length of antenna switching pattern supported by the Controller
 */
  uint8_t Max_Switching_Pattern_Length;
/**
 *
 * Values:
 * - 0x02 ... 0x14: Maximum length of a transmitted Constant Tone Extension supported in 8 microseconds units
 */
  uint8_t Max_CTE_Length;
} hci_le_read_antenna_information_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_receive_enable_cp0_s {
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Bit 0 to enable reporting. Bit 1 to enable duplicate filtering.
 * Flags:
 * - 0x01: ENABLE_REPORTING
 * - 0x02: ENABLE_DUPLICATE_FILTERING
 */
  uint8_t Enable;
} hci_le_set_periodic_advertising_receive_enable_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_receive_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_periodic_advertising_receive_enable_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The Service_Data parameter is a value provided by the Host for use by the
 * Host of the peer device. It is not used by the Controller.
 */
  uint16_t Service_Data;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_sync_transfer_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_periodic_advertising_sync_transfer_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_set_info_transfer_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * It is a value provided by the Host to identify the periodic advertising train
 * to the peer device. It is not used by the Controller.
 */
  uint16_t Service_Data;
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
} hci_le_periodic_advertising_set_info_transfer_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_set_info_transfer_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_periodic_advertising_set_info_transfer_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_sync_transfer_parameters_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The action to be taken when periodic advertising synchronization information
 * is received. If 0, no attempt is made to synchronize to the periodic
 * advertising and no HCI_LE_Periodic_Advertising_Sync_Transfer_Received event
 * is sent to the Host. If 1, an
 * HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
 * HCI_LE_Periodic_Advertising_Report events will be disabled. If 2, an
 * HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
 * HCI_LE_Periodic_Advertising_Report events will be enabled with duplicate
 * filtering disabled. If 3, an
 * HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
 * HCI_LE_Periodic_Advertising_Report events will be enabled with duplicate
 * filtering enabled.
 * Values:
 * - 0x00: NO_SYNC
 * - 0x01: REPORTS_DISABLED
 * - 0x02: REPORTS_ENABLED
 * - 0x03: REPORTS_ENABLED_WITH_DUPLICATE_FILTERING
 */
  uint8_t Mode;
/**
 * The number of periodic advertising packets that can be skipped after a
 * successful receive.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Skip;
/**
 * Synchronization timeout for the periodic advertising train. Time = N*10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 */
  uint16_t Sync_Timeout;
/**
 * It specifies whether to only synchronize to periodic advertising with certain
 * types of Constant Tone Extension.  If bit 0 is set: do not sync to packets
 * with an AoA Constant Tone Extension. If bit 1 is set: Do not sync to packets
 * with an AoD Constant Tone Extension with 1 us slots. If bit 2 is set: Do not
 * sync to packets with an AoD Constant Tone Extension with 2 us slots. If bit 3
 * is set: Do not sync to packets without a Constant Tone Extension.
 * Flags:
 * - 0x01: DO_NOT_SYNC_WITH_AOA
 * - 0x02: DO_NOT_SYNC_WITH_AOD_1US
 * - 0x04: DO_NOT_SYNC_WITH_AOD_2US
 * - 0x10: DO_NOT_SYNC_WITHOUT_CTE
 */
  uint8_t CTE_Type;
} hci_le_set_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_sync_transfer_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_set_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0_s {
/**
 * The action to be taken when periodic advertising synchronization information
 * is received. If 0, no attempt is made to synchronize to the periodic
 * advertising and no HCI_LE_Periodic_Advertising_Sync_Transfer_Received event
 * is sent to the Host. If 1, an
 * HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
 * HCI_LE_Periodic_Advertising_Report events will be disabled. If 2, an
 * HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
 * HCI_LE_Periodic_Advertising_Report events will be enabled with duplicate
 * filtering disabled. If 3, an
 * HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
 * HCI_LE_Periodic_Advertising_Report events will be enabled with duplicate
 * filtering enabled.
 * Values:
 * - 0x00: NO_SYNC
 * - 0x01: REPORTS_DISABLED
 * - 0x02: REPORTS_ENABLED
 * - 0x03: REPORTS_ENABLED_WITH_DUPLICATE_FILTERING
 */
  uint8_t Mode;
/**
 * The number of periodic advertising packets that can be skipped after a
 * successful receive.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Skip;
/**
 * Synchronization timeout for the periodic advertising train. Time = N*10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 */
  uint16_t Sync_Timeout;
/**
 * It specifies whether to only synchronize to periodic advertising with certain
 * types of Constant Tone Extension.  If bit 0 is set: do not sync to packets
 * with an AoA Constant Tone Extension. If bit 1 is set: Do not sync to packets
 * with an AoD Constant Tone Extension with 1 us slots. If bit 2 is set: Do not
 * sync to packets with an AoD Constant Tone Extension with 2 us slots. If bit 3
 * is set: Do not sync to packets without a Constant Tone Extension.
 * Flags:
 * - 0x01: DO_NOT_SYNC_WITH_AOA
 * - 0x02: DO_NOT_SYNC_WITH_AOD_1US
 * - 0x04: DO_NOT_SYNC_WITH_AOD_2US
 * - 0x10: DO_NOT_SYNC_WITHOUT_CTE
 */
  uint8_t CTE_Type;
} hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) hci_le_set_default_periodic_advertising_sync_transfer_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_default_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) hci_le_read_buffer_size_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * 0x0000: No dedicated LE Buffer exists. Use the HCI_Read_Buffer_Size command.
 * 0x001B - 0xFFFF Maximum length (in octets) of the data portion of each HCI
 * ACL data packet.
 * Values:
 * - 0x0000: NO_BUFFER
 * - 0x001B ... 0xFFFF
 */
  uint16_t HC_LE_ACL_Data_Packet_Length;
/**
 * 0x00: No dedicated LE Buffer exists. Use the HCI_Read_Buffer_Size command.
 * 0x01 - 0xFF: Total number of HCI ACL Data Packets that can be stored in the
 * data buffers of the Controller.
 * Values:
 * - 0x00: NO_BUFFER
 * - 0x01 ... 0xFF
 */
  uint8_t HC_Total_Num_LE_ACL_Data_Packets;
/**
 * 0x0000: No dedicated ISO Buffer exists. 0x0001 to 0xFFFF: The maximum length
 * (in octets) of the data portion of each HCI ISO data packet.
 * Values:
 * - 0x0000: NO_BUFFER
 * - 0x0001 ... 0xFFFF
 */
  uint16_t ISO_Data_Packet_Length;
/**
 * 0x00: No dedicated ISO Buffer exists. 0x01 to 0xFF: The total number of HCI
 * ISO data packets that can be stored in the ISO buffers of the Controller.
 * Values:
 * - 0x00: NO_BUFFER
 * - 0x01 ... 0xFF
 */
  uint8_t Total_Num_ISO_Data_Packets;
} hci_le_read_buffer_size_v2_rp0;

typedef PACKED(struct) hci_le_read_iso_tx_sync_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_read_iso_tx_sync_cp0;

typedef PACKED(struct) hci_le_read_iso_tx_sync_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The packet sequence number of an SDU.
 */
  uint16_t Packet_Sequence_Number;
/**
 * The CIG reference point or BIG anchor point of a transmitted SDU derived
 * using the Controller's free running reference clock (in microseconds).
 */
  uint32_t TX_Time_Stamp;
/**
 * The time offset, in microseconds, that is associated with a transmitted SDU.
 */
  uint8_t Time_Offset[3];
} hci_le_read_iso_tx_sync_rp0;

typedef PACKED(struct) hci_le_set_cig_parameters_cp0_s {
/**
 * Used to identify the CIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIG_ID;
/**
 * The interval, in microseconds, of periodic SDUs.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval_C_To_P[3];
/**
 * The interval, in microseconds, of periodic SDUs.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval_P_To_C[3];
/**
 * Worst-case sleep clock accuracy of all the Peripherals.
 * Values:
 * - 0x00: 251 ppm to 500 ppm
 * - 0x01: 151 ppm to 250 ppm
 * - 0x02: 101 ppm to 150 ppm
 * - 0x03: 76 ppm to 100 ppm
 * - 0x04: 51 ppm to 75 ppm
 * - 0x05: 31 ppm to 50 ppm
 * - 0x06: 21 ppm to 30 ppm
 * - 0x07: 0 ppm to 20 ppm
 */
  uint8_t Worst_Case_SCA;
/**
 * Preferred method of arranging subevents of multiple CISes.
 * Values:
 * - 0x00: Sequential
 * - 0x01: Interleaved
 */
  uint8_t Packing;
/**
 * Format of the CIS Data PDUs of the specified CISes.
 * Values:
 * - 0x00: Unframed
 * - 0x01: Framed
 */
  uint8_t Framing;
/**
 * Maximum transport latency, in milliseconds, from the Central's Controller to
 * the Peripheral's Controller.
 * Values:
 * - 0x0005 ... 0x0FA0
 */
  uint16_t Max_Transport_Latency_C_To_P;
/**
 * Maximum transport latency, in milliseconds, from the Peripheral's Controller
 * to the Central's Controller.
 * Values:
 * - 0x0005 ... 0x0FA0
 */
  uint16_t Max_Transport_Latency_P_To_C;
/**
 * Total number of CIS configurations in the CIG being added or modified.
 * Values:
 * - 0x00 ... 0x1F
 */
  uint8_t CIS_Count;
/**
 * See @ref CIS_Param_t
 */
  packed_CIS_Param_t CIS_Param[(HCI_MAX_PAYLOAD_SIZE - 15)/sizeof(packed_CIS_Param_t)];
} hci_le_set_cig_parameters_cp0;

typedef PACKED(struct) hci_le_set_cig_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Total number of CIS configurations added or modified by this command.
 * Values:
 * - 0x00 ... 0x1F
 */
  uint8_t CIG_ID;
/**
 * Total number of CIS configurations added or modified by this command.
 * Values:
 * - 0x00 ... 0x1F
 */
  uint8_t CIS_Count;
/**
 * Connection handle of the CIS in the CIG.
 */
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint16_t)];
} hci_le_set_cig_parameters_rp0;

typedef PACKED(struct) hci_le_set_cig_parameters_test_cp0_s {
/**
 * Used to identify the CIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIG_ID;
/**
 * The interval, in microseconds, of periodic SDUs.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval_C_To_P[3];
/**
 * The interval, in microseconds, of periodic SDUs.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval_P_To_C[3];
/**
 * The flush timeout in multiples of ISO_Interval for each payload sent from the
 * Central to Peripheral.
 * Values:
 * - 0x01 ... 0xFF
 */
  uint8_t FT_C_To_P;
/**
 * The flush timeout in multiples of ISO_Interval for each payload sent from the
 * Peripheral to Central.
 * Values:
 * - 0x01 ... 0xFF
 */
  uint8_t FT_P_To_C;
/**
 * Time between consecutive CIS anchor points. Time = N * 1.25 ms
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t ISO_Interval;
/**
 * Worst-case sleep clock accuracy of all the Peripherals.
 * Values:
 * - 0x00: 251 ppm to 500 ppm
 * - 0x01: 151 ppm to 250 ppm
 * - 0x02: 101 ppm to 150 ppm
 * - 0x03: 76 ppm to 100 ppm
 * - 0x04: 51 ppm to 75 ppm
 * - 0x05: 31 ppm to 50 ppm
 * - 0x06: 21 ppm to 30 ppm
 * - 0x07: 0 ppm to 20 ppm
 */
  uint8_t Worst_Case_SCA;
/**
 * Preferred method of arranging subevents of multiple CISes.
 * Values:
 * - 0x00: Sequential
 * - 0x01: Interleaved
 */
  uint8_t Packing;
/**
 * Format of the CIS Data PDUs of the specified CISes.
 * Values:
 * - 0x00: Unframed
 * - 0x01: Framed
 */
  uint8_t Framing;
/**
 * Total number of CIS configurations in the CIG being added or modified.
 * Values:
 * - 0x00 ... 0x1F
 */
  uint8_t CIS_Count;
/**
 * See @ref CIS_Param_Test_t
 */
  packed_CIS_Param_Test_t CIS_Param_Test[(HCI_MAX_PAYLOAD_SIZE - 15)/sizeof(packed_CIS_Param_Test_t)];
} hci_le_set_cig_parameters_test_cp0;

typedef PACKED(struct) hci_le_set_cig_parameters_test_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Total number of CIS configurations added or modified by this command.
 * Values:
 * - 0x00 ... 0x1F
 */
  uint8_t CIG_ID;
/**
 * Total number of CIS configurations added or modified by this command.
 * Values:
 * - 0x00 ... 0x1F
 */
  uint8_t CIS_Count;
/**
 * Connection handle of the CIS in the CIG.
 */
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint16_t)];
} hci_le_set_cig_parameters_test_rp0;

typedef PACKED(struct) hci_le_create_cis_cp0_s {
/**
 * Total number of CISes to be created.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t CIS_Count;
/**
 * See @ref CIS_Handles_t
 */
  packed_CIS_Handles_t CIS_Handles[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_CIS_Handles_t)];
} hci_le_create_cis_cp0;

typedef PACKED(struct) hci_le_create_cis_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_create_cis_rp0;

typedef PACKED(struct) hci_le_remove_cig_cp0_s {
/**
 * Identifier of a CIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIG_ID;
} hci_le_remove_cig_cp0;

typedef PACKED(struct) hci_le_remove_cig_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Identifier of a CIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIG_ID;
} hci_le_remove_cig_rp0;

typedef PACKED(struct) hci_le_accept_cis_request_cp0_s {
/**
 * Connection handle of the CIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_accept_cis_request_cp0;

typedef PACKED(struct) hci_le_accept_cis_request_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_accept_cis_request_rp0;

typedef PACKED(struct) hci_le_reject_cis_request_cp0_s {
/**
 * Reason the CIS request was rejected. See [Vol 1] Part F, Controller Error
 * Codes for a list of error codes and descriptions.
 */
  uint16_t Connection_Handle;
/**
 * Reason the CIS request was rejected. See [Vol 1] Part F, Controller Error
 * Codes for a list of error codes and descriptions.
 */
  uint8_t Reason;
} hci_le_reject_cis_request_cp0;

typedef PACKED(struct) hci_le_reject_cis_request_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The connection handle of the CIS to be rejected.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_reject_cis_request_rp0;

typedef PACKED(struct) hci_le_create_big_cp0_s {
/**
 * Used to identify the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Used to identify the periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * Total number of BISes in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * The interval, in microseconds, of periodic SDUs.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval[3];
/**
 * Maximum size of an SDU, in octets.
 * Values:
 * - 0x0001 ... 0x0FFF
 */
  uint16_t Max_SDU;
/**
 * Maximum transport latency, in milliseconds.
 * Values:
 * - 0x0005 ... 0x0FA0
 */
  uint16_t Max_Transport_Latency;
/**
 * The number of times that every BIS Data PDU should be retransmitted.
 * Values:
 * - 0x00 ... 0x1E
 */
  uint8_t RTN;
/**
 * Transmitter PHY of packets.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t PHY;
/**
 * Used to indicate the preferred method of arranging subevents of multiple
 * BISes.
 * Values:
 * - 0x00: Sequential
 * - 0x01: Interleaved
 */
  uint8_t Packing;
/**
 * The format for sending BIS Data PDUs.
 * Values:
 * - 0x00: Unframed
 * - 0x01: Framed
 */
  uint8_t Framing;
/**
 * The encryption mode of the BISes.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Encryption;
/**
 * 128-bit code used for deriving the session key for decrypting payloads of
 * BISes in the BIG.
 */
  uint8_t Broadcast_Code[16];
} hci_le_create_big_cp0;

typedef PACKED(struct) hci_le_create_big_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_create_big_rp0;

typedef PACKED(struct) hci_le_create_big_test_cp0_s {
/**
 * Used to identify the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Used to identify the periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * Total number of BISes in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * The interval, in microseconds, of periodic SDUs.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval[3];
/**
 * The time between consecutive BIG anchor points. Time = N * 1.25 ms Time
 * Range: 5 ms to 4 s
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t ISO_Interval;
/**
 * The total number of subevents in each interval of each BIS in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t NSE;
/**
 * Maximum size of an SDU, in octets.
 * Values:
 * - 0x0001 ... 0x0FFF
 */
  uint16_t Max_SDU;
/**
 * Maximum size, in octets, of payload
 * Values:
 * - 0x0001 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * Transmitter PHY of packets.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t PHY;
/**
 * Used to indicate the preferred method of arranging subevents of multiple
 * BISes.
 * Values:
 * - 0x00: Sequential
 * - 0x01: Interleaved
 */
  uint8_t Packing;
/**
 * The format for sending BIS Data PDUs.
 * Values:
 * - 0x00: Unframed
 * - 0x01: Framed
 */
  uint8_t Framing;
/**
 * The number of new payloads in each interval for each BIS.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * The number of times the scheduled payload(s) are transmitted in a given
 * event.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Offset used for pre-transmissions.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * The encryption mode of the BISes.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Encryption;
/**
 * 128-bit code used for deriving the session key for decrypting payloads of
 * BISes in the BIG.
 */
  uint8_t Broadcast_Code[16];
} hci_le_create_big_test_cp0;

typedef PACKED(struct) hci_le_create_big_test_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_create_big_test_rp0;

typedef PACKED(struct) hci_le_terminate_big_cp0_s {
/**
 * Used to identify the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Reason for disconnection. See Error Codes.
 */
  uint8_t Reason;
} hci_le_terminate_big_cp0;

typedef PACKED(struct) hci_le_terminate_big_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_terminate_big_rp0;

typedef PACKED(struct) hci_le_big_create_sync_cp0_s {
/**
 * Used to identify the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Identifier of the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x00EF
 */
  uint16_t Sync_Handle;
/**
 * The encryption mode of the BIG.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Encryption;
/**
 * 128-bit code used for deriving the session key for decrypting payloads of
 * BISes in the BIG.
 */
  uint8_t Broadcast_Code[16];
/**
 * The MSE (Maximum Subevents) parameter is the maximum number of subevents that
 * a Controller should use to receive data payloads in each interval for a BIS.
 * The Host should set MSE to reduce the maximum continuous radio receiving time
 * for a Synchronized Receiver with limited battery capacity.
 * Values:
 * - 0x00: Any number of subevents
 * - 0x01 ... 0x1F
 */
  uint8_t MSE;
/**
 * The BIG_Sync_Timeout parameter specifies the maximum permitted time between
 * successful receptions of BIS PDUs. If this time is exceeded, synchronization
 * is lost. When the Controller establishes synchronization and if the
 * BIG_Sync_Timeout set by the Host is less than 6 * ISO_Interval, the
 * Controller shall set the timeout to 6 * ISO_Interval.
 * Values:
 * - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 */
  uint16_t BIG_Sync_Timeout;
/**
 * Total number of BISes to synchronize.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * List of indices of BISes.
 */
  uint8_t BIS[(HCI_MAX_PAYLOAD_SIZE - 24)/sizeof(uint8_t)];
} hci_le_big_create_sync_cp0;

typedef PACKED(struct) hci_le_big_create_sync_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_big_create_sync_rp0;

typedef PACKED(struct) hci_le_big_terminate_sync_cp0_s {
/**
 * Used to identify the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
} hci_le_big_terminate_sync_cp0;

typedef PACKED(struct) hci_le_big_terminate_sync_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Identifer of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
} hci_le_big_terminate_sync_rp0;

typedef PACKED(struct) hci_le_request_peer_sca_cp0_s {
/**
 * Connection handle of the ACL.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_request_peer_sca_cp0;

typedef PACKED(struct) hci_le_request_peer_sca_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_request_peer_sca_rp0;

typedef PACKED(struct) hci_le_setup_iso_data_path_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The Data_Path_Direction parameter specifies the direction for which the data
 * path is being configured. The input and output directions are defined from
 * the perspective of the Controller, so "input" refers to data flowing from the
 * Host to the Controller.
 * Values:
 * - 0x00: Input
 * - 0x01: Output
 */
  uint8_t Data_Path_Direction;
/**
 * The Data_Path_ID parameter specifies the data transport path used. When set
 * to 0x00, the data path shall be over the HCI transport. When set to 0xFF the
 * path shall be disabled. When set to a value in the range 0x01 to 0xFE, the
 * data path shall use a vendor-specific transport interface (e.g., a PCM
 * interface) with logical transport numbers. The meanings of these logical
 * transport numbers are vendor-specific.
 * Values:
 * - 0x00: HCI
 * - 0x01 ... 0xFE
 * - 0xFF: Disabled
 */
  uint8_t Data_Path_ID;
/**
 * The Codec_ID parameter specifies the coding format used over the air. Octet
 * 0: See Assigned Numbers for Coding Format. Octets 1 to 2: Company ID, see
 * Assigned Numbers for Company Identifier. Shall be ignored if octet 0 is not
 * 0xFF. Octets 3 to 4: Vendor-defined codec ID. Shall be ignored if octet 0 is
 * not 0xFF.
 */
  uint8_t Codec_ID[5];
/**
 * Controller delay in microseconds. When Data_Path_Direction is set to 0x00
 * (input), the Controller_Delay parameter specifies the delay at the data
 * source from the reference time of an SDU to the CIG reference point (see
 * Bluetooth Core v5.2 [Vol 6] Part B, Section 4.5.14.1) or BIG anchor point
 * (see Core v5.2 [Vol 6] Part B, Section 4.4.6.4). When Data_Path_Direction is
 * set to 0x01 (output), Controller_Delay specifies the delay from the CIG
 * synchronization point or BIG synchronization point to the point in time at
 * which the Controller begins to transfer the corresponding data to the data
 * path interface.
 * Values:
 * - 0x000000 ... 0x3D0900
 */
  uint8_t Controller_Delay[3];
/**
 * Length of codec configuration.
 */
  uint8_t Codec_Configuration_Length;
/**
 * The Codec_Configuration parameter specifies codec-specific configuration
 * information for the specified direction.
 */
  uint8_t Codec_Configuration[(HCI_MAX_PAYLOAD_SIZE - 13)/sizeof(uint8_t)];
} hci_le_setup_iso_data_path_cp0;

typedef PACKED(struct) hci_le_setup_iso_data_path_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_setup_iso_data_path_rp0;

typedef PACKED(struct) hci_le_remove_iso_data_path_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The Data_Path_Direction parameter specifies which directions are to have the
 * data path removed.
 * Flags:
 * - 0x01: Input
 * - 0x02: Output
 */
  uint8_t Data_Path_Direction;
} hci_le_remove_iso_data_path_cp0;

typedef PACKED(struct) hci_le_remove_iso_data_path_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_remove_iso_data_path_rp0;

typedef PACKED(struct) hci_le_iso_transmit_test_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The Payload_Type parameter defines the configuration of SDUs in the payload.
 * Values:
 * - 0x00: ZERO_LENGTH_PAYLOAD
 * - 0x01: VARIABLE_LENGTH_PAYLOAD
 * - 0x02: MAXIMUM_LENGTH_PAYLOAD
 */
  uint8_t Payload_Type;
} hci_le_iso_transmit_test_cp0;

typedef PACKED(struct) hci_le_iso_transmit_test_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_iso_transmit_test_rp0;

typedef PACKED(struct) hci_le_iso_receive_test_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The Payload_Type parameter defines the configuration of SDUs in the payload.
 * Values:
 * - 0x00: ZERO_LENGTH_PAYLOAD
 * - 0x01: VARIABLE_LENGTH_PAYLOAD
 * - 0x02: MAXIMUM_LENGTH_PAYLOAD
 */
  uint8_t Payload_Type;
} hci_le_iso_receive_test_cp0;

typedef PACKED(struct) hci_le_iso_receive_test_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_iso_receive_test_rp0;

typedef PACKED(struct) hci_le_iso_read_test_counters_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_iso_read_test_counters_cp0;

typedef PACKED(struct) hci_le_iso_read_test_counters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Number in the Received_Packet_Count.
 */
  uint32_t Received_Packet_Count;
/**
 * Number in the Missed_Packet_Count.
 */
  uint32_t Missed_Packet_Count;
/**
 * Number in the Failed_Packet_Count.
 */
  uint32_t Failed_Packet_Count;
} hci_le_iso_read_test_counters_rp0;

typedef PACKED(struct) hci_le_iso_test_end_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_iso_test_end_cp0;

typedef PACKED(struct) hci_le_iso_test_end_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Number in the Received_Packet_Count.
 */
  uint32_t Received_Packet_Count;
/**
 * Number in the Missed_Packet_Count.
 */
  uint32_t Missed_Packet_Count;
/**
 * Number in the Failed_Packet_Count.
 */
  uint32_t Failed_Packet_Count;
} hci_le_iso_test_end_rp0;

typedef PACKED(struct) hci_le_set_host_feature_cp0_s {
/**
 * Bit position in the FeatureSet.
 * Values:
 * - 0x00 ... 0x3F
 */
  uint8_t Bit_Number;
/**
 * If 0, the Host feature is disabled, if 1 the Host feature is enablded.
 * Values:
 * - 0x00: DISABLED
 * - 0x01: ENABLED
 */
  uint8_t Bit_Value;
} hci_le_set_host_feature_cp0;

typedef PACKED(struct) hci_le_set_host_feature_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_host_feature_rp0;

typedef PACKED(struct) hci_le_read_iso_link_quality_cp0_s {
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_read_iso_link_quality_cp0;

typedef PACKED(struct) hci_le_read_iso_link_quality_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS or BIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Value of the Tx_UnACKed_Packets counter. Incremented when the Link Layer does
 * not receive an acknowledgment for a CIS Data PDU that it transmitted at least
 * once by its flush point (see Core 5.2 [Vol 6] Part B, Section 4.5.13.5).
 */
  uint32_t Tx_UnACKed_Packets;
/**
 * Value of the Tx_Flushed_Packets counter. Incremented when the Link Layer does
 * not transmit a specific payload by its flush point.
 */
  uint32_t Tx_Flushed_Packets;
/**
 * Value of the Tx_Last_Subevent_Packets counter. Incremented when the Link
 * Layer transmits a CIS Data PDU in the last subevent of a CIS event.
 */
  uint32_t Tx_Last_Subevent_Packets;
/**
 * Value of the Retransmitted_Packets counter. Incremented when the Link Layer
 * retransmits a CIS Data PDU.
 */
  uint32_t Retransmitted_Packets;
/**
 * Value of the CRC_Error_Packets counter. Incremented when the Link Layer
 * receives a packet with a CRC error.
 */
  uint32_t CRC_Error_Packets;
/**
 * Value of the Rx_Unreceived_Packets counter. Incremented when the Link Layer
 * does not receive a specific payload by its flush point (on a CIS) or the end
 * of the event it is associated with (on a BIS; see Core v5.2 [Vol 6] Part B,
 * Section 4.4.6.6).
 */
  uint32_t Rx_Unreceived_Packets;
/**
 * Value of the Duplicate_Packets counter. Incremented when the Link Layer
 * receives a retransmission of a CIS Data PDU.
 */
  uint32_t Duplicate_Packets;
} hci_le_read_iso_link_quality_rp0;

typedef PACKED(struct) hci_le_enhanced_read_transmit_power_level_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * PHY associated with the connection  (not necessarily the currently used one).
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
} hci_le_enhanced_read_transmit_power_level_cp0;

typedef PACKED(struct) hci_le_enhanced_read_transmit_power_level_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * PHY associated with the connection  (not necessarily the currently used one).
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 * Current TX power level (dBm).
 * Values:
 * - -127 ... 20
 * - 127: NA
 */
  int8_t Current_Transmit_Power_Level;
/**
 * Maximum TX power level (dBm).
 * Values:
 * - -127 ... 20
 */
  int8_t Max_Transmit_Power_Level;
} hci_le_enhanced_read_transmit_power_level_rp0;

typedef PACKED(struct) hci_le_read_remote_transmit_power_level_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * PHY associated with the connection  (not necessarily the currently used one).
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
} hci_le_read_remote_transmit_power_level_cp0;

typedef PACKED(struct) hci_le_read_remote_transmit_power_level_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_read_remote_transmit_power_level_rp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_parameters_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * High threshold for the path loss. Units: dB.
 * Values:
 * - 0 ... 254
 * - 255: UNUSED
 */
  uint8_t High_Threshold;
/**
 * Hysteresis value for the high threshold. Units: dB.
 */
  uint8_t High_Hysteresis;
/**
 * Low threshold for the path loss. Units: dB.
 */
  uint8_t Low_Threshold;
/**
 * Hysteresis value for the low threshold. Units: dB.
 */
  uint8_t Low_Hysteresis;
/**
 * Minimum time in number of connection events to be observed once the path
 * crosses the threshold before an event is generated.
 */
  uint16_t Min_Time_Spent;
} hci_le_set_path_loss_reporting_parameters_cp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_set_path_loss_reporting_parameters_rp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_enable_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Enable (1) or disable (0) reportinig.
 * Values:
 * - 0x00: DISABLE
 * - 0x01: ENABLE
 */
  uint8_t Enable;
} hci_le_set_path_loss_reporting_enable_cp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_set_path_loss_reporting_enable_rp0;

typedef PACKED(struct) hci_le_set_transmit_power_reporting_enable_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Enable (1) or disable (0) local transmit power reports.
 * Values:
 * - 0x00: DISABLE
 * - 0x01: ENABLE
 */
  uint8_t Local_Enable;
/**
 * Enable (1) or disable (0) remote transmit power reports.
 * Values:
 * - 0x00: DISABLE
 * - 0x01: ENABLE
 */
  uint8_t Remote_Enable;
} hci_le_set_transmit_power_reporting_enable_cp0;

typedef PACKED(struct) hci_le_set_transmit_power_reporting_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_set_transmit_power_reporting_enable_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v4_cp0_s {
/**
 * N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 * Values:
 * - 0x00 ... 0x27
 */
  uint8_t TX_Channel;
/**
 * Length in bytes of payload data in each packet.     Supported ranges:       -
 * (0x00,0x25) if data length extension is disabled.       - (0x00,0xFF) if data
 * length extension is enabled.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Test_Data_Length;
/**
 * Content of the Payload of the test reference packets.  0: PRBS9 sequence
 * '11111111100000111101...' (in transmission order) 1: Repeated '11110000' (in
 * transmission order) sequence 2: Repeated '10101010' (in transmission order)
 * sequence 3: PRBS15 sequence 4: Repeated '11111111' (in transmission order)
 * sequence 5: Repeated '00000000' (in transmission order) sequence 6: Repeated
 * '00001111' (in transmission order) sequence 7: Repeated '01010101' (in
 * transmission order) sequence
 * Values:
 * - 0x00: PRBS9
 * - 0x01: Repeated '11110000'
 * - 0x02: Repeated '10101010'
 * - 0x03: PRBS15
 * - 0x04: Repeated '11111111'
 * - 0x05: Repeated '00000000'
 * - 0x06: Repeated '00001111'
 * - 0x07: Repeated '01010101'
 */
  uint8_t Packet_Payload;
/**
 * PHY to be used by the transmitter.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 *
 * Values:
 * - 0x00: No Constant Tone Extension expected (default)
 * - 0x02 ... 0x14: Expected length of the Constant Tone Extension in 8 microseconds units.
 */
  uint8_t CTE_Length;
/**
 *
 * Values:
 * - 0x00: Expect AoA Constant Tone Extension
 * - 0x01: Expect AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: Expect AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t CTE_Type;
/**
 *
 * Values:
 * - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_transmitter_test_v4_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v4_cp1_s {
/**
 *
 * Values:
 * - -127 ... 20: Set transmitter to the specified or the nearest transmit power level.
 * - 126: Set transmitter to minimum transmit power level
 * - 127: Set transmitter to maximum transmit power level
 */
  int8_t Transmit_Power_Level;
} hci_le_transmitter_test_v4_cp1;

typedef PACKED(struct) hci_le_transmitter_test_v4_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_transmitter_test_v4_rp0;

typedef PACKED(struct) hci_le_set_data_related_address_changes_cp0_s {
/**
 * Used to identify an advertising set.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * Bitmap associated with the reasons to refresh the Resolvable Private
 * Addresses used by the advertising set. If bit 0 is set, change the address
 * whenever the advertising data changes. If bit 1 is set, change the address
 * whenever the scan response data changes.
 * Flags:
 * - 0x01: ADV_DATA_CHANGES
 * - 0x02: SCAN_RESP_DATA_CHANGES
 */
  uint8_t Change_Reasons;
} hci_le_set_data_related_address_changes_cp0;

typedef PACKED(struct) hci_le_set_data_related_address_changes_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_data_related_address_changes_rp0;

typedef PACKED(struct) hci_le_set_default_subrate_cp0_s {
/**
 * Minimum subrate factor allowed in requests by a Peripheral.
 * Values:
 * - 0x0001 ... 0x01F4
 */
  uint16_t Subrate_Min;
/**
 * Maximum subrate factor allowed in requests by a Peripheral.
 * Values:
 * - 0x0001 ... 0x01F4
 */
  uint16_t Subrate_Max;
/**
 * Maximum Peripheral latency allowed in requests by a Peripheral, in units of
 * subrated connection intervals.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Minimum number of underlying connection events to remain active after a
 * packet containing a Link Layer PDU with a non-zero Length field is sent or
 * received in requests by a Peripheral.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Continuation_Number;
/**
 * Maximum supervision timeout allowed in requests by a Peripheral. Time = N x
 * 10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
} hci_le_set_default_subrate_cp0;

typedef PACKED(struct) hci_le_set_default_subrate_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_set_default_subrate_rp0;

typedef PACKED(struct) hci_le_subrate_request_cp0_s {
/**
 * Connection handle of the ACL.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Minimum subrate factor to be applied to the underlying connection interval.
 * Values:
 * - 0x0001 ... 0x01F4
 */
  uint16_t Subrate_Min;
/**
 * Maximum subrate factor to be applied to the underlying connection interval.
 * Values:
 * - 0x0001 ... 0x01F4
 */
  uint16_t Subrate_Max;
/**
 * Maximum Peripheral latency for the connection in units of subrated connection
 * intervals.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Minimum number of underlying connection events to remain active after a
 * packet containing a Link Layer PDU with a non-zero Length field is sent or
 * received.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Continuation_Number;
/**
 * Supervision timeout for this connection. Time = N x 10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
} hci_le_subrate_request_cp0;

typedef PACKED(struct) hci_le_subrate_request_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_subrate_request_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_v2_cp0_s {
/**
 * The Advertising_Handle parameter identifies the advertising set whose
 * parameters are being configured.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * The Advertising_Event_Properties parameter describes the type of advertising
 * event that is being configured and its basic properties. The type shall be
 * one supported by the Controller. Bits: 0 Connectable advertising 1 Scannable
 * advertising 2 Directed advertising 3 High Duty Cycle Directed Connectable
 * advertising (<= 3.75 ms Advertising Interval) 4 Use legacy advertising PDUs 5
 * Omit advertiser's address from all PDUs ("anonymous advertising") 6 Include
 * TxPower in the extended header of the advertising PDU
 * Flags:
 * - 0x0001: Connectable
 * - 0x0002: Scannable
 * - 0x0004: Directed
 * - 0x0008: HDC Directed Connectable
 * - 0x0010: Legacy
 * - 0x0020: Anonymous
 * - 0x0040: TxPower in ext header
 */
  uint16_t Advertising_Event_Properties;
/**
 * Minimum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 ms; Time Range: 20 ms to 10,485.759375 s.
 * Values:
 * - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 */
  uint8_t Primary_Advertising_Interval_Min[3];
/**
 * Maximum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 ms; Time Range: 20 ms to 10,485.759375 s.
 * Values:
 * - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 */
  uint8_t Primary_Advertising_Interval_Max[3];
/**
 * The Primary_Advertising_Channel_Map is a bit field that indicates the
 * advertising channels that shall be used when transmitting advertising
 * packets. At least one channel bit shall be set in the
 * Primary_Advertising_Channel_Map parameter.
 * Flags:
 * - 0x01: CH_37
 * - 0x02: CH_38
 * - 0x04: CH_39
 */
  uint8_t Primary_Advertising_Channel_Map;
/**
 * The Own_Address_Type parameter specifies the type of address being used in
 * the advertising packets. For random addresses, the address is specified by
 * the LE_Set_Advertising_Set_Random_Address command.  0x00 Public Device
 * Address 0x01 Random Device Address 0x02 Controller generates the Resolvable
 * Private Address based on the local IRK from the resolving list. If the
 * resolving list contains no matching entry, use the public address. 0x03
 * Controller generates the Resolvable Private Address based on the local IRK
 * from the resolving list. If the resolving list contains no matching entry,
 * use the random address from LE_Set_Advertising_Set_Random_Address. All other
 * values Reserved for future use
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Resolvable Private Address / Public Address
 * - 0x03: Resolvable Private Address / Random Address
 */
  uint8_t Own_Address_Type;
/**
 * Peer Address type
 * Values:
 * - 0x00: Public Device Address or Public Identity Address
 * - 0x01: Random Device Address or Random (static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Advertising Filter Policy. This parameter is ignored when directed
 * advertising is enabled.  0x00 Process scan and connection requests from all
 * devices (i.e., the Filter Accept List is not in use) 0x01 Process connection
 * requests from all devices and scan requests only from devices that are in the
 * Filter Accept List 0x02 Process scan requests from all devices and connection
 * requests only from devices that are in the Filter Accept List. 0x03 Process
 * scan and connection requests only from devices in the Filter Accept List. All
 * other values are reserved for future use
 * Values:
 * - 0x00: HCI_ADV_FILTER_NONE
 * - 0x01: HCI_ADV_FILTER_ACCEPT_LIST_SCAN
 * - 0x02: HCI_ADV_FILTER_ACCEPT_LIST_CONNECT
 * - 0x03: HCI_ADV_FILTER_ACCEPT_LIST_SCAN_CONNECT
 */
  uint8_t Advertising_Filter_Policy;
/**
 * Units: dBm  The Advertising_Tx_Power parameter indicates the maximum power
 * level at which the advertising packets are to be transmitted on the
 * advertising channels. The Controller shall choose a power level lower than or
 * equal to the one specified by the Host.
 * Values:
 * - -127 ... 126
 * - 127: No preference
 */
  int8_t Advertising_Tx_Power;
/**
 * The Primary_Advertising_PHY parameter indicates the PHY on which the
 * advertising packets are transmitted on the primary advertising channel. If
 * legacy advertising PDUs are being used, the Primary_Advertising_PHY shall
 * indicate the LE 1M PHY.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t Primary_Advertising_PHY;
/**
 * The Secondary_Advertising_Max_Skip parameter is the maximum number of
 * advertising events that can be skipped before the AUX_ADV_IND can be sent.
 * 0x00 AUX_ADV_IND shall be sent prior to the next advertising event 0x01-0xFF
 * Maximum advertising events the Controller can skip before sending the
 * AUX_ADV_IND packets on the secondary advertising channel
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Secondary_Advertising_Max_Skip;
/**
 * The Secondary_Advertising_PHY parameter indicates the PHY on which the
 * advertising packets are transmitted on the secondary advertising channel.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t Secondary_Advertising_PHY;
/**
 * The Advertising_SID parameter specifies the value to be transmitted in the
 * Advertising SID subfield of the ADI field of the Extended Header of those
 * advertising channel PDUs that have an ADI field. If the advertising set only
 * uses PDUs that do not contain an ADI field, Advertising_SID is ignored.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t Advertising_SID;
/**
 * The Scan_Request_Notification_Enable parameter indicates whether the
 * Controller shall send notifications upon the receipt of a scan request PDU
 * that is in response to an advertisement from the specified advertising set
 * that contains its device address and is from a scanner that is allowed by the
 * advertising filter policy.
 * Values:
 * - 0x00: Scan request notifications disabled
 * - 0x01: Scan request notifications enabled
 */
  uint8_t Scan_Request_Notification_Enable;
/**
 * Preference or requirements on coding scheme when transmitting on Primary
 * Advertising Physical Channel.
 * Values:
 * - 0x00: CODED_PHY_NO_PREFERENCE
 * - 0x01: CODED_PHY_S2_PREFERRED
 * - 0x02: CODED_PHY_S8_PREFERRED
 * - 0x03: CODED_PHY_S2_REQUIRED
 * - 0x04: CODED_PHY_S8_REQUIRED
 */
  uint8_t Primary_Advertising_PHY_Options;
/**
 * Preference or requirements on coding scheme when transmitting on Secondary
 * Advertising Physical Channel.
 * Values:
 * - 0x00: CODED_PHY_NO_PREFERENCE
 * - 0x01: CODED_PHY_S2_PREFERRED
 * - 0x02: CODED_PHY_S8_PREFERRED
 * - 0x03: CODED_PHY_S2_REQUIRED
 * - 0x04: CODED_PHY_S8_REQUIRED
 */
  uint8_t Secondary_Advertising_PHY_Options;
} hci_le_set_extended_advertising_parameters_v2_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Units: dBm. The Selected_Tx_Power return parameter indicates the transmit
 * power selected by the Controller. The Controller shall not change the
 * transmit power for this advertising set without being directed to by the
 * Host.
 * Values:
 * - -127 ... 126
 */
  int8_t Selected_Tx_Power;
} hci_le_set_extended_advertising_parameters_v2_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_subevent_data_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 */
  uint8_t Advertising_Handle;
/**
 * Number of subevent data in the command.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t Num_Subevents;
/**
 * See @ref Subevent_Data_Parameters_t
 */
  packed_Subevent_Data_Parameters_t Subevent_Data_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Subevent_Data_Parameters_t)];
} hci_le_set_periodic_advertising_subevent_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_subevent_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Used to identify a periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_subevent_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_response_data_cp0_s {
/**
 * Sync_Handle identifying the PAwR train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * The value of paEventCounter (see [Vol 6] Part B, Section 4.4.2.1) for the
 * periodic advertising packet that the Host is responding to.
 */
  uint16_t Request_Event;
/**
 * Used to identify the subevent of the PAwR train.
 * Values:
 * - 0x00 ... 0x7F
 */
  uint8_t Request_Subevent;
/**
 * Used to identify the response slot of the PAwR train.
 */
  uint8_t Response_Subevent;
/**
 * Used to identify the response slot of the PAwR train.
 */
  uint8_t Response_Slot;
/**
 * The number of octets in the Response_Data parameter.
 * Values:
 * - 0x00 ... 0xFB
 */
  uint8_t Response_Data_Length;
/**
 * Response data formatted as defined in [Vol 3] Part C, Section 11.
 */
  uint8_t Response_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} hci_le_set_periodic_advertising_response_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_response_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
} hci_le_set_periodic_advertising_response_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_sync_subevent_cp0_s {
/**
 * Sync_Handle identifying the PAwR train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * If bit 6 is set, include TxPower in the advertising PDU.
 * Flags:
 * - 0x0040: TX_POWER
 */
  uint16_t Periodic_Advertising_Properties;
/**
 * Number of subevent data in the command.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t Num_Subevents;
/**
 * The subevent to synchronize with.
 */
  uint8_t Subevent[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_periodic_sync_subevent_cp0;

typedef PACKED(struct) hci_le_set_periodic_sync_subevent_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
} hci_le_set_periodic_sync_subevent_rp0;

typedef PACKED(struct) hci_le_extended_create_connection_v2_cp0_s {
/**
 * Advertising_Handle identifying the periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 * - 0xFF: Not specified
 */
  uint8_t Advertising_Handle;
/**
 * Subevent where the connection request is to be sent.
 * Values:
 * - 0x00 ... 0x7F
 * - 0xFF: Not specified
 */
  uint8_t Subevent;
/**
 * The Initiator_Filter_Policy parameter is used to determine whether the Filter
 * Accept List is used. If the Filter Accept List is not used, the
 * Peer_Address_Type and the Peer_Address parameters specify the address type
 * and address of the advertising device to connect to. 0x00 - Filter Accept
 * List is not used to determine which advertiser to connect to.
 * Peer_Address_Type and Peer_Address shall be used. 0x01 - Filter Accept List
 * is used to determine which advertiser to connect to. Peer_Address_Type and
 * Peer_Address shall be ignored.
 * Values:
 * - 0x00: FILTER_ACCEPT_LIST_NOT_USED
 * - 0x01: FILTER_ACCEPT_LIST_USED
 */
  uint8_t Initiator_Filter_Policy;
/**
 * The Own_Address_Type parameter indicates the type of address being used in
 * the connection request packets.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 * - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from the most recent successful
LE_Set_Random_Address Command.
 */
  uint8_t Own_Address_Type;
/**
 * The Peer_Address_Type parameter indicates the type of address used in the
 * connectable advertisement sent by the peer. 0x00: Public Device Address or
 * Public Identity Address 0x01: Random Device Address or Random (static)
 * Identity Address
 * Values:
 * - 0x00: Public Address
 * - 0x01: Random Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * The Initiating_PHYs parameter indicates the PHY(s) on which the advertising
 * packets should be received on the primary advertising channel and the PHYs
 * for which connection parameters have been specified. The Host may enable one
 * or more initiating PHYs. 0x01: Scan connectable advertisements on the LE 1M
 * PHY. Connection parameters for the LE 1M PHY are provided. 0x02: Connection
 * parameters for the LE 2M PHY are provided 0x04: Scan connectable
 * advertisements on the LE Coded PHY. Connection parameters for the LE Coded
 * PHY are provided.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t Initiating_PHYs;
/**
 * See @ref Extended_Create_Connection_Parameters_t
 */
  packed_Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(packed_Extended_Create_Connection_Parameters_t)];
} hci_le_extended_create_connection_v2_cp0;

typedef PACKED(struct) hci_le_extended_create_connection_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} hci_le_extended_create_connection_v2_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_v2_cp0_s {
/**
 * Used to identify a periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * Minimum advertising interval for periodic advertising. Time = N * 1.25 ms;
 * Time Range: 7.5ms to 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval_Min;
/**
 * Maximum advertising interval for periodic advertising. Time = N * 1.25 ms;
 * Time Range: 7.5ms to 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval_Max;
/**
 * The Periodic_Advertising_Properties parameter indicates which fields should
 * be included in the advertising packet.
 * Flags:
 * - 0x0040
 */
  uint16_t Periodic_Advertising_Properties;
/**
 * Number of subevents.
 * Values:
 * - 0x00 ... 0x80
 */
  uint8_t Num_Subevents;
/**
 * Interval between subevents. Time = N x 1.25 ms.
 * Values:
 * - 0x06 (7.50 ms)  ... 0xFF (318.75 ms) 
 */
  uint8_t Subevent_Interval;
/**
 * Time between the advertising packet in a subevent and the first response
 * slot. Time = N x 1.25 ms.
 * Values:
 * - 0x00 (NaN) : No response slots
 * - 0x01 (1.25 ms)  ... 0xFE (317.50 ms) 
 */
  uint8_t Response_Slot_Delay;
/**
 * Time between response slots. Time = N x 0.125 ms
 * Values:
 * - 0x00 (0.000 ms) : No response slots
 * - 0x02 (0.250 ms)  ... 0xFF (31.875 ms) 
 */
  uint8_t Response_Slot_Spacing;
/**
 * Number of subevent response slots.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Num_Response_Slots;
} hci_le_set_periodic_advertising_parameters_v2_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Used to identify a periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_parameters_v2_rp0;

typedef PACKED(struct) aci_hal_get_fw_build_number_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Build number of the firmware.
 */
  uint16_t Build_Number;
} aci_hal_get_fw_build_number_rp0;

typedef PACKED(struct) aci_hal_get_firmware_details_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Major version number of the DTM application part
 */
  uint8_t DTM_version_major;
/**
 * Minor version number of the DTM application part
 */
  uint8_t DTM_version_minor;
/**
 * Patch version number of the DTM application part
 */
  uint8_t DTM_version_patch;
/**
 * Transport layer mode (numbers not defined reserved for future use)
 * Values:
 * - 0x01: UART
 * - 0x02: SPI
 */
  uint8_t DTM_variant;
/**
 * Build number for DTM application part
 */
  uint16_t DTM_Build_Number;
/**
 * Major version number of BTLE stack
 */
  uint8_t BTLE_Stack_version_major;
/**
 * Minor version number of BTLE stack
 */
  uint8_t BTLE_Stack_version_minor;
/**
 * Patch version number of BTLE stack
 */
  uint8_t BTLE_Stack_version_patch;
/**
 * Specific variant build
 * Values:
 * - 0x00: Official release
 * - 0x01: Internal development release
 */
  uint8_t BTLE_Stack_development;
/**
 * Bitmask of BLE stack v4.x or later variants (modular configurations options
 * and link layer only)
 * Flags:
 * - 0x0001: CONTROLLER_PRIVACY_ENABLED
 * - 0x0002: SECURE_CONNECTIONS_ENABLED
 * - 0x0004: CONTROLLER_SCAN_ENABLED
 * - 0x0008: CONTROLLER_DATA_LENGTH_EXTENSION_ENABLED
 * - 0x0010: LINK LAYER ONLY
 * - 0x0020: CONTROLLER_2M_CODED_PHY_ENABLED
 * - 0x0040: CONTROLLER_EXT_ADV_SCAN_ENABLED
 * - 0x0080: L2CAP_COS_ENABLED
 * - 0x0100: CONTROLLER_PERIODIC_ADV_ENABLED
 * - 0x0200: CONTROLLER_CTE_ENABLED
 * - 0x0400: CONTROLLER_POWER_CONTROL_ENABLED
 * - 0x0800: CONNECTION_ENABLED
 */
  uint16_t BTLE_Stack_variant;
/**
 * Build number for BTLE stack
 */
  uint16_t BTLE_Stack_Build_Number;
} aci_hal_get_firmware_details_rp0;

typedef PACKED(struct) aci_hal_get_firmware_details_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Major version number of the DTM application part
 */
  uint8_t DTM_version_major;
/**
 * Minor version number of the DTM application part
 */
  uint8_t DTM_version_minor;
/**
 * Patch version number of the DTM application part
 */
  uint8_t DTM_version_patch;
/**
 * Transport layer mode (numbers not defined reserved for future use)
 * Values:
 * - 0x01: UART
 * - 0x02: SPI
 */
  uint8_t DTM_variant;
/**
 * Build number for DTM application part
 */
  uint16_t DTM_Build_Number;
/**
 * Major version number of BTLE stack
 */
  uint8_t BTLE_Stack_version_major;
/**
 * Minor version number of BTLE stack
 */
  uint8_t BTLE_Stack_version_minor;
/**
 * Patch version number of BTLE stack
 */
  uint8_t BTLE_Stack_version_patch;
/**
 * Specific variant build
 * Values:
 * - 0x00: Official release
 * - 0x01: Internal development release
 */
  uint8_t BTLE_Stack_development;
/**
 * Bitmask of BLE stack v4.x or later variants (modular configurations options
 * and link layer only)
 * Flags:
 * - 0x00000001: CONTROLLER_PRIVACY_ENABLED
 * - 0x00000002: SECURE_CONNECTIONS_ENABLED
 * - 0x00000004: CONTROLLER_SCAN_ENABLED
 * - 0x00000008: CONTROLLER_DATA_LENGTH_EXTENSION_ENABLED
 * - 0x00000010: LINK LAYER ONLY
 * - 0x00000020: CONTROLLER_2M_CODED_PHY_ENABLED
 * - 0x00000040: CONTROLLER_EXT_ADV_SCAN_ENABLED
 * - 0x00000080: L2CAP_COS_ENABLED
 * - 0x00000100: CONTROLLER_PERIODIC_ADV_ENABLED
 * - 0x00000200: CONTROLLER_CTE_ENABLED
 * - 0x00000400: CONTROLLER_POWER_CONTROL_ENABLED
 * - 0x00000800: CONNECTION_ENABLED
 * - 0x00010000: CONTROLLER_CHAN_CLASS_ENABLED
 * - 0x00020000: CONTROLLER_BIS_ENABLED
 * - 0x00080000: CONNECTION_SUBRATING_ENABLED
 * - 0x00100000: CONTROLLER_CIS_ENABLED
 * - 0x00400000: CONTROLLER_PERIODIC_ADV_WR
 */
  uint32_t BTLE_Stack_variant;
/**
 * Build number for BTLE stack
 */
  uint16_t BTLE_Stack_Build_Number;
} aci_hal_get_firmware_details_v2_rp0;

typedef PACKED(struct) aci_hal_write_config_data_cp0_s {
/**
 * Offset of the element in the configuration data structure which has to be
 * written. The valid offsets are:  - 0x00: Bluetooth public address, Value
 * length to be written: 6 bytes - 0x08: Encryption root key used to derive LTK
 * and CSRK, Value length to be written: 16 bytes - 0x18: Identity root key used
 * to derive LTK and CSRK, Value length to be written: 16 bytes - 0x2C: Link
 * layer without host (for certification purposes), Value length to be written:
 * 1 byte - 0x2E: If set, the stack uses this address as the static random
 * address instead of the one stored in NVM. - 0x2F: Value is a bit field that
 * indicates the advertising channel indices that shall be used when scanning.
 * At least one channel bit shall be set. Bit 0: ch. 37; bit 1: ch. 38; bit 2:
 * ch 39. - 0xD0: Use debug key for Secure connection: 1 byte - 0xD1: Set the
 * maximum allowed parameter values for Data Length Extension: 8 bytes, 2 bytes
 * for each of the following parameters:         supportedMaxTxOctets,
 * supportedMaxTxTime, supportedMaxRxOctets, supportedMaxRxTime, in little-
 * endian order.         (default 251,2120,251,2120).
 * Values:
 * - 0x00: CONFIG_DATA_PUBADDR_OFFSET
 * - 0x08: CONFIG_DATA_ER_OFFSET
 * - 0x18: CONFIG_DATA_IR_OFFSET
 * - 0x2C: LL_WITHOUT_HOST
 * - 0x2E: CONFIG_DATA_STATIC_RANDOM_ADDRESS
 * - 0x2F: CONFIG_DATA_SCAN_CH_MAP
 * - 0xD0: CONFIG_DATA_DEBUG_KEY
 * - 0xD1: CONFIG_DATA_DLE
 */
  uint8_t Offset;
/**
 * Length of data to be written
 */
  uint8_t Length;
/**
 * Data to be written
 */
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_write_config_data_cp0;

typedef PACKED(struct) aci_hal_write_config_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_write_config_data_rp0;

typedef PACKED(struct) aci_hal_read_config_data_cp0_s {
/**
 * Offset of the element in the configuration data structure which has to be
 * read. The valid offsets are:  - 0x00: Bluetooth public address, Value length
 * returned: 6 bytes - 0x08: Encryption root key used to derive LTK and CSRK,
 * Value length returned: 16 bytes - 0x18: Identity root key used to derive LTK
 * and CSRK, Value length returned: 16 bytes - 0x2C: Link layer without host
 * (for certification purposes), Value length returned: 1 byte - 0x80: The
 * static random address stored in NVM. Value length returned: 6 bytes (read-
 * only)
 * Values:
 * - 0x00: CONFIG_DATA_PUBADDR_OFFSET
 * - 0x08: CONFIG_DATA_ER_OFFSET
 * - 0x18: CONFIG_DATA_IR_OFFSET
 * - 0x2C: LL_WITHOUT_HOST
 * - 0x80: CONFIG_DATA_STORED_STATIC_RANDOM_ADDRESS
 */
  uint8_t Offset;
} aci_hal_read_config_data_cp0;

typedef PACKED(struct) aci_hal_read_config_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of Data in octets
 */
  uint8_t Data_Length;
/**
 * Data field associated with Offset parameter
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_read_config_data_rp0;

typedef PACKED(struct) aci_hal_set_tx_power_level_cp0_s {
/**
 * Enable High Power mode, by changing SMPS level. High power mode should be
 * enabled only to reach the maximum output power. Normal power (0x00) is the
 * default.
 * Values:
 * - 0x00: Normal Power
 * - 0x01: High Power
 */
  uint8_t En_High_Power;
/**
 * Power amplifier output level. PA_Level 32 is available only for STM32WB09, to
 * select 8 dBm of output power.
 * Values:
 * - 0: -54/-54 dBm
 * - 1: -21/-19 dBm
 * - 2: -20/-18 dBm
 * - 3: -19/-17 dBm
 * - 4: -17/-16 dBm
 * - 5: -16/-15 dBm
 * - 6: -15/-14 dBm
 * - 7: -14/-13 dBm
 * - 8: -13/-12 dBm
 * - 9: -12/-11 dBm
 * - 10: -11/-10 dBm
 * - 11: -10/-9 dBm
 * - 12: -9/-8 dBm
 * - 13: -8/-7 dBm
 * - 14: -7/-6 dBm
 * - 15: -6/-5 dBm
 * - 16: -6/-4 dBm
 * - 17: -4/-3 dBm
 * - 18: -3/-3 dBm
 * - 19: -3/-2 dBm
 * - 20: -2/-1 dBm
 * - 21: -2/+0 dBm
 * - 22: -1/+1 dBm
 * - 23: -1/+2 dBm
 * - 24: +0/+3 dBm
 * - 25: +0/+8 dBm
 * - 26: +1/+8 dBm
 * - 27: +2/+8 dBm
 * - 28: +3/+8 dBm
 * - 29: +4/+8 dBm
 * - 30: +5/+8 dBm
 * - 31: +6/+8 dBm
 * - 32: +8 dBm
 */
  uint8_t PA_Level;
} aci_hal_set_tx_power_level_cp0;

typedef PACKED(struct) aci_hal_set_tx_power_level_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_set_tx_power_level_rp0;

typedef PACKED(struct) aci_hal_le_tx_test_packet_number_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Number of packets sent during the last Direct TX test.
 */
  uint32_t Number_Of_Packets;
} aci_hal_le_tx_test_packet_number_rp0;

typedef PACKED(struct) aci_hal_tone_start_cp0_s {
/**
 * BLE Channel ID, from 0x00 to 0x27 meaning (2.402 + 2*0xXX) GHz.
 * Values:
 * - 0x00 ... 0x27
 */
  uint8_t RF_Channel;
/**
 * Specify if the tone must be emitted with an offset from the channel center
 * frequency.  If 0, the tone is emitted at the channel center frequency. If 1
 * or 2, the device will continuously emit the tone at the center frequency plus
 * or minus 250 kHz respectively.
 * Values:
 * - 0x00: 0 kHz offset
 * - 0x01: +250 kHz offset
 * - 0x02: -250 kHz offset
 */
  uint8_t Offset;
} aci_hal_tone_start_cp0;

typedef PACKED(struct) aci_hal_tone_start_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_tone_start_rp0;

typedef PACKED(struct) aci_hal_tone_stop_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_tone_stop_rp0;

typedef PACKED(struct) aci_hal_get_link_status_cp0_s {
/**
 * Index that identifies the link bank. Each bank is made by 8 links. Set
 * Bank_Index to 0 to retrieve the status of the first 8 links, Bank_Index 1 to
 * retrieve the status of the second 8 links and so on.
 * Values:
 * - 0x00 ... 0x15
 */
  uint8_t Bank_index;
} aci_hal_get_link_status_cp0;

typedef PACKED(struct) aci_hal_get_link_status_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Array of link status (8 links). Each link status is 1 byte. - 0x00: Idle -
 * 0x01: Advertising - 0x02: Connected as peripheral - 0x03: Scanning - 0x04:
 * Initiating - 0x05: Connected as central - 0x06: TX test mode - 0x07: RX test
 * mode
 */
  uint8_t Link_Status[8];
/**
 * Array of connection handles (2 bytes) for 8 links.
 */
  uint16_t Link_Connection_Handle[16 / 2];
} aci_hal_get_link_status_rp0;

typedef PACKED(struct) aci_hal_set_radio_activity_mask_cp0_s {
/**
 * Bitmask of radio events
 * Flags:
 * - 0x0001: Idle
 * - 0x0002: Advertising
 * - 0x0004: Connection event peripheral
 * - 0x0008: Scanning
 * - 0x0010: Connection request
 * - 0x0020: Connection event central
 * - 0x0040: TX test mode
 * - 0x0080: RX test mode
 */
  uint16_t Radio_Activity_Mask;
} aci_hal_set_radio_activity_mask_cp0;

typedef PACKED(struct) aci_hal_set_radio_activity_mask_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_set_radio_activity_mask_rp0;

typedef PACKED(struct) aci_hal_set_le_power_control_cp0_s {
/**
 * Enable (1) or disable (0) LE power control on following connections. Default:
 * 1.
 * Values:
 * - 0x00: DISABLE
 * - 0x01: ENABLE
 */
  uint8_t Enable;
/**
 * PHY on which the power control must be enabled or disabled.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 * Target RSSI in dBm. Default: -55 dBm.
 */
  int8_t RSSI_Target;
/**
 * Hysteresis applied on the target RSSI in dB. Default: 15 dB.
 */
  uint8_t RSSI_Hysteresis;
/**
 * Initial TX power in dBm. Default: max TX power supported by the platform.
 */
  int8_t Initial_TX_Power;
/**
 * Coefficient used for the filtering of the RSSI samples and the calculation of
 * the average RSSI. Allowed values are from 0 (fast moving average, low
 * accuracy, max weight of last RSSI) to 4 (slow moving average, high accuracy,
 * min weight of last RSSI). Default: 2.
 * Values:
 * - 0x00 ... 0x04
 */
  uint8_t RSSI_Filtering_Coefficient;
} aci_hal_set_le_power_control_cp0;

typedef PACKED(struct) aci_hal_set_le_power_control_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_set_le_power_control_rp0;

typedef PACKED(struct) aci_hal_updater_start_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_updater_start_rp0;

typedef PACKED(struct) aci_hal_get_updater_version_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  uint8_t Version;
} aci_hal_get_updater_version_rp0;

typedef PACKED(struct) aci_hal_get_updater_bufsize_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  uint8_t Buffer_Size;
} aci_hal_get_updater_bufsize_rp0;

typedef PACKED(struct) aci_hal_updater_erase_blue_flag_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_updater_erase_blue_flag_rp0;

typedef PACKED(struct) aci_hal_updater_reset_blue_flag_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_updater_reset_blue_flag_rp0;

typedef PACKED(struct) aci_hal_updater_erase_sector_cp0_s {
/**
 *
 */
  uint32_t Address;
} aci_hal_updater_erase_sector_cp0;

typedef PACKED(struct) aci_hal_updater_erase_sector_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_updater_erase_sector_rp0;

typedef PACKED(struct) aci_hal_updater_prog_data_blk_cp0_s {
/**
 *
 */
  uint32_t Address;
/**
 * Length of Data in octets
 */
  uint16_t Data_Length;
/**
 *
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_hal_updater_prog_data_blk_cp0;

typedef PACKED(struct) aci_hal_updater_prog_data_blk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_updater_prog_data_blk_rp0;

typedef PACKED(struct) aci_hal_updater_read_data_blk_cp0_s {
/**
 *
 */
  uint32_t Address;
/**
 *
 */
  uint16_t Data_Length;
} aci_hal_updater_read_data_blk_cp0;

typedef PACKED(struct) aci_hal_updater_read_data_blk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(uint8_t)];
} aci_hal_updater_read_data_blk_rp0;

typedef PACKED(struct) aci_hal_updater_calc_crc_cp0_s {
/**
 *
 */
  uint32_t Address;
/**
 *
 */
  uint8_t Num_Of_Sectors;
} aci_hal_updater_calc_crc_cp0;

typedef PACKED(struct) aci_hal_updater_calc_crc_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  uint32_t crc;
} aci_hal_updater_calc_crc_rp0;

typedef PACKED(struct) aci_hal_updater_hw_version_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * It is the content of Die ID register.
 */
  uint8_t HW_Version;
} aci_hal_updater_hw_version_rp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_cp0_s {
/**
 * N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 * Values:
 * - 0x00 ... 0x27
 */
  uint8_t TX_Frequency;
/**
 * Length in bytes of payload data in each packet.     Supported ranges:       -
 * (0x00,0x25): BlueNRG-1 and BlueNRG-2 with BLE stack version < 2.1       -
 * (0x00,0xFF): BlueNRG-2 with BLE stack version >= 2.1 and extended packet
 * length.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Length_Of_Test_Data;
/**
 * Type of packet payload.
 * Values:
 * - 0x00: Pseudo-Random bit sequence 9
 * - 0x01: Pattern of alternating bits '11110000'
 * - 0x02: Pattern of alternating bits '10101010'
 * - 0x03: Pseudo-Random bit sequence 15
 * - 0x04: Pattern of All '1' bits
 * - 0x05: Pattern of All '0' bits
 * - 0x06: Pattern of alternating bits '00001111'
 * - 0x07: Pattern of alternating bits '0101'
 */
  uint8_t Packet_Payload;
/**
 * Number of packets to be sent
 */
  uint16_t Number_Of_Packets;
/**
 * PHY to be used by the transmitter.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
} aci_hal_transmitter_test_packets_cp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_transmitter_test_packets_rp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_v2_cp0_s {
/**
 * N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 * Values:
 * - 0x00 ... 0x27
 */
  uint8_t TX_Channel;
/**
 * Length in bytes of payload data in each packet.
 */
  uint8_t Test_Data_Length;
/**
 * Content of the Payload of the test reference packets.  0: PRBS9 sequence
 * '11111111100000111101...' (in transmission order) 1: Repeated '11110000' (in
 * transmission order) sequence 2: Repeated '10101010' (in transmission order)
 * sequence 3: PRBS15 sequence 4: Repeated '11111111' (in transmission order)
 * sequence 5: Repeated '00000000' (in transmission order) sequence 6: Repeated
 * '00001111' (in transmission order) sequence 7: Repeated '01010101' (in
 * transmission order) sequence
 * Values:
 * - 0x00: PRBS9
 * - 0x01: Repeated '11110000'
 * - 0x02: Repeated '10101010'
 * - 0x03: PRBS15
 * - 0x04: Repeated '11111111'
 * - 0x05: Repeated '00000000'
 * - 0x06: Repeated '00001111'
 * - 0x07: Repeated '01010101'
 */
  uint8_t Packet_Payload;
/**
 * Number of packets to be sent.
 */
  uint16_t Number_Of_Packets;
/**
 * PHY to be used by the transmitter.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 * Expected length of the Constant Tone Extension in 8 microseconds units. If 0,
 * no Constant Tone Extension expected.
 * Values:
 * - 0x00
 * - 0x02 ... 0x14
 */
  uint8_t CTE_Length;
/**
 * Type of the Constant Tone Extension in the test reference packets. 0: AoA; 1:
 * AoD with 1 us slots; 2: AoD with 2 us slots.
 * Values:
 * - 0x00: CTE_AOA
 * - 0x01: CTE_AOD_1us
 * - 0x02: CTE_AOD_2us
 */
  uint8_t CTE_Type;
/**
 * The number of Antenna IDs in the pattern.
 * Values:
 * - 0x02 ... 0x4B
 */
  uint8_t Switching_Pattern_Length;
/**
 * List of Antenna IDs in the pattern.
 */
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 9)/sizeof(uint8_t)];
} aci_hal_transmitter_test_packets_v2_cp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_v2_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_transmitter_test_packets_v2_rp0;

typedef PACKED(struct) aci_hal_write_radio_reg_cp0_s {
/**
 *
 */
  uint32_t Start_Address;
/**
 * Length of Data in octets
 */
  uint8_t Num_Bytes;
/**
 *
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_hal_write_radio_reg_cp0;

typedef PACKED(struct) aci_hal_write_radio_reg_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_write_radio_reg_rp0;

typedef PACKED(struct) aci_hal_read_radio_reg_cp0_s {
/**
 *
 */
  uint32_t Start_Address;
/**
 *
 */
  uint8_t Num_Bytes;
} aci_hal_read_radio_reg_cp0;

typedef PACKED(struct) aci_hal_read_radio_reg_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of Data in octets
 */
  uint8_t Data_Length;
/**
 *
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_read_radio_reg_rp0;

typedef PACKED(struct) aci_hal_set_antenna_switch_parameters_cp0_s {
/**
 * ANTENNA_ID pins to be enabled. Each bit in the mask enables the corresponding
 * bit of the ANTENNA_ID signal, which is output on PB[0:6].
 * Flags:
 * - 0x01: ANTENNA_ID_0
 * - 0x02: ANTENNA_ID_1
 * - 0x04: ANTENNA_ID_2
 * - 0x08: ANTENNA_ID_3
 * - 0x10: ANTENNA_ID_4
 * - 0x20: ANTENNA_ID_5
 * - 0x40: ANTENNA_ID_6
 */
  uint8_t Antenna_IDs;
/**
 * This parameter can be set to a value different from zero to left shift the
 * ANTENNA_ID signal by the given number of bits. This number does not affect
 * the pin selected by Antenna_IDs parameter. E.g. to have the ANTENNA_ID signal
 * output on PB[2:4], set Antenna_IDs to enable ANTENNA_ID[2:4] (Antenna_IDs =
 * 0x1C) and Antenna_ID_Shift to 2.
 * Values:
 * - 0 ... 6
 */
  uint8_t Antenna_ID_Shift;
/**
 * The ID of antenna that the controller will select for regular communication.
 * The antenna to be used when sending or receiving the CTE field needs to be
 * specified through the Antenna_IDs parameter of the dedicated HCI commands
 * (i.e. hci_le_set_connectionless_cte_transmit_parameters,
 * hci_le_set_connectionless_iq_sampling_enable,
 * hci_le_set_connection_cte_receive_parameters and
 * hci_le_set_connection_cte_transmit_parameters).
 * Values:
 * - 0x00 ... 0x7F
 */
  uint8_t Default_Antenna_ID;
/**
 * Enable or disable the RF Activity signal, if supported by the device. This
 * signal can be used to enable the antenna switch only when necessary.
 * Values:
 * - 0x00: DISABLED
 * - 0x01: ENABLED
 */
  uint8_t RF_Activity_Enable;
} aci_hal_set_antenna_switch_parameters_cp0;

typedef PACKED(struct) aci_hal_set_antenna_switch_parameters_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_set_antenna_switch_parameters_rp0;

typedef PACKED(struct) aci_hal_peripheral_latency_enable_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Enable (1) or disable (0) the peripheral latency. Default value is Enabled
 * (1).
 * Values:
 * - 0x00: DISABLED
 * - 0x01: ENABLED
 */
  uint8_t Enable;
} aci_hal_peripheral_latency_enable_cp0;

typedef PACKED(struct) aci_hal_peripheral_latency_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_hal_peripheral_latency_enable_rp0;

typedef PACKED(struct) aci_hal_get_evt_fifo_max_level_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Maximum size reached by the FIFO used for critical controller events produced
 * by the ISR (e.g. rx data packets). See isr0_fifo_size parameter field of
 * BLE_STACK_InitTypeDef structure, used by BLE_STACK_Init().
 */
  uint16_t ISR0_FIFO_Max_Level;
/**
 * Maximum size reached by the FIFO used for non-critical controller events
 * produced by the ISR (e.g. advertising or IQ sampling reports). See
 * isr1_fifo_size parameter field of BLE_STACK_InitTypeDef structure, used by
 * BLE_STACK_Init().
 */
  uint16_t ISR1_FIFO_Max_Level;
/**
 * Maximum size reached by the FIFO used for controller and host events produced
 * outside the ISR. See user_fifo_size parameter field of BLE_STACK_InitTypeDef
 * structure, used by BLE_STACK_Init().
 */
  uint16_t User_FIFO_Max_Level;
} aci_hal_get_evt_fifo_max_level_rp0;

typedef PACKED(struct) aci_gap_init_cp0_s {
/**
 * Specify if privacy is enabled or not and which one .
 * Values:
 * - 0x00: Privacy disabled
 * - 0x01: Privacy host enabled
 * - 0x02: Privacy controller enabled
 */
  uint8_t Privacy_Type;
/**
 * Specify which address has to be used as Identity Address. 0x00: The public
 * address is used as identity address 0x01: The static random address is used
 * as identity address
 * Values:
 * - 0x00: Public Address
 * - 0x01: Static Random Address
 */
  uint8_t Identity_Address_Type;
} aci_gap_init_cp0;

typedef PACKED(struct) aci_gap_init_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_init_rp0;

typedef PACKED(struct) aci_gap_set_io_capability_cp0_s {
/**
 * IO capability of the device.
 * Values:
 * - 0x00: GAP_IO_CAP_DISPLAY_ONLY
 * - 0x01: GAP_IO_CAP_DISPLAY_YES_NO
 * - 0x02: GAP_IO_CAP_KEYBOARD_ONLY
 * - 0x03: GAP_IO_CAP_NO_INPUT_NO_OUTPUT
 * - 0x04: GAP_IO_CAP_KEYBOARD_DISPLAY
 */
  uint8_t IO_Capability;
} aci_gap_set_io_capability_cp0;

typedef PACKED(struct) aci_gap_set_io_capability_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_io_capability_rp0;

typedef PACKED(struct) aci_gap_set_security_requirements_cp0_s {
/**
 * Bonding mode. Only if bonding is enabled (0x01), the bonding information is
 * stored in flash
 * Values:
 * - 0x00: NO_BONDING
 * - 0x01: BONDING
 */
  uint8_t Bonding_Mode;
/**
 * MITM mode.
 * Values:
 * - 0x00: MITM_PROTECTION_NOT_REQUIRED
 * - 0x01: MITM_PROTECTION_REQUIRED
 */
  uint8_t MITM_Mode;
/**
 * LE Secure connections support. Secure Connections Only Mode (0x02) is the
 * recommended value. However it is no compatible with old devices not
 * supporting LE Secure Connections. - 0x00: Secure Connections Pairing not
 * supported. - 0x01: Secure Connections Pairing supported but optional. - 0x02:
 * Secure Connections Pairing supported and mandatory (SC Only Mode). This is
 * the recommended value.
 * Values:
 * - 0x00: GAP_SC_NOT_SUPPORTED
 * - 0x01: GAP_SC_OPTIONAL
 * - 0x02: GAP_SC_MANDATORY
 */
  uint8_t SC_Support;
/**
 * Keypress notification support
 * Values:
 * - 0x00: GAP_KEYPRESS_NOT_SUPPORTED
 * - 0x01: GAP_KEYPRESS_SUPPORTED
 */
  uint8_t KeyPress_Notification_Support;
/**
 * Minimum encryption key size to be used during pairing
 * Values:
 * - 7 ... 16
 */
  uint8_t Min_Encryption_Key_Size;
/**
 * Maximum encryption key size to be used during pairing
 * Values:
 * - 7 ... 16
 */
  uint8_t Max_Encryption_Key_Size;
/**
 * This parameter controls how pairing confirmation is managed.
 * Values:
 * - 0x00: GAP_PAIRING_RESP_NONE
 * - 0x01: GAP_PAIRING_RESP_FOR_BONDED_DEVICES
 * - 0x02: GAP_PAIRING_RESP_FOR_ALL
 */
  uint8_t Pairing_Response;
} aci_gap_set_security_requirements_cp0;

typedef PACKED(struct) aci_gap_set_security_requirements_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_security_requirements_rp0;

typedef PACKED(struct) aci_gap_passkey_resp_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Pass key that will be used during the pairing process.  Must be a six-digit
 * decimal number.
 * Values:
 * - 0 ... 999999
 */
  uint32_t Passkey;
} aci_gap_passkey_resp_cp0;

typedef PACKED(struct) aci_gap_passkey_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_passkey_resp_rp0;

typedef PACKED(struct) aci_gap_profile_init_cp0_s {
/**
 * Bitmap of allowed roles. Ignored in stack v3.2 and earlier.
 * Flags:
 * - 0x01: Peripheral
 * - 0x02: Broadcaster
 * - 0x04: Central
 * - 0x08: Observer
 */
  uint8_t Role;
/**
 * Specify if privacy is enabled or not and which one .
 * Values:
 * - 0x00: Privacy disabled
 * - 0x01: Privacy host enabled
 * - 0x02: Privacy controller enabled
 */
  uint8_t Privacy_Type;
} aci_gap_profile_init_cp0;

typedef PACKED(struct) aci_gap_profile_init_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Device Name Characteristic handle
 */
  uint16_t Dev_Name_Char_Handle;
/**
 * Appearance Characteristic handle
 */
  uint16_t Appearance_Char_Handle;
/**
 * Appearance Characteristic handle
 */
  uint16_t Periph_Pref_Conn_Param_Char_Handle;
} aci_gap_profile_init_rp0;

typedef PACKED(struct) aci_gap_set_security_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Indicates the minimum Security Level to be achieved.
 * Values:
 * - 0x01: GAP_SECURITY_LEVEL_1
 * - 0x02: GAP_SECURITY_LEVEL_2
 * - 0x03: GAP_SECURITY_LEVEL_3
 * - 0x04: GAP_SECURITY_LEVEL_4
 */
  uint8_t Security_Level;
/**
 * Valid only for Central role. Ignored if role is Peripheral.  The bit b0
 * indicates whether pairing request has to be sent even if the peer device is
 * bonded.   The bit b1 indicates whether the link has to be re-encrypted after
 * the key exchange.
 * Flags:
 * - 0x01: FORCE_PAIRING
 * - 0x02: ENCRYPT_AFTER_KEY_EXCHANGE
 */
  uint8_t Force_Pairing;
} aci_gap_set_security_cp0;

typedef PACKED(struct) aci_gap_set_security_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_security_rp0;

typedef PACKED(struct) aci_gap_get_security_level_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} aci_gap_get_security_level_cp0;

typedef PACKED(struct) aci_gap_get_security_level_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Security mode.
 * Values:
 * - 0x01: Security Mode 1
 * - 0x02: Security Mode 2
 */
  uint8_t Security_Mode;
/**
 * Security Level.
 * Values:
 * - 0x01: Security Level 1
 * - 0x02: Security Level 2
 * - 0x03: Security Level 3
 * - 0x04: Security Level 4
 */
  uint8_t Security_Level;
} aci_gap_get_security_level_rp0;

typedef PACKED(struct) aci_gap_set_le_event_mask_cp0_s {
/**
 * LE event mask. Default: 0x000000000000001F.
 * Flags:
 * - 0x0000000000000000: No LE events specified
 * - 0x0000000000000001: LE Connection Complete Event
 * - 0x0000000000000002: LE Advertising Report Event
 * - 0x0000000000000004: LE Connection Update Complete Event
 * - 0x0000000000000008: LE Read Remote Used Features Complete Event
 * - 0x0000000000000010: LE Long Term Key Request Event
 * - 0x0000000000000020: LE Remote Connection Parameter Request Event
 * - 0x0000000000000040: LE Data Length Change Event
 * - 0x0000000000000080: LE Read Local P-256 Public Key Complete Event
 * - 0x0000000000000100: LE Generate DHKey Complete Event
 * - 0x0000000000000200: LE Enhanced Connection Complete Event
 * - 0x0000000000000400: LE Directed Advertising Report Event
 * - 0x0000000000000800: LE PHY Update Complete event
 * - 0x0000000000001000: LE Extended Advertising Report event
 * - 0x0000000000002000: LE Periodic Advertising Sync Established event
 * - 0x0000000000004000: LE Periodic Advertising Report event
 * - 0x0000000000008000: LE Periodic Advertising Sync Lost event
 * - 0x0000000000010000: LE Scan Timeout event
 * - 0x0000000000020000: LE Advertising Set Terminated event
 * - 0x0000000000040000: LE Scan Request Received event
 * - 0x0000000000080000: LE Channel Selection Algorithm event
 * - 0x0000000000100000: LE Connectionless IQ Report event
 * - 0x0000000000200000: LE Connection IQ Report event
 * - 0x0000000000400000: LE CTE Request Failed event
 * - 0x0000000000800000: LE Periodic Advertising Sync Transfer Received event
 * - 0x0000000001000000: LE CIS Established event
 * - 0x0000000002000000: LE CIS Request event
 * - 0x0000000004000000: LE Create BIG Complete event
 * - 0x0000000008000000: LE Terminate BIG Complete event
 * - 0x0000000010000000: LE BIG Sync Established event
 * - 0x0000000020000000: LE BIG Sync Lost event
 * - 0x0000000040000000: LE Request Peer SCA Complete event
 * - 0x0000000080000000: LE Path Loss Threshold event
 * - 0x0000000100000000: LE Transmit Power Reporting event
 * - 0x0000000200000000: LE BIGInfo Advertising Report event
 * - 0x0000000400000000: LE Subrate Change event
 * - 0x0000000800000000: LE Periodic Advertising Sync Established event [v2]
 * - 0x0000001000000000: LE Periodic Advertising Report event [v2]
 * - 0x0000002000000000: LE Periodic Advertising Sync Transfer Received event [v2]
 * - 0x0000004000000000: LE Periodic Advertising Subevent Data Request event
 * - 0x0000008000000000: LE Periodic Advertising Response Report event
 * - 0x0000010000000000: LE Enhanced Connection Complete event [v2]
 */
  uint8_t LE_Event_Mask[8];
} aci_gap_set_le_event_mask_cp0;

typedef PACKED(struct) aci_gap_set_le_event_mask_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_le_event_mask_rp0;

typedef PACKED(struct) aci_gap_terminate_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The reason for ending the connection.
 * Values:
 * - 0x05: Authentication Failure
 * - 0x13: Remote User Terminated Connection
 * - 0x14: Remote Device Terminated Connection due to Low Resources
 * - 0x15: Remote Device Terminated Connection due to Power Off
 * - 0x1A: Unsupported Remote Feature
 * - 0x3B: Unacceptable Connection Parameters
 */
  uint8_t Reason;
} aci_gap_terminate_cp0;

typedef PACKED(struct) aci_gap_terminate_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_terminate_rp0;

typedef PACKED(struct) aci_gap_clear_security_db_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_clear_security_db_rp0;

typedef PACKED(struct) aci_gap_pairing_resp_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x00: REJECT
 * - 0x01: ACCEPT
 */
  uint8_t Accept;
} aci_gap_pairing_resp_cp0;

typedef PACKED(struct) aci_gap_pairing_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_pairing_resp_rp0;

typedef PACKED(struct) aci_gap_create_connection_cp0_s {
/**
 * PHYs that will be used for initiating the connection.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t Initiating_PHY;
/**
 * The Peer_Address_Type parameter indicates the type of address used in the
 * connectable advertisement sent by the peer. 0: Public Device Address or
 * Public Identity Address 1: Random Device Address or Random (static) Identity
 * Address
 * Values:
 * - 0x00: Public Address
 * - 0x01: Random Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
} aci_gap_create_connection_cp0;

typedef PACKED(struct) aci_gap_create_connection_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_create_connection_rp0;

typedef PACKED(struct) aci_gap_terminate_proc_cp0_s {
/**
 * Code identifying the procedure.
 * Values:
 * - 0x00: GAP_LIMITED_DISCOVERY_PROC
 * - 0x01: GAP_GENERAL_DISCOVERY_PROC
 * - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 * - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 * - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 * - 0x05: GAP_OBSERVATION_PROC
 * - 0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC
 * - 0x07: GAP_NAME_DISCOVERY_PROC
 */
  uint8_t Procedure_Code;
} aci_gap_terminate_proc_cp0;

typedef PACKED(struct) aci_gap_terminate_proc_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_terminate_proc_rp0;

typedef PACKED(struct) aci_gap_start_connection_update_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * The minimum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Min_CE_Length;
/**
 * The maximum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Max_CE_Length;
} aci_gap_start_connection_update_cp0;

typedef PACKED(struct) aci_gap_start_connection_update_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_start_connection_update_rp0;

typedef PACKED(struct) aci_gap_resolve_private_addr_cp0_s {
/**
 * Address to be resolved
 */
  uint8_t Address[6];
} aci_gap_resolve_private_addr_cp0;

typedef PACKED(struct) aci_gap_resolve_private_addr_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The public or static random address of the peer device, distributed during
 * pairing phase.
 */
  uint8_t Actual_Address[6];
} aci_gap_resolve_private_addr_rp0;

typedef PACKED(struct) aci_gap_get_bonded_devices_cp0_s {
/**
 * Index of the first record to be returned.
 */
  uint8_t Offset;
/**
 * Used to specify the maximum number of devices to be returned.
 */
  uint8_t Max_Num_Of_Addresses;
} aci_gap_get_bonded_devices_cp0;

typedef PACKED(struct) aci_gap_get_bonded_devices_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The number of bonded devices returned by this command.
 */
  uint8_t Num_of_Addresses;
/**
 * See @ref Bonded_Device_Entry_t
 */
  packed_Bonded_Device_Entry_t Bonded_Device_Entry[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Bonded_Device_Entry_t)];
} aci_gap_get_bonded_devices_rp0;

typedef PACKED(struct) aci_gap_is_device_bonded_cp0_s {
/**
 * Address type.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 */
  uint8_t Peer_Address_Type;
/**
 * Address used by the peer device while advertising
 */
  uint8_t Peer_Address[6];
} aci_gap_is_device_bonded_cp0;

typedef PACKED(struct) aci_gap_is_device_bonded_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_is_device_bonded_rp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_confirm_yesno_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * 0 : The Numeric Values showed on both local and peer device are different! 1
 * : The Numeric Values showed on both local and peer device are equal!
 * Values:
 * - 0x00: No
 * - 0x01: YES
 */
  uint8_t Confirm_Yes_No;
} aci_gap_numeric_comparison_value_confirm_yesno_cp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_confirm_yesno_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_numeric_comparison_value_confirm_yesno_rp0;

typedef PACKED(struct) aci_gap_passkey_input_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Passkey input type detected
 * Values:
 * - 0x00: Passkey entry started
 * - 0x01: Passkey digit entered
 * - 0x02: Passkey digit erased
 * - 0x03: Passkey cleared
 * - 0x04: Passkey entry completed
 */
  uint8_t Input_Type;
} aci_gap_passkey_input_cp0;

typedef PACKED(struct) aci_gap_passkey_input_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_passkey_input_rp0;

typedef PACKED(struct) aci_gap_get_oob_data_cp0_s {
/**
 * OOB Data type. - 0x00: Legacy Pairing (LP) v.4.1 TK (Temporary Key) - 0x01:
 * Secure Connections (SC) v.4.2 Random value r used for generation of Confirm
 * value - 0x02: Secure Connections (SC) v.4.2 Confirm value C generated through
 * AES-CMAC-128 based cryptographic function: C=f4(PKx, PKx, r, 0)
 * Values:
 * - 0x00: SM_TK
 * - 0x01: SM_RANDOM_VALUE
 * - 0x02: SM_CONFIRM_VALUE
 */
  uint8_t OOB_Data_Type;
} aci_gap_get_oob_data_cp0;

typedef PACKED(struct) aci_gap_get_oob_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Identity address type.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Address_Type;
/**
 * Public or Random (static) address of this device
 */
  uint8_t Address[6];
/**
 * OOB Data type. - 0x00: Legacy Pairing (LP) v.4.1 TK (Temporary Key) - 0x01:
 * Secure Connections (SC) v.4.2 Random value r used for generation of Confirm
 * value - 0x02: Secure Connections (SC) v.4.2 Confirm value C generated through
 * AES-CMAC-128 based cryptographic function: C=f4(PKx, PKx, r, 0)
 * Values:
 * - 0x00: SM_TK
 * - 0x01: SM_RANDOM_VALUE
 * - 0x02: SM_CONFIRM_VALUE
 */
  uint8_t OOB_Data_Type;
/**
 * Length of OOB Data carried by next data field
 */
  uint8_t OOB_Data_Len;
/**
 * OOB Data to be exported via OOB.
 */
  uint8_t OOB_Data[16];
} aci_gap_get_oob_data_rp0;

typedef PACKED(struct) aci_gap_set_oob_data_cp0_s {
/**
 * If Device_Type is 0x00 (Local Device), it sets the local OOB authentication
 * data. If Device_Type is 0x01 (Remote Device), the command sets the OOB data
 * for the specified remote device (only one device at a time is supported).
 * Values:
 * - 0x00: Local device
 * - 0x01: Remote device
 */
  uint8_t Device_Type;
/**
 * Identity address type of the remote device. Ignored if Device_Type is 0.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Address_Type;
/**
 * Public or Random (static) address of the peer device. Ignored if Device_Type
 * is 0.
 */
  uint8_t Address[6];
/**
 * OOB Data type. - 0x00: Legacy Pairing (LP) v.4.1 TK (Temporary Key) - 0x01:
 * Secure Connections (SC) v.4.2 Random value r used for generation of Confirm
 * value - 0x02: Secure Connections (SC) v.4.2 Confirm value C generated through
 * AES-CMAC-128 based cryptographic function: C=f4(PKx, PKx, r, 0)
 * Values:
 * - 0x00: SM_TK
 * - 0x01: SM_RANDOM_VALUE
 * - 0x02: SM_CONFIRM_VALUE
 */
  uint8_t OOB_Data_Type;
/**
 * Length of OOB Data carried by next data field. It may be set to 0x00 to
 * trigger the automatic generation of local Random and Confirm values for LE
 * Secure Connections pairing.
 * Values:
 * - 0x00 ... 0x10
 */
  uint8_t OOB_Data_Len;
/**
 * OOB Data to be exported via OOB.
 */
  uint8_t OOB_Data[16];
} aci_gap_set_oob_data_cp0;

typedef PACKED(struct) aci_gap_set_oob_data_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_oob_data_rp0;

typedef PACKED(struct) aci_gap_remove_bonded_device_cp0_s {
/**
 * Identity address type.
 * Values:
 * - 0x00: Public Identity Address
 * - 0x01: Random (static) Identity Address
 */
  uint8_t Peer_Identity_Address_Type;
/**
 * Public or Random (static) Identity address of the peer device
 */
  uint8_t Peer_Identity_Address[6];
} aci_gap_remove_bonded_device_cp0;

typedef PACKED(struct) aci_gap_remove_bonded_device_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_remove_bonded_device_rp0;

typedef PACKED(struct) aci_gap_set_advertising_configuration_cp0_s {
/**
 * Used to identify an advertising set. This parameter is only meaningful if
 * Extended Advertising Feature is enabled.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * Specifies the discoverable mode of the device.
 * Values:
 * - 0: Not Discoverable
 * - 1: Limited Discoverable
 * - 2: General Discoverable
 * - 3: Broadcast
 */
  uint8_t Discoverable_Mode;
/**
 * The Advertising_Event_Properties parameter describes the type of advertising
 * event that is being configured and its basic properties according to V5.1,
 * Vol 2, Part E, section 7.8.53.
 * Flags:
 * - 0x0001: Connectable
 * - 0x0002: Scannable
 * - 0x0004: Directed
 * - 0x0008: High Duty Cycle Directed Connectable
 * - 0x0010: Legacy
 * - 0x0020: Anonymous
 * - 0x0040: Include TX Power
 */
  uint16_t Advertising_Event_Properties;
/**
 * Minimum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 msec.
 * Values:
 * - 0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms) 
 */
  uint32_t Primary_Advertising_Interval_Min;
/**
 * Maximum advertising interval for undirected and low duty cycle directed
 * advertising. Time = N * 0.625 msec.
 * Values:
 * - 0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms) 
 */
  uint32_t Primary_Advertising_Interval_Max;
/**
 * It is a bit field that indicates the advertising channels that shall be used
 * when transmitting advertising packets.
 * Flags:
 * - 0x01: CH_37
 * - 0x02: CH_38
 * - 0x04: CH_39
 */
  uint8_t Primary_Advertising_Channel_Map;
/**
 * The peer address type.
 * Values:
 * - 0x00: Public
 * - 0x01: Random
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Advertising Filter Policy. If Directed advertising is selected, the
 * Peer_Address_Type and Peer_Address shall be valid and the
 * Advertising_Filter_Policy parameter shall be ignored.  0x00 Process scan and
 * connection requests from all devices (i.e., the Filter Accept List is not in
 * use) 0x01 Process connection requests from all devices and scan requests only
 * from devices that are in the Filter Accept List 0x02 Process scan requests
 * from all devices and connection requests only from devices that are in the
 * Filter Accept List. 0x03 Process scan and connection requests only from
 * devices in the Filter Accept List. All other values Reserved for future use
 * Values:
 * - 0x00: Scan and Connection requests from any
 * - 0x01: Connection requests from any, scan requests from Filter Accept List only
 * - 0x02: Scan requests from any, connection requests from Filter Accept List only
 * - 0x03: Scan and connection requests from Filter Accept List only
 */
  uint8_t Advertising_Filter_Policy;
/**
 * The Advertising_Tx_Power parameter indicates the maximum power level at which
 * the advertising packets are to be transmitted on the advertising channels.
 * The Controller shall choose a power level lower than or equal to the one
 * specified by the Host. (Units: dBm). This parameter is ignored if extended
 * advertising is not enabled.
 * Values:
 * - -127 ... 126
 * - 127: No preference
 */
  int8_t Advertising_Tx_Power;
/**
 * The Primary_Advertising_PHY parameter indicates the PHY on which the
 * advertising packets are transmitted on the primary advertising channel. If
 * legacy advertising PDUs are being used, the Primary_Advertising_PHY shall
 * indicate the LE 1M PHY. This parameter is ignored if extended advertising is
 * not enabled.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t Primary_Advertising_PHY;
/**
 * The Secondary_Advertising_Max_Skip parameter is the maximum number of
 * advertising events that can be skipped before the AUX_ADV_IND can be sent.
 * This parameter is ignored if extended advertising is not enabled. 0x00
 * AUX_ADV_IND shall be sent prior to the next advertising event 0x01-0xFF
 * Maximum advertising events the Controller can skip before sending the
 * AUX_ADV_IND packets on the secondary advertising channel
 */
  uint8_t Secondary_Advertising_Max_Skip;
/**
 * The Secondary_Advertising_PHY parameter indicates the PHY on which the
 * advertising packets are be transmitted on the secondary advertising channel.
 * This parameter is ignored if extended advertising is not enabled.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t Secondary_Advertising_PHY;
/**
 * The Advertising_SID parameter specifies the value to be transmitted in the
 * Advertising SID subfield of the ADI field of the Extended Header of those
 * advertising channel PDUs that have an ADI field. If the advertising set only
 * uses PDUs that do not contain an ADI field, Advertising_SID is ignored. This
 * parameter is ignored if extended advertising is not enabled.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t Advertising_SID;
/**
 * The Scan_Request_Notification_Enable parameter indicates whether the
 * Controller shall send notifications upon the receipt of a scan request PDU
 * that is in response to an advertisement from the specified advertising set
 * that contains its device address and is from a scanner that is allowed by the
 * advertising filter policy. This parameter is ignored if extended advertising
 * is not enabled.
 * Values:
 * - 0x00: Scan request notifications disabled
 * - 0x01: Scan request notifications enabled
 */
  uint8_t Scan_Request_Notification_Enable;
} aci_gap_set_advertising_configuration_cp0;

typedef PACKED(struct) aci_gap_set_advertising_configuration_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_advertising_configuration_rp0;

typedef PACKED(struct) aci_gap_set_advertising_enable_cp0_s {
/**
 * It allows to enable or disable one or more advertising sets using the
 * advertising sets identified by the Advertising_Handle[i] parameter.
 * Values:
 * - 0x00: Disable
 * - 0x01: Enable
 */
  uint8_t Enable;
/**
 * The Number_of_Sets parameter is the number of advertising sets contained in
 * the parameter arrays. 0x00: Disable all advertising sets 0x01 to 0x3F: Number
 * of advertising sets to enable or disable. Ignored if extended advertising
 * feature is disabled through modular configuration
 * (CONTROLLER_EXT_ADV_SCAN_ENABLED=0).
 * Values:
 * - 0x00: Disable all sets
 * - 0x01 ... 0x3F
 */
  uint8_t Number_of_Sets;
/**
 * See @ref Advertising_Set_Parameters_t
 */
  packed_Advertising_Set_Parameters_t Advertising_Set_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Advertising_Set_Parameters_t)];
} aci_gap_set_advertising_enable_cp0;

typedef PACKED(struct) aci_gap_set_advertising_enable_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_advertising_enable_rp0;

typedef PACKED(struct) aci_gap_set_advertising_data_nwk_cp0_s {
/**
 * Used to identify an advertising set. This parameter is only meaningful if
 * Extended Advertising Feature is enabled.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * The Host may set the advertising data in one or more operations using this
 * parameter. 0x00: Intermediate fragment of fragmented extended advertising
 * data 0x01: First fragment of fragmented extended advertising data 0x02: Last
 * fragment of fragmented extended advertising data 0x03: Complete extended
 * advertising data 0x04: Unchanged data (just update the Advertising DID) All
 * other values: Reserved for future use
 * Values:
 * - 0x00: Intermediate fragment
 * - 0x01: First fragment
 * - 0x02: Last fragment
 * - 0x03: Complete data
 * - 0x04: Unchanged data
 */
  uint8_t Operation;
/**
 * Length of advertising data. For legacy PDUs which supports advertising data
 * maximum value is 31 octets.
 * Values:
 * - 0 ... 251
 */
  uint8_t Advertising_Data_Length;
/**
 * Advertising data, that must be properly formatted (see Core v5.1 Vol 3, part
 * C, chapter 11).
 */
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_advertising_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_advertising_data_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_advertising_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_scan_response_data_nwk_cp0_s {
/**
 * Used to identify an advertising set. This parameter is only meaningful if
 * Extended Advertising Feature is enabled.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t Advertising_Handle;
/**
 * The Host may set the scan response data in one or more operations using the
 * Operation parameter in the command. 0x00: Intermediate fragment of fragmented
 * scan response data 0x01: First fragment of fragmented scan response data
 * 0x02: Last fragment of fragmented scan response data 0x03: Complete scan
 * response data All other values: Reserved for future use
 * Values:
 * - 0x00: Intermediate fragment
 * - 0x01: First fragment
 * - 0x02: Last fragment
 * - 0x03: Complete data
 */
  uint8_t Operation;
/**
 * Length of scan response data. If the advertising set uses scannable legacy
 * advertising PDUs maximum length is 31 octets.
 * Values:
 * - 0 ... 251
 */
  uint8_t Scan_Response_Data_Length;
/**
 * Scan response data, that must be properly formatted (see Core v5.1 Vol 3,
 * part C, chapter 11).
 */
  uint8_t Scan_Response_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_scan_response_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_scan_response_data_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_scan_response_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_scan_configuration_cp0_s {
/**
 * The Filter_Duplicates parameter controls whether the Link Layer should filter
 * out duplicate advertising reports (filtering duplicates enabled) to the Host
 * or if the Link Layer should generate advertising reports for each packet
 * received (filtering duplicates disabled). See [Vol 6] Part B, Section
 * 4.4.3.5.
 * Values:
 * - 0x00: Duplicate filtering disabled
 * - 0x01: Duplicate filtering enabled
 * - 0x02: Duplicate filtering enabled, reset for each scan period
 */
  uint8_t Filter_Duplicates;
/**
 * 0x00 Accept all advertisement packets. Directed advertising packets which are
 * not addressed for this device shall be ignored. 0x01 Ignore advertisement
 * packets from devices not in the Filter Accept List Only. Directed advertising
 * packets which are not addressed for this device shall be ignored 0x02 Accept
 * all undirected advertisement packets. Directed advertisement packets where
 * initiator address is a RPA and  Directed advertisement packets addressed to
 * this device shall be accepted. 0x03 Accept all undirected advertisement
 * packets from devices that are in the Filter Accept List.Directed
 * advertisement packets where initiator address is RPA and Directed
 * advertisement packets addressed to this device shall be accepted.
 * Values:
 * - 0x00: Accept All
 * - 0x01: Filter Accept List Only
 * - 0x02: Accept All (use resolving list)
 * - 0x03: Filter Accept List Only (use resolving list)
 */
  uint8_t Scanning_Filter_Policy;
/**
 * PHY that is going to be configured. Only one bit can be set.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t Scanning_PHY;
/**
 * The Scan_Type parameter specifies the type of scan to perform. 0: Passive
 * Scanning. No scan request PDUs shall be sent. 1: Active Scanning. Scan
 * request PDUs may be sent.
 * Values:
 * - 0x00: Passive Scanning
 * - 0x01: Active Scanning
 */
  uint8_t Scan_Type;
/**
 * Time interval from when the Controller started its last scan until it begins
 * the subsequent scan on the primary advertising physical channel.  Time = N *
 * 0.625 ms
 * Values:
 * - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
 */
  uint16_t Scan_Interval;
/**
 * Time interval from when the Controller started its last scan until it begins
 * the subsequent scan on the primary advertising physical channel. Time = N *
 * 0.625 msec.
 * Values:
 * - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
 */
  uint16_t Scan_Window;
} aci_gap_set_scan_configuration_cp0;

typedef PACKED(struct) aci_gap_set_scan_configuration_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_scan_configuration_rp0;

typedef PACKED(struct) aci_gap_set_connection_configuration_cp0_s {
/**
 * PHY that is going to be configured. Only one bit can be set.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x02: LE_2M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t Initiating_PHY;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * The minimum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Min_CE_Length;
/**
 * The maximum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Max_CE_Length;
} aci_gap_set_connection_configuration_cp0;

typedef PACKED(struct) aci_gap_set_connection_configuration_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_set_connection_configuration_rp0;

typedef PACKED(struct) aci_gap_start_procedure_cp0_s {
/**
 * Procedure to be started.
 * Values:
 * - 0x00: GAP_LIMITED_DISCOVERY_PROC
 * - 0x01: GAP_GENERAL_DISCOVERY_PROC
 * - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 * - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 * - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 * - 0x05: GAP_OBSERVATION_PROC
 */
  uint8_t Procedure_Code;
/**
 * PHYs that will be used for Scanning or Initiating .
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t PHYs;
/**
 * Ignored. Reserved for future use.
 */
  uint16_t Duration;
/**
 * Ignored. Reserved for future use.
 */
  uint16_t Period;
} aci_gap_start_procedure_cp0;

typedef PACKED(struct) aci_gap_start_procedure_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_start_procedure_rp0;

typedef PACKED(struct) aci_gap_discover_name_cp0_s {
/**
 * PHYs that will be used for initiating the connection.
 * Flags:
 * - 0x01: LE_1M_PHY_BIT
 * - 0x04: LE_CODED_PHY_BIT
 */
  uint8_t PHYs;
/**
 * The Peer_Address_Type parameter indicates the type of address used in the
 * connectable advertisement sent by the peer. 0: Public Device Address or
 * Public Identity Address 1: Random Device Address or Random (static) Identity
 * Address
 * Values:
 * - 0x00: Public Address
 * - 0x01: Random Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
} aci_gap_discover_name_cp0;

typedef PACKED(struct) aci_gap_discover_name_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_discover_name_rp0;

typedef PACKED(struct) aci_gap_add_devices_to_filter_accept_and_resolving_list_cp0_s {
/**
 * Select in which list the device addresses will be added: Filter Accept List,
 * resolving list or both.
 * Flags:
 * - 0x01: Filter Accept List
 * - 0x02: Resolving List
 */
  uint8_t Lists;
/**
 * Clear the selected lists before adding the device addresses.
 * Values:
 * - 0x00: Do not clear
 * - 0x01: Clear before adding
 */
  uint8_t Clear_Lists;
/**
 * Number of devices that have to be added to the Filter Accept List.
 * Values:
 * - 0x00 ... 0xFF
 */
  uint8_t Num_of_List_Entries;
/**
 * See @ref List_Entry_t
 */
  packed_List_Entry_t List_Entry[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_List_Entry_t)];
} aci_gap_add_devices_to_filter_accept_and_resolving_list_cp0;

typedef PACKED(struct) aci_gap_add_devices_to_filter_accept_and_resolving_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_add_devices_to_filter_accept_and_resolving_list_rp0;

typedef PACKED(struct) aci_gap_configure_filter_accept_and_resolving_list_cp0_s {
/**
 * Select in which list the device addresses will be added: Filter Accept List,
 * resolving list or both.
 * Flags:
 * - 0x01: Filter Accept List
 * - 0x02: Resolving List
 */
  uint8_t Lists;
} aci_gap_configure_filter_accept_and_resolving_list_cp0;

typedef PACKED(struct) aci_gap_configure_filter_accept_and_resolving_list_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_configure_filter_accept_and_resolving_list_rp0;

typedef PACKED(struct) aci_gap_remove_advertising_set_cp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 */
  uint8_t Advertising_Handle;
} aci_gap_remove_advertising_set_cp0;

typedef PACKED(struct) aci_gap_remove_advertising_set_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_remove_advertising_set_rp0;

typedef PACKED(struct) aci_gap_clear_advertising_sets_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_clear_advertising_sets_rp0;

typedef PACKED(struct) aci_gap_create_periodic_advertising_connection_cp0_s {
/**
 * Advertising_Handle identifying the periodic advertising train.
 * Values:
 * - 0x00 ... 0xEF
 * - 0xFF: Not specified
 */
  uint8_t Advertising_Handle;
/**
 * Subevent where the connection request is to be sent.
 * Values:
 * - 0x00 ... 0x7F
 * - 0xFF: Not specified
 */
  uint8_t Subevent;
/**
 * The Initiator_Filter_Policy parameter is used to determine whether the Filter
 * Accept List is used. If the Filter Accept List is not used, the
 * Peer_Address_Type and the Peer_Address parameters specify the address type
 * and address of the device to connect to.  0x00 - Filter Accept List is not
 * used to determine which device to connect to. Peer_Address_Type and
 * Peer_Address shall be used. 0x01 - Filter Accept List is used to determine
 * which device to connect to. Peer_Address_Type and Peer_Address shall be
 * ignored.
 * Values:
 * - 0x00: FILTER_ACCEPT_LIST_NOT_USED
 * - 0x01: FILTER_ACCEPT_LIST_USED
 */
  uint8_t Initiator_Filter_Policy;
/**
 * The Own_Address_Type parameter indicates the type of address being used in
 * the connection request packets.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 * - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from the most recent successful
LE_Set_Random_Address Command.
 */
  uint8_t Own_Address_Type;
/**
 * The Peer_Address_Type parameter indicates the type of address used in the
 * connectable advertisement sent by the peer. 0x00: Public Device Address or
 * Public Identity Address 0x01: Random Device Address or Random (static)
 * Identity Address
 * Values:
 * - 0x00: Public Address
 * - 0x01: Random Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Minimum value for the connection interval. This shall be less than or equal
 * to Connection_Interval_Max. Time = N x 1.25 ms.
 * Values:
 * - 0x0006 ... 0x0C80
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection interval. This shall be greater than or
 * equal to Connection_Interval_Min.  Time = N x 1.25 ms
 * Values:
 * - 0x0006 ... 0x0C80
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Supervision timeout for the LE Link.  Time = N x 10 ms
 * Values:
 * - 0x000A ... 0x0C80
 */
  uint16_t Supervision_Timeout;
/**
 * The minimum length of connection event recommended for this LE connection.
 */
  uint16_t Min_CE_Length;
/**
 * The maximum length of connection event recommended for this LE connection.
 */
  uint16_t Max_CE_Length;
} aci_gap_create_periodic_advertising_connection_cp0;

typedef PACKED(struct) aci_gap_create_periodic_advertising_connection_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gap_create_periodic_advertising_connection_rp0;

typedef PACKED(struct) aci_gap_encrypt_adv_data_nwk_cp0_s {
/**
 *
 */
  uint8_t Session_Key[16];
/**
 *
 */
  uint8_t IV[8];
/**
 * Length of Data.
 */
  uint8_t Data_Length;
/**
 * Data to be encrypted.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 25)/sizeof(uint8_t)];
} aci_gap_encrypt_adv_data_nwk_cp0;

typedef PACKED(struct) aci_gap_encrypt_adv_data_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of Encrypted_Data.
 */
  uint8_t Encrypted_Data_Length;
/**
 * Encrypted data, including Randomizer (5 bytes) and MIC (4 bytes).
 */
  uint8_t Encrypted_Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_gap_encrypt_adv_data_nwk_rp0;

typedef PACKED(struct) aci_gap_decrypt_adv_data_nwk_cp0_s {
/**
 *
 */
  uint8_t Session_Key[16];
/**
 *
 */
  uint8_t IV[8];
/**
 * Length of Encrypted_Data.
 */
  uint8_t Encrypted_Data_Length;
/**
 * Encrypted Data, containing Randomizer and MIC.
 */
  uint8_t Encrypted_Data[(HCI_MAX_PAYLOAD_SIZE - 25)/sizeof(uint8_t)];
} aci_gap_decrypt_adv_data_nwk_cp0;

typedef PACKED(struct) aci_gap_decrypt_adv_data_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of Decrypted_Data.
 */
  uint8_t Decrypted_Data_Length;
/**
 * Decrypted data, without Randomizer and MIC.
 */
  uint8_t Decrypted_Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_gap_decrypt_adv_data_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_profile_init_cp0_s {
/**
 * This is a bit field indicating if a characteristic in the GATT service shall
 * be added or not. bit 0: if set, the Service Changed Characteristic will be
 * added to the GATT Service. Service Changed characteristic is required if
 * service definitions may be added, changed, or removed. Otherwise it is
 * optional.
 * Flags:
 * - 0x01: SERVICE_CHANGED_CHAR_BIT
 */
  uint8_t Characteristics;
} aci_gatt_srv_profile_init_cp0;

typedef PACKED(struct) aci_gatt_srv_profile_init_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle of the Service Changed Characteristic. Characteristic value is at
 * following handle.
 */
  uint16_t Service_Changed_Handle;
} aci_gatt_srv_profile_init_rp0;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_cp0_s {
/**
 * UUID type.
 * Values:
 * - 0x01: 16-bit UUID
 * - 0x02: 128-bit UUID
 */
  uint8_t Service_UUID_Type;
/**
 * See @ref Service_UUID_t
 */
  packed_Service_UUID_t Service_UUID;
} aci_gatt_srv_add_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_cp1_s {
/**
 * Service type.
 * Values:
 * - 0x01: Primary Service
 * - 0x02: Secondary Service
 */
  uint8_t Service_Type;
/**
 * Number of handles reserved for the service. If 0, no handles are served and
 * when the next service is added to the GATT database, the first available
 * handle is assigned to that service (this means that no more attributes can be
 * assigned to the previously created service).
 */
  uint8_t Max_Attribute_Records;
} aci_gatt_srv_add_service_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle of the Service. When this service is added, a handle is allocated by
 * the server for this service.  Server also allocates a range of handles for
 * this service from serviceHandle to <serviceHandle + max_attr_records - 1>
 */
  uint16_t Service_Handle;
} aci_gatt_srv_add_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_include_service_nwk_cp0_s {
/**
 * Handle of the Service to which another service has to be included.
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Service_Handle;
/**
 * Attribute Handle of the Service which has to be included in service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Included_Service_Handle;
} aci_gatt_srv_include_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_include_service_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle of the include declaration
 */
  uint16_t Include_Handle;
} aci_gatt_srv_include_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_cp0_s {
/**
 * Handle of the Service to which the characteristic will be added.
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Service_Handle;
/**
 * UUID type.
 * Values:
 * - 0x01: 16-bit UUID
 * - 0x02: 128-bit UUID
 */
  uint8_t Char_UUID_Type;
/**
 * See @ref Char_UUID_t
 */
  packed_Char_UUID_t Char_UUID;
} aci_gatt_srv_add_char_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_cp1_s {
/**
 * Maximum length of the characteristic value.
 * Values:
 * - 0 ... 512
 */
  uint16_t Char_Value_Length;
/**
 * Characteristic Properties (Volume 3, Part G, section 3.3.1.1 of Bluetooth
 * Specification 4.1)
 * Flags:
 * - 0x00: CHAR_PROP_NONE
 * - 0x01: CHAR_PROP_BROADCAST (Broadcast)
 * - 0x02: CHAR_PROP_READ (Read)
 * - 0x04: CHAR_PROP_WRITE_WITHOUT_RESP (Write w/o resp)
 * - 0x08: CHAR_PROP_WRITE (Write)
 * - 0x10: CHAR_PROP_NOTIFY (Notify)
 * - 0x20: CHAR_PROP_INDICATE (Indicate)
 * - 0x40: CHAR_PROP_SIGNED_WRITE (Authenticated Signed Writes)
 * - 0x80: CHAR_PROP_EXT (Extended Properties)
 */
  uint8_t Char_Properties;
/**
 * Security permission flags.
 * Flags:
 * - 0x00
 * - 0x01: AUTHEN_READ (Need authentication to read)
 * - 0x04: ENCRY_READ (Need encryption to read)
 * - 0x08: AUTHEN_WRITE (need authentication to write)
 * - 0x20: ENCRY_WRITE (need encryption to write)
 */
  uint8_t Security_Permissions;
/**
 * GATT event mask. - GATT_NOTIFY_ATTRIBUTE_WRITE:
 * aci_gatt_srv_attribute_modified_event is generated when characteristic value
 * is modified. - GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP:
 * aci_gatt_srv_authorize_nwk_event is generated when a write operation is
 * received on the characteristic value. -
 * GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP: aci_gatt_srv_authorize_nwk_event
 * is generated when a read request is received on the characteristic value.
 * Flags:
 * - 0x00: GATT_DONT_NOTIFY_EVENTS
 * - 0x01: GATT_NOTIFY_ATTRIBUTE_WRITE
 * - 0x02: GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP
 * - 0x04: GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP
 */
  uint8_t GATT_Evt_Mask;
/**
 * Minimum encryption key size required to read the characteristic.
 * Values:
 * - 0x07 ... 0x10
 */
  uint8_t Enc_Key_Size;
/**
 * Specify if the characteristic value has a fixed length or a variable length.
 * Values:
 * - 0x00: Fixed length
 * - 0x01: Variable length
 */
  uint8_t Is_Variable;
} aci_gatt_srv_add_char_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle of the Characteristic that has been added.  It is the handle of the
 * characteristic declaration.  The attribute that holds the characteristic
 * value is allocated at the next handle,  followed by the Client Characteristic
 * Configuration descriptor if the characteristic  has CHAR_PROP_NOTIFY or
 * CHAR_PROP_INDICATE properties.
 */
  uint16_t Char_Handle;
} aci_gatt_srv_add_char_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp0_s {
/**
 * Handle of the characteristic to which description has to be added
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Char_Handle;
/**
 * UUID type.
 * Values:
 * - 0x01: 16-bit UUID
 * - 0x02: 128-bit UUID
 */
  uint8_t Char_Desc_Uuid_Type;
/**
 * See @ref Char_Desc_Uuid_t
 */
  packed_Char_Desc_Uuid_t Char_Desc_Uuid;
} aci_gatt_srv_add_char_desc_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp1_s {
/**
 * The maximum length of the descriptor value
 * Values:
 * - 0 ... 512
 */
  uint16_t Char_Desc_Value_Max_Len;
/**
 * Current Length of the characteristic descriptor value
 * Values:
 * - 0 ... 512
 */
  uint16_t Char_Desc_Value_Length;
/**
 * Value of the characteristic description
 */
  uint8_t Char_Desc_Value[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} aci_gatt_srv_add_char_desc_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp2_s {
/**
 * Security permission flags.
 * Flags:
 * - 0x00
 * - 0x01: AUTHEN_READ (Need authentication to read)
 * - 0x04: ENCRY_READ (Need encryption to read)
 * - 0x08: AUTHEN_WRITE (need authentication to write)
 * - 0x20: ENCRY_WRITE (need encryption to write)
 */
  uint8_t Security_Permissions;
/**
 * Access permission
 * Flags:
 * - 0x00: None
 * - 0x01: READ
 * - 0x02: WRITE
 * - 0x04: WRITE_WO_RESP
 * - 0x08: SIGNED_WRITE
 */
  uint8_t Access_Permissions;
/**
 * GATT event mask. - GATT_NOTIFY_ATTRIBUTE_WRITE:
 * aci_gatt_srv_attribute_modified_event is generated when characteristic value
 * is modified. - GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP:
 * aci_gatt_srv_authorize_nwk_event is generated when a write operation is
 * received on the characteristic value. -
 * GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP: aci_gatt_srv_authorize_nwk_event
 * is generated when a read request is received on the characteristic value.
 * Flags:
 * - 0x00: GATT_DONT_NOTIFY_EVENTS
 * - 0x01: GATT_NOTIFY_ATTRIBUTE_WRITE
 * - 0x02: GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP
 * - 0x04: GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP
 */
  uint8_t GATT_Evt_Mask;
/**
 * Minimum encryption key size required to read the characteristic.
 * Values:
 * - 0x07 ... 0x10
 */
  uint8_t Enc_Key_Size;
/**
 * Specify if the characteristic value has a fixed length or a variable length.
 * Values:
 * - 0x00: Fixed length
 * - 0x01: Variable length
 */
  uint8_t Is_Variable;
} aci_gatt_srv_add_char_desc_nwk_cp2;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle of the characteristic descriptor
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Char_Desc_Handle;
} aci_gatt_srv_add_char_desc_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_write_handle_value_nwk_cp0_s {
/**
 * Handle of the attribute
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * The offset from which the attribute value has to be updated.  If this is set
 * to 0 and the attribute value is of variable length, then the length of the
 * attribute will be set to the Char_Value_Length.  If the Val_Offset is set to
 * a value greater than 0, then the length of the attribute will be set to the
 * maximum length as  specified for the attribute while adding the
 * characteristic.
 * Values:
 * - 0 ... 511
 */
  uint16_t Val_Offset;
/**
 * Length of the attribute value in octets
 */
  uint16_t Value_Length;
/**
 * Attribute value
 */
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_write_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_write_handle_value_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_write_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_char_nwk_cp0_s {
/**
 * Handle of the characteristic which has to be deleted
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Char_Handle;
} aci_gatt_srv_rm_char_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_char_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_rm_char_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_service_nwk_cp0_s {
/**
 * Handle of the service to be deleted
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Serv_Handle;
} aci_gatt_srv_rm_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_service_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_rm_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_include_service_nwk_cp0_s {
/**
 * Handle of the included service which has to be deleted
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Include_Handle;
} aci_gatt_srv_rm_include_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_include_service_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_rm_include_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_set_event_mask_cp0_s {
/**
 * GATT/ATT event mask.
 * Values:
 * - 0x00000001: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
 * - 0x00000002: ACI_GATT_PROC_TIMEOUT_EVENT
 * - 0x00000004: ACI_ATT_EXCHANGE_MTU_RESP_EVENT
 * - 0x00000008: ACI_ATT_FIND_INFO_RESP_EVENT
 * - 0x00000010: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
 * - 0x00000020: ACI_ATT_READ_BY_TYPE_RESP_EVENT
 * - 0x00000040: ACI_ATT_READ_RESP_EVENT
 * - 0x00000080: ACI_ATT_READ_BLOB_RESP_EVENT
 * - 0x00000100: ACI_ATT_READ_MULTIPLE_RESP_EVENT
 * - 0x00000200: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
 * - 0x00000800: ACI_ATT_PREPARE_WRITE_RESP_EVENT
 * - 0x00001000: ACI_ATT_EXEC_WRITE_RESP_EVENT
 * - 0x00002000: ACI_GATT_INDICATION_EVENT
 * - 0x00004000: ACI_GATT_NOTIFICATION_EVENT
 * - 0x00008000: ACI_GATT_ERROR_RESP_EVENT
 * - 0x00010000: ACI_GATT_PROC_COMPLETE_EVENT
 * - 0x00020000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
 * - 0x00040000: ACI_GATT_TX_POOL_AVAILABLE_EVENT
 */
  uint32_t GATT_Evt_Mask;
} aci_gatt_set_event_mask_cp0;

typedef PACKED(struct) aci_gatt_set_event_mask_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_set_event_mask_rp0;

typedef PACKED(struct) aci_gatt_clt_exchange_config_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} aci_gatt_clt_exchange_config_cp0;

typedef PACKED(struct) aci_gatt_clt_exchange_config_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_exchange_config_rp0;

typedef PACKED(struct) aci_gatt_clt_prepare_write_req_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * The offset of the first octet to be written
 * Values:
 * - 0 ... 511
 */
  uint16_t Val_Offset;
/**
 * Length of attribute value (maximum value is ATT_MTU - 5).
 */
  uint16_t Attribute_Val_Length;
/**
 * The value of the attribute to be written
 */
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_clt_prepare_write_req_cp0;

typedef PACKED(struct) aci_gatt_clt_prepare_write_req_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_prepare_write_req_rp0;

typedef PACKED(struct) aci_gatt_clt_execute_write_req_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Execute or cancel writes.
 * Values:
 * - 0x00: Cancel all prepared writes
 * - 0x01: Immediately write all pending prepared values
 */
  uint8_t Execute;
} aci_gatt_clt_execute_write_req_cp0;

typedef PACKED(struct) aci_gatt_clt_execute_write_req_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_execute_write_req_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_primary_services_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
} aci_gatt_clt_disc_all_primary_services_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_primary_services_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_disc_all_primary_services_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_primary_service_by_uuid_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * UUID type.
 * Values:
 * - 0x01: 16-bit UUID
 * - 0x02: 128-bit UUID
 */
  uint8_t UUID_Type;
/**
 * See @ref UUID_t
 */
  packed_UUID_t UUID;
} aci_gatt_clt_disc_primary_service_by_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_primary_service_by_uuid_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_disc_primary_service_by_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_find_included_services_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Start attribute handle of the service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Start_Handle;
/**
 * End attribute handle of the service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t End_Handle;
} aci_gatt_clt_find_included_services_cp0;

typedef PACKED(struct) aci_gatt_clt_find_included_services_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_find_included_services_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_of_service_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Start attribute handle of the service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Start_Handle;
/**
 * End attribute handle of the service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t End_Handle;
} aci_gatt_clt_disc_all_char_of_service_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_of_service_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_disc_all_char_of_service_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_char_by_uuid_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Start attribute handle of the service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Start_Handle;
/**
 * End attribute handle of the service
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t End_Handle;
/**
 * UUID type.
 * Values:
 * - 0x01: 16-bit UUID
 * - 0x02: 128-bit UUID
 */
  uint8_t UUID_Type;
/**
 * See @ref UUID_t
 */
  packed_UUID_t UUID;
} aci_gatt_clt_disc_char_by_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_char_by_uuid_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_disc_char_by_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_desc_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the characteristic value
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Char_Handle;
/**
 * End handle of the characteristic
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t End_Handle;
} aci_gatt_clt_disc_all_char_desc_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_desc_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_disc_all_char_desc_rp0;

typedef PACKED(struct) aci_gatt_clt_read_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be read
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
} aci_gatt_clt_read_cp0;

typedef PACKED(struct) aci_gatt_clt_read_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_read_rp0;

typedef PACKED(struct) aci_gatt_clt_read_using_char_uuid_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Starting handle of the range to be searched
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Start_Handle;
/**
 * End handle of the range to be searched
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t End_Handle;
/**
 * UUID type.
 * Values:
 * - 0x01: 16-bit UUID
 * - 0x02: 128-bit UUID
 */
  uint8_t UUID_Type;
/**
 * See @ref UUID_t
 */
  packed_UUID_t UUID;
} aci_gatt_clt_read_using_char_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_read_using_char_uuid_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_read_using_char_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_read_long_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be read
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Offset from which the value needs to be read
 * Values:
 * - 0 ... 511
 */
  uint16_t Val_Offset;
} aci_gatt_clt_read_long_cp0;

typedef PACKED(struct) aci_gatt_clt_read_long_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_read_long_rp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_char_value_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * The number of handles for which the value has to be read. From 2 to
 * (ATT_MTU-1)/2
 * Values:
 * - 0x02 ... 0xFF
 */
  uint8_t Number_of_Handles;
/**
 * The handles for which the attribute value has to be read
 */
  uint16_t Handle[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint16_t)];
} aci_gatt_clt_read_multiple_char_value_cp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_char_value_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_read_multiple_char_value_rp0;

typedef PACKED(struct) aci_gatt_clt_write_nwk_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Length of the value to be written
 */
  uint16_t Attribute_Val_Length;
/**
 * Value to be written
 */
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_write_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_write_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_long_nwk_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Offset at which the attribute has to be written
 * Values:
 * - 0 ... 511
 */
  uint16_t Val_Offset;
/**
 * Length of the value to be written
 */
  uint16_t Attribute_Val_Length;
/**
 * Value to be written
 */
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_clt_write_long_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_long_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_write_long_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_char_reliable_nwk_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Offset at which the attribute has to be written
 * Values:
 * - 0 ... 511
 */
  uint16_t Val_Offset;
/**
 * Length of the value to be written
 */
  uint16_t Attribute_Val_Length;
/**
 * Value to be written
 */
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_clt_write_char_reliable_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_char_reliable_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_write_char_reliable_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_without_resp_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Length of the value to be written (maximum value is ATT_MTU - 3)
 */
  uint16_t Attribute_Val_Length;
/**
 * Value to be written
 */
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_write_without_resp_cp0;

typedef PACKED(struct) aci_gatt_clt_write_without_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_write_without_resp_rp0;

typedef PACKED(struct) aci_gatt_clt_signed_write_without_resp_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Length of the value to be written (up to ATT_MTU - 13)
 */
  uint16_t Attribute_Val_Length;
/**
 * Value to be written
 */
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_signed_write_without_resp_cp0;

typedef PACKED(struct) aci_gatt_clt_signed_write_without_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_signed_write_without_resp_rp0;

typedef PACKED(struct) aci_gatt_clt_confirm_indication_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
} aci_gatt_clt_confirm_indication_cp0;

typedef PACKED(struct) aci_gatt_clt_confirm_indication_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_confirm_indication_rp0;

typedef PACKED(struct) aci_gatt_srv_set_security_permission_nwk_cp0_s {
/**
 * Handle of the attribute whose security permission has to be modified
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Security permission flags.
 * Flags:
 * - 0x00
 * - 0x01: AUTHEN_READ (Need authentication to read)
 * - 0x04: ENCRY_READ (Need encryption to read)
 * - 0x08: AUTHEN_WRITE (need authentication to write)
 * - 0x20: ENCRY_WRITE (need encryption to write)
 */
  uint8_t Security_Permissions;
} aci_gatt_srv_set_security_permission_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_set_security_permission_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_set_security_permission_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_read_handle_value_nwk_cp0_s {
/**
 * Handle of the attribute to read
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Offset from which the value needs to be read
 * Values:
 * - 0 ... 511
 */
  uint16_t Offset;
/**
 * Maximum number of octets to be returned as attribute value
 * Values:
 * - 0 ... 512
 */
  uint16_t Value_Length_Requested;
} aci_gatt_srv_read_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_handle_value_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of the attribute value
 */
  uint16_t Length;
/**
 * Length in octets of the Value parameter
 */
  uint16_t Value_Length;
/**
 * Attribute value
 */
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_gatt_srv_read_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_set_access_permission_nwk_cp0_s {
/**
 * Handle of the attribute whose security permission has to be modified
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Access permission
 * Flags:
 * - 0x00
 * - 0x01: READ
 * - 0x02: WRITE
 * - 0x04: WRITE_NO_RESP
 * - 0x08: SIGNED_WRITE
 */
  uint8_t Access_Permissions;
} aci_gatt_srv_set_access_permission_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_set_access_permission_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_set_access_permission_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_notify_cp0_s {
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to be notified
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Select the notification type.
 * Values:
 * - 0x00: GATT_NOTIFICATION
 * - 0x02: GATT_INDICATION
 */
  uint8_t Flags;
/**
 * Length of the Val field.
 */
  uint16_t Val_Length;
/**
 *
 */
  uint8_t Val[(HCI_MAX_PAYLOAD_SIZE - 9)/sizeof(uint8_t)];
} aci_gatt_srv_notify_cp0;

typedef PACKED(struct) aci_gatt_srv_notify_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_notify_rp0;

typedef PACKED(struct) aci_gatt_srv_exec_write_resp_nwk_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Conn_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * If 1, allow execution of queued writes. If 0 flush all queued writes for the
 * given connection handle.
 * Values:
 * - 0x00: FLUSH
 * - 0x01: EXECUTE
 */
  uint8_t Exec;
} aci_gatt_srv_exec_write_resp_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_exec_write_resp_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_exec_write_resp_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_authorize_resp_nwk_cp0_s {
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Conn_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Offset from which the value needs to be read or write
 * Values:
 * - 0 ... 511
 */
  uint16_t Attr_Handle;
/**
 *
 * Values:
 * - 0x00: Read
 * - 0x10: Write Request
 * - 0x11: Write Command or Signed Write Command
 * - 0x12: Prepare Write Request
 */
  uint8_t Operation_Type;
/**
 * Set to 0 if operation is authorized, otherwise Error_Code is the ATT error
 * code that will be sent to the peer in reaponse to the request.
 * Values:
 * - 0: Authorize
 * - 0 ... 255
 */
  uint8_t Error_Code;
/**
 * Offset from which the attribute needs to be read or written. For a read
 * operation it is always 0.
 * Values:
 * - 0 ... 511
 */
  uint16_t Attr_Val_Offset;
/**
 * Length of Data field
 */
  uint16_t Data_Length;
/**
 * The data that the client has requested to write.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(uint8_t)];
} aci_gatt_srv_authorize_resp_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_authorize_resp_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_authorize_resp_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_read_prepare_queue_nwk_cp0_s {
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Conn_Handle;
/**
 * The index of the entry in the queue for the selected connection handle.
 */
  uint8_t Item_Index;
} aci_gatt_srv_read_prepare_queue_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_prepare_queue_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The attribute handle of the returned entry.
 */
  uint16_t Attr_Handle;
/**
 * The offset from which the peer is requesting to start writing.
 */
  uint16_t Value_Offset;
/**
 * Length in octets of the Value parameter
 */
  uint16_t Value_Length;
/**
 * The value to be written.
 */
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_gatt_srv_read_prepare_queue_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_write_multiple_instance_handle_value_cp0_s {
/**
 * Connection handle for which the attribute value will be written.
 */
  uint16_t Connection_Handle;
/**
 * Handle of the attribute
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Length of the attribute value in octets.
 */
  uint16_t Value_Length;
/**
 * Attribute value.
 */
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_write_multiple_instance_handle_value_cp0;

typedef PACKED(struct) aci_gatt_srv_write_multiple_instance_handle_value_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_write_multiple_instance_handle_value_rp0;

typedef PACKED(struct) aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0_s {
/**
 * Connection handle for which the attribute value will be read.
 */
  uint16_t Connection_Handle;
/**
 * Handle of the attribute
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
} aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of the attribute value in octets.
 */
  uint16_t Value_Length;
/**
 * Attribute value.
 */
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_multi_notify_cp0_s {
/**
 * Connection handle for which the attribute value will be read.
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * Reserved for future use. Its value must be set to 0.
 * Values:
 * - 0x00
 */
  uint8_t Flags;
/**
 *
 */
  uint8_t Num_Of_Attr;
/**
 * See @ref Gatt_Srv_Notify_Attr_t
 */
  packed_Gatt_Srv_Notify_Attr_t Gatt_Srv_Notify_Attr[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(packed_Gatt_Srv_Notify_Attr_t)];
} aci_gatt_srv_multi_notify_cp0;

typedef PACKED(struct) aci_gatt_srv_multi_notify_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_srv_multi_notify_rp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_var_len_char_value_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Channel Identifier of the ATT bearer. It must be set to 0x0004 for unenhanced
 * ATT bearer.
 */
  uint16_t CID;
/**
 * The number of handles for which the value has to be read. From 2 to
 * (ATT_MTU-1)/2
 * Values:
 * - 0x02 ... 0xFF
 */
  uint8_t Number_of_Handles;
/**
 * The handles for which the attribute value has to be read
 */
  uint16_t Handle[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint16_t)];
} aci_gatt_clt_read_multiple_var_len_char_value_cp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_var_len_char_value_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_gatt_clt_read_multiple_var_len_char_value_rp0;

typedef PACKED(struct) aci_gatt_clt_add_subscription_security_level_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint16_t Char_Value_Handle;
  uint8_t Sec_Level;
} aci_gatt_clt_add_subscription_security_level_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_add_subscription_security_level_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_add_subscription_security_level_nwk_rp0;
typedef PACKED(struct) aci_l2cap_connection_parameter_update_req_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Defines connection timeout parameter in the following manner: Timeout
 * Multiplier * 10ms.
 * Values:
 * - 10 (100 ms)  ... 3200 (32000 ms) 
 */
  uint16_t Timeout_Multiplier;
} aci_l2cap_connection_parameter_update_req_cp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_req_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_connection_parameter_update_req_rp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_resp_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Defines connection timeout parameter in the following manner: Timeout
 * Multiplier * 10ms.
 * Values:
 * - 10 (100 ms)  ... 3200 (32000 ms) 
 */
  uint16_t Timeout_Multiplier;
/**
 * The minimum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Min_CE_Length;
/**
 * The maximum length of connection event recommended for this LE connection.
 * Time = N * 0.625 msec.
 */
  uint16_t Max_CE_Length;
/**
 * Identifier received in ACI_L2CAP_Connection_Update_Req event.
 */
  uint8_t Identifier;
/**
 * Specify if connection update parameters are acceptable or not.
 * Values:
 * - 0x00: Reject
 * - 0x01: Accept
 */
  uint8_t Accept;
} aci_l2cap_connection_parameter_update_resp_cp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_connection_parameter_update_resp_rp0;

typedef PACKED(struct) aci_l2cap_cos_connection_req_cp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * Simplified Protocol/Service Multiplexer
 * Values:
 * - 0x0001 ... 0x00FF
 */
  uint16_t SPSM;
/**
 * The maximum SDU size (in octets) that the L2CAP layer entity sending the
 * L2CAP_LE_CREDIT_BASED_CONNECTION_REQ can receive on this channel.
 * Values:
 * - 23 ... 65535
 */
  uint16_t MTU;
/**
 * The maximum PDU payload size (in octets) that the L2CAP layer entity sending
 * the L2CAP_LE_CREDIT_BASED_CONNECTION_REQ is capable of receiving on this
 * channel.
 * Values:
 * - 23 ... 65533
 */
  uint16_t MPS;
/**
 * Type of channel: LE Credit Based Flow Control Mode or Enhanced Credit Based
 * Flow Control Mode.
 * Values:
 * - 0x00: L2CAP_CHANNEL_TYPE_LE_CFC
 * - 0x01: L2CAP_CHANNEL_TYPE_ECFC
 */
  uint8_t Channel_Type;
/**
 *
 */
  uint8_t CID_Count;
} aci_l2cap_cos_connection_req_cp0;

typedef PACKED(struct) aci_l2cap_cos_connection_req_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_cos_connection_req_rp0;

typedef PACKED(struct) aci_l2cap_cos_connection_resp_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Identifier of the request.
 */
  uint8_t Identifier;
/**
 * The MTU field specifies the maximum SDU size (in octets) that the L2CAP layer
 * entity sending the L2CAP_LE_CREDIT_BASED_CONNECTION_RSP can receive on this
 * channel.
 * Values:
 * - 23 ... 65535
 */
  uint16_t MTU;
/**
 * The MPS field specifies the maximum PDU payload size (in octets) that the
 * L2CAP layer entity sending the L2CAP_LE_CREDIT_BASED_CONNECTION_RSP is
 * capable of receiving on this channel.
 * Values:
 * - 23 ... 65533
 */
  uint16_t MPS;
/**
 * It indicates the outcome of the connection request. A result value of 0x0000
 * indicates success while a non-zero value indicates a fail. Code values
 * starting from 0x000C can be used only for ECFC channel type.
 * Values:
 * - 0x0000: L2CAP_CONN_SUCCESSFUL
 * - 0x0002: L2CAP_CONN_FAIL_SPSM_NOT_SUPPORTED
 * - 0x0004: L2CAP_CONN_FAIL_INSUFFICIENT_RESOURCES
 * - 0x0005: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHENTICATION
 * - 0x0006: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHORIZATION
 * - 0x0007: L2CAP_CONN_FAIL_KEY_SIZE_TOO_SHORT
 * - 0x0008: L2CAP_CONN_FAIL_INSUFFICIENT_ENCRYPTION
 * - 0x000B: L2CAP_CONN_FAIL_UNACCEPTABLE_PARAMETERS
 * - 0x000C: L2CAP_CONN_FAIL_INVALID_PARAMETERS
 * - 0x000D: L2CAP_CONN_FAIL_NO_INFO
 * - 0x000E: L2CAP_CONN_FAIL_AUTHENTICATION_PENDING
 * - 0x000F: L2CAP_CONN_FAIL_AUTHORIZATION_PENDING
 */
  uint16_t Result;
/**
 *
 */
  uint8_t CID_Count;
} aci_l2cap_cos_connection_resp_cp0;

typedef PACKED(struct) aci_l2cap_cos_connection_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  uint8_t CID_Count;
/**
 *
 */
  uint16_t CID[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint16_t)];
} aci_l2cap_cos_connection_resp_rp0;

typedef PACKED(struct) aci_l2cap_cos_flow_control_credits_ind_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t RX_Credits;
  uint8_t CFC_Policy;
} aci_l2cap_cos_flow_control_credits_ind_cp0;

typedef PACKED(struct) aci_l2cap_cos_flow_control_credits_ind_rp0_s {
  uint8_t Status;
  uint16_t RX_Credit_Balance;
} aci_l2cap_cos_flow_control_credits_ind_rp0;
typedef PACKED(struct) aci_l2cap_cos_disconnect_req_cp0_s {
/**
 *
 */
  uint16_t Connection_Handle;
/**
 * Local endpoint of the channel to be disconnected.
 */
  uint16_t CID;
} aci_l2cap_cos_disconnect_req_cp0;

typedef PACKED(struct) aci_l2cap_cos_disconnect_req_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_cos_disconnect_req_rp0;

typedef PACKED(struct) aci_l2cap_cos_sdu_data_transmit_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 * Length of the SDU to be transmitted.
 */
  uint16_t SDU_Length;
/**
 * Data contained in the SDU to be transmitted. Data must be valid until the SDU
 * is transmitted.
 */
  uint8_t SDU_Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_l2cap_cos_sdu_data_transmit_cp0;

typedef PACKED(struct) aci_l2cap_cos_sdu_data_transmit_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_cos_sdu_data_transmit_rp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_req_cp0_s {
/**
 * Identifier received in the aci_eatt_connection_event.
 */
  uint16_t Connection_Handle;
/**
 * The maximum SDU size (in octets) that the L2CAP layer entity can receive on
 * each of the Source CID channels (represented by Local_CID array parameter).
 * This is equal to the maximum size of an ATT packet on the Enhanced ATT
 * bearer.
 * Values:
 * - 0x0040 ... 0xFFFF
 */
  uint16_t MTU;
/**
 * The maximum PDU payload size (in octets) that the local L2CAP layer is
 * capable of receiving on each of the Source CID channels (represented by
 * Local_CID array parameter).
 * Values:
 * - 0x0040 ... 0xFFFF
 */
  uint16_t MPS;
/**
 * The number of potential Enhanced ATT bearers that are going to be opened.
 * This is the number of L2CAP channels to be opened in Enhanced Credit Based
 * Flow Control mode.
 * Values:
 * - 0x01 ... 0x05
 */
  uint8_t CID_Count;
/**
 * List of CID values representing the channel endpoints on the local device.
 * Each entry in the array shall be non-zero and represents a request for a
 * channel. The value of each CID shall be from the dynamically allocated range
 * for LE devices (0x0040-0x007F) and shall not be already allocated to a
 * different channel on the device sending the request.
 */
  uint16_t CID[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint16_t)];
} aci_l2cap_cos_reconfigure_req_cp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_req_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_cos_reconfigure_req_rp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_resp_cp0_s {
/**
 * Identifier received in the aci_eatt_connection_event.
 */
  uint16_t Connection_Handle;
/**
 * Identifier received in the aci_eatt_connection_event.
 */
  uint8_t Identifier;
/**
 * It indicates the outcome of the connection request. A result value of 0x0000
 * indicates success while a non-zero value indicates the connection request was
 * refused.
 * Values:
 * - 0x0000: L2CAP_RECONFIG_SUCCESSFUL
 * - 0x0001: L2CAP_MTU_REDUCTION_NOT_ALLOWED
 * - 0x0002: L2CAP_MPS_REDUCTION_NOT_ALLOWED
 * - 0x0003: L2CAP_INVALID_DESTINATION_CID
 * - 0x0004: L2CAP_UNACCEPTABLE_PARAMETERS
 */
  uint16_t Result;
} aci_l2cap_cos_reconfigure_resp_cp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_resp_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_l2cap_cos_reconfigure_resp_rp0;

typedef PACKED(struct) aci_test_tx_notification_start_cp0_s {
/**
 * Connection handle to notify.
 */
  uint16_t Connection_Handle;
/**
 * Handle of service to which the characteristic belongs
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Service_Handle;
/**
 * Handle of the characteristic
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Char_Handle;
/**
 * Length of the characteristic to be notified. Only ATT_MTU - 3 bytes are sent
 * with notifications.
 */
  uint16_t Value_Length;
} aci_test_tx_notification_start_cp0;

typedef PACKED(struct) aci_test_tx_notification_start_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_test_tx_notification_start_rp0;

typedef PACKED(struct) aci_test_tx_write_command_start_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 * Length of the characteristic to be written with write commands. Only ATT_MTU
 * - 3 bytes are written.
 */
  uint16_t Value_Length;
} aci_test_tx_write_command_start_cp0;

typedef PACKED(struct) aci_test_tx_write_command_start_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_test_tx_write_command_start_rp0;

typedef PACKED(struct) aci_test_rx_start_cp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Handle of the attribute to be written
 * Values:
 * - 0x0001 ... 0xFFFF
 */
  uint16_t Attr_Handle;
/**
 *
 * Values:
 * - 0x00: Notifications
 * - 0x01: Write Commands
 */
  uint8_t Notifications_WriteCmds;
} aci_test_rx_start_cp0;

typedef PACKED(struct) aci_test_rx_start_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_test_rx_start_rp0;

typedef PACKED(struct) aci_test_stop_cp0_s {
/**
 *
 * Values:
 * - 0x00: TX
 * - 0x01: RX
 */
  uint8_t TX_RX;
} aci_test_stop_cp0;

typedef PACKED(struct) aci_test_stop_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
} aci_test_stop_rp0;

typedef PACKED(struct) aci_test_report_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 *
 */
  uint32_t TX_Packets;
/**
 *
 */
  uint32_t RX_Packets;
/**
 *
 */
  uint16_t RX_Data_Length;
/**
 *
 */
  uint32_t RX_Sequence_Errors;
} aci_test_report_rp0;

/**
 * The Disconnection Complete event occurs when a connection is terminated. The
 * status parameter indicates if the disconnection was successful or not. The
 * reason parameter indicates the reason for the disconnection if the
 * disconnection was successful. If the disconnection was not successful, the
 * value of the reason parameter can be ignored by the Host. For example, this
 * can be the case if the Host has issued the Disconnect command and there was a
 * parameter error, or the command was not presently allowed, or a
 * Connection_Handle that didn't correspond to a connection was given.
 */
typedef PACKED(struct) hci_disconnection_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection_Handle which was disconnected.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Reason for disconnection. See Error Codes.
 */
  uint8_t Reason;
} hci_disconnection_complete_event_rp0;

/**
 * The Encryption Change event is used to indicate that the change of the
 * encryption mode has been completed. The Connection_Handle will be a
 * Connection_Handle for an ACL connection. The Encryption_Enabled event
 * parameter specifies the new Encryption_Enabled parameter for the
 * Connection_Handle specified by the Connection_Handle event parameter. This
 * event will occur on both devices to notify the Hosts when Encryption has
 * changed for the specified Connection_Handle between two devices. Note: This
 * event shall not be generated if encryption is paused or resumed; during a
 * role switch, for example. The meaning of the Encryption_Enabled parameter
 * depends on whether the Host has indicated support for Secure Connections in
 * the Secure_Connections_Host_Support parameter. When
 * Secure_Connections_Host_Support is 'disabled' or the Connection_Handle refers
 * to an LE link, the Controller shall only use Encryption_Enabled values 0x00
 * (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 * 7.7.8)
 */
typedef PACKED(struct) hci_encryption_change_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Link Level Encryption.
 * Values:
 * - 0x00: Link Level Encryption OFF
 * - 0x01: Link Level Encryption is ON with AES-CCM
 */
  uint8_t Encryption_Enabled;
} hci_encryption_change_event_rp0;

/**
 * The Read Remote Version Information Complete event is used to indicate the
 * completion of the process obtaining the version information of the remote
 * Controller specified by the Connection_Handle event parameter. The
 * Connection_Handle shall be for an ACL connection. The Version event parameter
 * defines the specification version of the LE Controller. The Manufacturer_Name
 * event parameter indicates the manufacturer of the remote Controller. The
 * Subversion event parameter is controlled by the manufacturer and is
 * implementation dependent. The Subversion event parameter defines the various
 * revisions that each version of the Bluetooth hardware will go through as
 * design processes change and errors are fixed. This allows the software to
 * determine what Bluetooth hardware is being used and, if necessary, to work
 * around various bugs in the hardware. When the Connection_Handle is associated
 * with an LE-U logical link, the Version event parameter shall be Link Layer
 * VersNr parameter, the Manufacturer_Name event parameter shall be the CompId
 * parameter, and the Subversion event parameter shall be the SubVersNr
 * parameter. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12)
 */
typedef PACKED(struct) hci_read_remote_version_information_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Version of the Current LMP in the remote Controller
 */
  uint8_t Version;
/**
 * Manufacturer Name of the remote Controller
 */
  uint16_t Manufacturer_Name;
/**
 * Subversion of the LMP in the remote Controller
 */
  uint16_t Subversion;
} hci_read_remote_version_information_complete_event_rp0;

/**
 * The Hardware Error event is used to indicate some implementation specific
 * type of hardware failure for the controller. This event is used to notify the
 * Host that a hardware failure has occurred in the Controller.
 */
typedef PACKED(struct) hci_hardware_error_event_rp0_s {
/**
 * Error code 0x01 and 0x02 are errors generally caused by hardware issue on the
 * PCB; another possible cause is a slow crystal startup. In the latter case,
 * the HS_STARTUP_TIME in the device configuration needs to be tuned. Error code
 * 0x03 indicates an internal error of the protocol stack. This event with error
 * code 0x04 is raised when a radio interrupt is served late. This usually
 * happens when interrupts are disabled for too long time or when a Flash
 * operation is performed (which can be also triggered by the Stack to store
 * bonding information). Stack will try to recover the situation, so there is
 * normally no need to reset the device. However this condition should be
 * avoided as much as possible. Error code 0x05 is raised when an error happens
 * during a TX transaction. After this event is received with error code 0x00,
 * 0x01, 0x02 or 0x03, it is recommended to force a device reset.
 * Values:
 * - 0x00: Generic HW error
 * - 0x01: Radio state error
 * - 0x02: Timer overrun error
 * - 0x03: Internal queue overflow error
 * - 0x04: Late Radio ISR
 * - 0x05: TX Error
 */
  uint8_t Hardware_Code;
} hci_hardware_error_event_rp0;

/**
 * The Number Of Completed Packets event is used by the Controller to indicate
 * to the Host how many HCI Data Packets have been completed (transmitted or
 * flushed) for each Connection_Handle since the previous Number Of Completed
 * Packets event was sent to the Host. This means that the corresponding buffer
 * space has been freed in the Controller. Based on this information, and the
 * HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_- Data_Packets
 * return parameter of the Read_Buffer_Size command, the Host can determine for
 * which Connection_Handles the following HCI Data Packets should be sent to the
 * Controller. The Number Of Completed Packets event must not be sent before the
 * corresponding Connection Complete event. While the Controller has HCI data
 * packets in its buffer, it must keep sending the Number Of Completed Packets
 * event to the Host at least periodically, until it finally reports that all
 * the pending ACL Data Packets have been transmitted or flushed.
 */
typedef PACKED(struct) hci_number_of_completed_packets_event_rp0_s {
/**
 * The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs
 * contained in this event
 */
  uint8_t Number_of_Handles;
/**
 * See @ref Handle_Packets_Pair_Entry_t
 */
  packed_Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Handle_Packets_Pair_Entry_t)];
} hci_number_of_completed_packets_event_rp0;

/**
 * This event is used to indicate that the Controller's data buffers have been
 * overflowed. This can occur if the Host has sent more packets than allowed.
 * The Link_Type parameter is used to indicate that the overflow was caused by
 * ACL data.
 */
typedef PACKED(struct) hci_data_buffer_overflow_event_rp0_s {
/**
 * On which type of channel overflow has occurred.
 * Values:
 * - 0x01: ACL Buffer Overflow
 */
  uint8_t Link_Type;
} hci_data_buffer_overflow_event_rp0;

/**
 * The Encryption Key Refresh Complete event is used to indicate to the Host
 * that the encryption key was refreshed on the given Connection_Handle any time
 * encryption is paused and then resumed. If the Encryption Key Refresh Complete
 * event was generated due to an encryption pause and resume operation embedded
 * within a change connection link key procedure, the Encryption Key Refresh
 * Complete event shall be sent prior to the Change Connection Link Key Complete
 * event. If the Encryption Key Refresh Complete event was generated due to an
 * encryption pause and resume operation embedded within a role switch
 * procedure, the Encryption Key Refresh Complete event shall be sent prior to
 * the Role Change event.
 */
typedef PACKED(struct) hci_encryption_key_refresh_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_encryption_key_refresh_complete_event_rp0;

/**
 * The HCI_Authenticated_Payload_Timeout_Expired event is used to indicate that
 * a packet containing a valid MIC on the Connection_Handle was not received
 * within the authenticatedPayloadTO. Note: A Host may choose to disconnect the
 * link when this occurs.
 */
typedef PACKED(struct) hci_authenticated_payload_timeout_expired_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_authenticated_payload_timeout_expired_event_rp0;

/**
 * This event inform the application that the network coprocessor has been
 * reset. If the reason code is a system crash, a following event @ref
 * aci_blue_crash_info_event will provide more information regarding the system
 * crash details.
 */
typedef PACKED(struct) aci_blue_initialized_event_rp0_s {
/**
 * Reason code describing why device was reset and in which mode is operating
 * (Updater or Normal mode)
 * Values:
 * - 0x01: Firmware started properly
 * - 0x02: Updater mode entered with ACI command
 * - 0x03: Updater mode entered due to bad Blue Flag
 * - 0x04: Updater mode entered due to boot pin
 * - 0x05: System reset due to watchdog
 * - 0x06: System reset due to lockup
 * - 0x07: System reset due to brownout reset
 * - 0x08: System reset due to crash
 * - 0x09: System reset due to ECC error
 */
  uint8_t Reason_Code;
} aci_blue_initialized_event_rp0;

/**
 * This event is given to the application after the @ref
 * aci_blue_initialized_event when a system crash is detected. This events
 * returns system crash information for debugging purposes.  Information
 * reported are useful to understand the root cause of the crash.
 */
typedef PACKED(struct) aci_blue_crash_info_event_rp0_s {
/**
 * Crash type
 * Values:
 * - 0x00: Assert failed
 * - 0x01: NMI fault
 * - 0x02: Hard fault
 */
  uint8_t Crash_Type;
/**
 * Stack pointer
 */
  uint32_t SP;
/**
 * Register R0
 */
  uint32_t R0;
/**
 * Register R1
 */
  uint32_t R1;
/**
 * Register R2
 */
  uint32_t R2;
/**
 * Register R3
 */
  uint32_t R3;
/**
 * Register R12
 */
  uint32_t R12;
/**
 * Link register
 */
  uint32_t LR;
/**
 * Program counter where crash occurred
 */
  uint32_t PC;
/**
 * xPSR register
 */
  uint32_t xPSR;
/**
 * Length of Debug_Data field
 */
  uint8_t Debug_Data_Length;
/**
 * Debug data
 */
  uint8_t Debug_Data[(HCI_MAX_PAYLOAD_SIZE - 38)/sizeof(uint8_t)];
} aci_blue_crash_info_event_rp0;

/**
 * This event is generated when the device completes a radio activity and
 * provide information when a new radio activity will be performed. Information
 * provided includes type of radio activity and absolute time in system ticks
 * when a new radio activity is schedule, if any. Application can use this
 * information to schedule user activities synchronous to selected radio
 * activities. A command @ref aci_hal_set_radio_activity_mask is provided to
 * enable radio activity events of user interests, by default no events are
 * enabled. User should take into account that enabling radio events in
 * application with intense radio activity could lead to a fairly high rate of
 * events generated. Application use cases includes synchronizing notification
 * with connection interval, switching  antenna at the end of advertising or
 * performing flash erase operation while radio is idle.
 */
typedef PACKED(struct) aci_hal_end_of_radio_activity_event_rp0_s {
/**
 * Completed radio events
 * Values:
 * - 0x00: Idle
 * - 0x01: Advertising
 * - 0x02: Connection event peripheral
 * - 0x03: Scanning
 * - 0x04: Connection request
 * - 0x05: Connection event central
 * - 0x06: TX test mode
 * - 0x07: RX test mode
 */
  uint8_t Last_State;
/**
 * Incoming radio events
 * Values:
 * - 0x00: Idle
 * - 0x01: Advertising
 * - 0x02: Connection event peripheral
 * - 0x03: Scanning
 * - 0x04: Connection request
 * - 0x05: Connection event central
 * - 0x06: TX test mode
 * - 0x07: RX test mode
 */
  uint8_t Next_State;
/**
 * 32bit absolute current time expressed in internal time units.
 */
  uint32_t Next_State_SysTime;
} aci_hal_end_of_radio_activity_event_rp0;

/**
 * This event is generated to report firmware error information.
 */
typedef PACKED(struct) aci_hal_fw_error_event_rp0_s {
/**
 * Code identifying the type of error that has occurred in Bluetooth stack.
 * 0x01: L2CAP layer failed recombining a PDU; 0x02: GATT layer received an
 * unexpteced response (protocol violation); 0x03: GATT layer received an
 * unexpteced request (protocol violation); 0x04: No space to store info GATT
 * database info in NVM (database clean-up  needed or bonding entries to be
 * removed); 0x05: No space to store bonding info in NVM  (database clean-up
 * needed or bonding entries to be removed); 0x06: Link Layer scheduler failed
 * to reschedule slots for too many times (a system reset is recommended; 0x07:
 * Out of memory resources for isochronous channels; 0x08: Error in programming
 * timer for CTE reception functionality.
 * Values:
 * - 0x01: HAL_FW_L2CAP_RECOMBINATION_ERROR
 * - 0x02: HAL_FW_GATT_UNEXPECTED_RESPONSE_ERROR
 * - 0x03: HAL_FW_GATT_SEQUENTIAL_PROTOCOL_ERROR
 * - 0x04: HAL_FW_BONDING_DB_FULL_GATTSERVICE_ERROR
 * - 0x05: HAL_FW_BONDING_DB_FULL_PAIRING_ERROR
 * - 0x06: HAL_FW_SCHEDULER_OVERRUN_ERROR
 * - 0x07: HAL_FW_MEMBUF_NOT_AVAILABLE
 * - 0x08: HAL_FW_CTE_TIMER_PROGRAM_ERROR
 */
  uint8_t FW_Error_Type;
/**
 * Length of Data in octets
 */
  uint8_t Data_Length;
/**
 * The error event info. If FW_Error_Type is 0x01, 0x02 or 0x03, this parameter
 * contains the connection handle where the abnormal condition has occurred.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_fw_error_event_rp0;

/**
 * This event is generated when the amount of transmitted test packets specified
 * with aci_hal_transmitter_test_packets() has been reached.
 */
typedef PACKED(struct) aci_hal_le_test_end_event_rp0_s {
/**
 * The number of test packets actually transmitted.
 */
  uint16_t Number_Of_Packets;
} aci_hal_le_test_end_event_rp0;

/**
 * This event is generated when the pairing process has completed successfully
 * or a pairing procedure timeout has occurred or the pairing has failed. This
 * is to notify the application that we have paired with a remote device so that
 * it can take further actions or to notify that a timeout has occurred so that
 * the upper layer can decide to disconnect the link.
 */
typedef PACKED(struct) aci_gap_pairing_complete_event_rp0_s {
/**
 * Connection handle on which the pairing procedure completed
 */
  uint16_t Connection_Handle;
/**
 * Pairing status. If 0x02, see Reason code.
 * Values:
 * - 0x00: Success
 * - 0x01: Timeout
 * - 0x02: Pairing Failed
 * - 0x03: Encryption failed, LTK missing on local device
 * - 0x04: Encryption failed, LTK missing on peer device
 * - 0x05: Encryption not supported by remote device
 */
  uint8_t Status;
/**
 * Pairing reason error code
 * Values:
 * - 0x00
 * - 0x01: SM_PASSKEY_ENTRY_FAILED
 * - 0x02: SM_OOB_NOT_AVAILABLE
 * - 0x03: SM_AUTHENTICATION_REQUIREMENTS
 * - 0x04: SM_CONFIRM_VALUE_FAILED
 * - 0x05: SM_PAIRING_NOT_SUPPORTED
 * - 0x06: SM_ENCRYPTION_KEY_SIZE
 * - 0x07: SM_CMD_NOT_SUPPORTED
 * - 0x08: SM_UNSPECIFIED_REASON
 * - 0x09: SM_REPEATED_ATTEMPTS
 * - 0x0A: SM_INVALID_PARAMETERS
 * - 0x0B: SMP_DHKEY_CHECK_FAILED
 * - 0x0C: SMP_NUMCOMPARISON_FAILED
 * - 0x0D: SM_BR_EDR_PAIRING_IN_PROGRESS
 * - 0x0E: SM_CROSS_TRANSPORT_KEY_NOT_ALLOWED
 * - 0x0F: SM_KEY_REJECTED
 */
  uint8_t Reason;
} aci_gap_pairing_complete_event_rp0;

/**
 * This event is generated by the Security manager to the application when a
 * passkey is required for pairing. When this event is received, the application
 * has to respond with the @ref aci_gap_passkey_resp command.
 */
typedef PACKED(struct) aci_gap_passkey_req_event_rp0_s {
/**
 * Connection handle for which the passkey has been requested.
 */
  uint16_t Connection_Handle;
/**
 * This parameter informs the application if the passkey needs to be displayed
 * or requested for input on the local device.
 * Values:
 * - 0x00: PASSKEY_DISPLAY
 * - 0x01: PASSKEY_INPUT
 */
  uint8_t Display_Input;
} aci_gap_passkey_req_event_rp0;

/**
 * This event is sent by the GAP to the upper layers when a procedure previously
 * started has been terminated by the upper layer or has completed for any other
 * reason
 */
typedef PACKED(struct) aci_gap_proc_complete_event_rp0_s {
/**
 * Code identifying the procedure.
 * Values:
 * - 0x00: GAP_LIMITED_DISCOVERY_PROC
 * - 0x01: GAP_GENERAL_DISCOVERY_PROC
 * - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 * - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 * - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 * - 0x05: GAP_OBSERVATION_PROC
 * - 0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC
 * - 0x07: GAP_NAME_DISCOVERY_PROC
 */
  uint8_t Procedure_Code;
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of Data in octets
 */
  uint8_t Data_Length;
/**
 * Procedure Specific Data: - For Name Discovery Procedure: the name of the peer
 * device if the procedure completed successfully.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_proc_complete_event_rp0;

/**
 * This event is sent only by a privacy enabled Peripheral. The event is sent to
 * the upper layers when the peripheral is unsuccessful in resolving the
 * resolvable address of the peer device after connecting to it.
 */
typedef PACKED(struct) aci_gap_addr_not_resolved_event_rp0_s {
/**
 * Connection handle for which the private address could not be resolved with
 * any of the stored IRK's.
 */
  uint16_t Connection_Handle;
} aci_gap_addr_not_resolved_event_rp0;

/**
 * This event is sent only during SC v.4.2 Pairing, when Numeric Comparison
 * Association model is selected, in order to show the Numeric Value generated,
 * and to ask for Confirmation to the User. When this event is received, the
 * application has to respond with the  @ref
 * aci_gap_numeric_comparison_value_confirm_yesno command
 */
typedef PACKED(struct) aci_gap_numeric_comparison_value_event_rp0_s {
/**
 * Connection handle related to the underlying Pairing
 */
  uint16_t Connection_Handle;
/**
 *
 */
  uint32_t Numeric_Value;
} aci_gap_numeric_comparison_value_event_rp0;

/**
 * This event is sent only during SC v.4.2 Pairing, when Keypress Notifications
 * are supported, in order to show the input type signalled by the peer device,
 * having Keyboard only I/O capabilities. When this event is received, no action
 * is required to the User.
 */
typedef PACKED(struct) aci_gap_keypress_notification_event_rp0_s {
/**
 * Connection handle related to the underlying Pairing
 */
  uint16_t Connection_Handle;
/**
 * Type of Keypress input notified/signaled by peer device
 * Values:
 * - 0x00: PASSKEY_ENTRY_STARTED
 * - 0x01: PASSKEY_DIGIT_ENTERED
 * - 0x02: PASSKEY_DIGIT_ERASED
 * - 0x03: PASSKEY_CLEARED
 * - 0x04: PASSKEY_ENTRY_COMPLETED
 */
  uint8_t Notification_Type;
} aci_gap_keypress_notification_event_rp0;

/**
 * This event may be generated when there is a request to start a pairing
 * process.  Application shall respond with aci_gap_pairing_resp command to
 * accept or reject the incoming pairing procedure notified through this event.
 * If the pairing is going to start with a non-bonded device, the Bonded
 * parameter is set to 0. Instead, if the pairing process is going to start with
 * an already bonded device, the event is raised with Bonded parameter set to 1.
 * This may happen either if the peer has lost the bond or if it is a malicious
 * device.   If aci_gap_set_security_requirements command was given with
 * Pairing_Response set to 1 (pairing confirmation only for bonded devices), the
 * event is raised only if pairing is going to be initiated with a bonded
 * device.
 */
typedef PACKED(struct) aci_gap_pairing_event_rp0_s {
/**
 *
 */
  uint16_t Connection_Handle;
/**
 * Indicates if the peer device is already bonded or not.
 * Values:
 * - 0x00: DEVICE_NOT_BONDED
 * - 0x01: DEVICE_BONDED
 */
  uint8_t Bonded;
} aci_gap_pairing_event_rp0;

/**
 * This event is generated when the central responds to the connection update
 * request packet with a connection update response packet.
 */
typedef PACKED(struct) aci_l2cap_connection_update_resp_event_rp0_s {
/**
 * Connection handle referring to the COS Channel where the Disconnection has
 * been received.
 */
  uint16_t Connection_Handle;
/**
 *
 */
  uint16_t Result;
} aci_l2cap_connection_update_resp_event_rp0;

/**
 * This event is generated when the central does not respond to the connection
 * update request packet with a connection update response packet or a command
 * reject packet within 30 seconds.
 */
typedef PACKED(struct) aci_l2cap_proc_timeout_event_rp0_s {
/**
 * Handle of the connection related to this L2CAP procedure.
 */
  uint16_t Connection_Handle;
/**
 * Length of following data
 */
  uint8_t Data_Length;
/**
 *
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_l2cap_proc_timeout_event_rp0;

/**
 * The event is given by the L2CAP layer when a connection update request is
 * received from the peripheral. The upper layer which receives this event has
 * to respond by sending a @ref aci_l2cap_connection_parameter_update_resp
 * command.
 */
typedef PACKED(struct) aci_l2cap_connection_update_req_event_rp0_s {
/**
 * Handle of the connection related to this L2CAP procedure.
 */
  uint16_t Connection_Handle;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * Length of the L2CAP connection update request.
 */
  uint16_t L2CAP_Length;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Defines connection timeout parameter in the following manner: Timeout
 * Multiplier * 10ms.
 * Values:
 * - 10 (100 ms)  ... 3200 (32000 ms) 
 */
  uint16_t Timeout_Multiplier;
} aci_l2cap_connection_update_req_event_rp0;

/**
 * Event raised when an L2CAP channel using LE Credit Based Flow Control mode is
 * terminated.
 */
typedef PACKED(struct) aci_l2cap_cos_disconnection_complete_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
} aci_l2cap_cos_disconnection_complete_event_rp0;

/**
 * Event raised when an L2CAP_FLOW_CONTROL_CREDIT_IND is received from the peer,
 * which means that it is capable of receiving additional K-frames (for example
 * after it has processed one or more K-frames) in LE Credit Based Flow Control.
 */
typedef PACKED(struct) aci_l2cap_cos_flow_control_credit_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 * The number of additional k-frames that the peer's L2CAP layer entity can
 * receive.
 */
  uint16_t TX_Credits;
/**
 * Remaining number of K-frames that local L2CAP layer entity can currently send
 * to the peer.
 * Values:
 * - 1 ... 65535
 */
  uint16_t TX_Credit_Balance;
} aci_l2cap_cos_flow_control_credit_event_rp0;

/**
 * Event raised when an SDU to be transmitted has been processed by the local
 * L2CAP layer entity.
 */
typedef PACKED(struct) aci_l2cap_cos_sdu_data_tx_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 *
 */
  uint16_t SDU_Length;
/**
 * Remaining number of K-frames that local L2CAP layer entity can currently send
 * to the peer.
 */
  uint16_t TX_Credit_Balance;
} aci_l2cap_cos_sdu_data_tx_event_rp0;

/**
 * Event raised when an SDU has been received.
 */
typedef PACKED(struct) aci_l2cap_cos_sdu_data_rx_nwk_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 * Remaining number of K-frames that local L2CAP layer entity can currently
 * receive from the peer. If automatic management of credits is enabled, this
 * number is automatically changed after the SDU is extracted.
 */
  uint16_t RX_Credit_Balance;
/**
 *
 */
  uint16_t SDU_Length;
/**
 *
 */
  uint8_t SDU_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_l2cap_cos_sdu_data_rx_nwk_event_rp0;

/**
 * Event generated when receiving an L2CAP_CREDIT_BASED_RECONFIGURE_REQ or an
 * L2CAP_CREDIT_BASED_RECONFIGURE_RSP, to reconfigure one or more (up to 5)
 * L2CAP Enhanced Credit Based Flow Control channels.
 */
typedef PACKED(struct) aci_l2cap_cos_reconfiguration_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x00: L2CAP_ECFC_RECONFIGURE_REQ
 * - 0x01: L2CAP_ECFC_RECONFIGURE_RESP
 */
  uint8_t Event_Type;
/**
 * Result of the connection request if Event_Type is L2CAP_ECFC_CONN_RESP. To be
 * ignored if Event_Type is L2CAP_ECFC_CONN_REQ.
 * Values:
 * - 0x0000: L2CAP_RECONFIG_SUCCESSFUL
 * - 0x0001: L2CAP_RECONFIG_FAIL_MTU_REDUCTION_NOT_ALLOWED
 * - 0x0002: L2CAP_RECONFIG_FAIL_MPS_REDUCTION_NOT_ALLOWED
 * - 0x0003: L2CAP_RECONFIG_FAIL_INVALID_CID
 * - 0x0004: L2CAP_RECONFIG_FAIL_UNACCEPTABLE_PARAMETERS
 */
  uint16_t Result;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * The maximum SDU size (in octets) that the remote L2CAP layer entity can
 * receive on this channel after successful reconfiguration.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MTU;
/**
 * The maximum PDU payload size (in octets) that the remote L2CAP layer entity
 * can receive on this channel after successful reconfiguration.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MPS;
/**
 * Number of Channels that are going to be created.
 * Values:
 * - 0x01 ... 0x05
 */
  uint8_t CID_Count;
/**
 * Array of up to 5 two-octet values that represent the local channel endpoints
 * identifying the EATT channels to be reconfigured.
 */
  uint16_t Local_CID[(HCI_MAX_PAYLOAD_SIZE - 11)/sizeof(uint16_t)];
} aci_l2cap_cos_reconfiguration_event_rp0;

/**
 * This event is generated when the central rejects a L2CAP request.
 */
typedef PACKED(struct) aci_l2cap_command_reject_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * Reason
 */
  uint16_t Reason;
/**
 * Length of following data
 */
  uint8_t Data_Length;
/**
 * Data field associated with Reason
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_l2cap_command_reject_event_rp0;

/**
 * Event generated when a request is received from the peer to create one L2CAP
 * Credit Based Flow Control channel or one or more (up to 5) L2CAP Enhanced
 * Credit Based Flow Control channels.
 */
typedef PACKED(struct) aci_l2cap_cos_connection_req_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Type of channel: LE Credit Based Flow Control Mode or Enhanced Credit Based
 * Flow Control Mode.
 * Values:
 * - 0x00: L2CAP_CHANNEL_TYPE_LE_CFC
 * - 0x01: L2CAP_CHANNEL_TYPE_ECFC
 */
  uint8_t Channel_Type;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * Simplified Protocol/Service Multiplexer
 * Values:
 * - 0x0001 ... 0x00FF
 */
  uint16_t SPSM;
/**
 * The maximum SDU size (in octets) that the remote L2CAP layer entity can
 * receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MTU;
/**
 * The maximum PDU payload size (in octets) that the remote L2CAP layer entity
 * can receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MPS;
/**
 * The number of K-frames that can be sent to the L2CAP layer entity of the peer
 * device as soon as the L2CAP channel is established.
 */
  uint16_t Initial_Credits;
/**
 *
 */
  uint8_t CID_Count;
} aci_l2cap_cos_connection_req_event_rp0;

/**
 * Event generated when a response is received from the peer to create one L2CAP
 * Credit Based Flow Control channel or one or more (up to 5) L2CAP Enhanced
 * Credit Based Flow Control channels.
 */
typedef PACKED(struct) aci_l2cap_cos_connection_resp_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Type of channel: LE Credit Based Flow Control Mode or Enhanced Credit Based
 * Flow Control Mode.
 * Values:
 * - 0x00: L2CAP_CHANNEL_TYPE_LE_CFC
 * - 0x01: L2CAP_CHANNEL_TYPE_ECFC
 */
  uint8_t Channel_Type;
/**
 * The maximum SDU size (in octets) that the remote L2CAP layer entity can
 * receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MTU;
/**
 * The maximum PDU payload size (in octets) that the remote L2CAP layer entity
 * can receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MPS;
/**
 * The number of K-frames that can be sent to the L2CAP layer entity of the peer
 * device as soon as the L2CAP channel is established.
 */
  uint16_t Initial_Credits;
/**
 * Outcome of the connetion request.
 * Values:
 * - 0x0000: L2CAP_CONN_SUCCESSFUL
 * - 0x0002: L2CAP_CONN_FAIL_SPSM_NOT_SUPPORTED
 * - 0x0004: L2CAP_CONN_FAIL_INSUFFICIENT_RESOURCES
 * - 0x0005: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHENTICATION
 * - 0x0006: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHORIZATION
 * - 0x0007: L2CAP_CONN_FAIL_KEY_SIZE_TOO_SHORT
 * - 0x0008: L2CAP_CONN_FAIL_INSUFFICIENT_ENCRYPTION
 * - 0x0009: L2CAP_CONN_FAIL_INVALID_SOURCE_CID
 * - 0x000A: L2CAP_CONN_FAIL_SOURCE_CID_ALREADY_ALLOCATED
 * - 0x000B: L2CAP_CONN_FAIL_UNACCEPTABLE_PARAMETERS
 * - 0x000C: L2CAP_CONN_FAIL_INVALID_PARAMETERS
 * - 0x000D: L2CAP_CONN_FAIL_NO_INFO
 * - 0x000E: L2CAP_CONN_FAIL_AUTHENTICATION_PENDING
 * - 0x000F: L2CAP_CONN_FAIL_AUTHORIZATION_PENDING
 */
  uint16_t Result;
/**
 * Number of channels to be created which are present in the L2CAP Credit Based
 * Connection Request. The effective number of channels that will be opened can
 * be less than this value (see Local_CID) .
 * Values:
 * - 0x01 ... 0x05
 */
  uint8_t CID_Count;
/**
 * Array of up to 5 two-octet values that represent the local channel endpoints.
 */
  uint16_t CID[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(uint16_t)];
} aci_l2cap_cos_connection_resp_event_rp0;

/**
 * This event is generated to the application by the GATT server when a client
 * modifies any attribute on the server, as consequence of one of the following
 * GATT procedures: - write without response - signed write without response -
 * write characteristic value - write long characteristic value - reliable
 * write.
 */
typedef PACKED(struct) aci_gatt_srv_attribute_modified_event_rp0_s {
/**
 * The connection handle which modified the attribute.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute that was modified.
 */
  uint16_t Attr_Handle;
/**
 * Length of Attr_Data in octets
 */
  uint16_t Attr_Data_Length;
/**
 * A concatenation of Handle, Length and Values for each of the attributes being
 * notified.
 */
  uint8_t Attr_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_srv_attribute_modified_event_rp0;

/**
 * This event is generated by the client/server to the application on a GATT
 * timeout (30 seconds). This is a critical event that should not happen during
 * normal operating conditions. It is an indication of either a major disruption
 * in the communication link or a mistake in the application which does not
 * provide a reply to GATT procedures. After this event, the GATT channel is
 * closed and no more GATT communication can be performed. The applications is
 * exptected to issue an @ref aci_gap_terminate to disconnect from the peer
 * device.
 */
typedef PACKED(struct) aci_gatt_proc_timeout_event_rp0_s {
/**
 * Connection handle on which the GATT procedure has timed out
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
} aci_gatt_proc_timeout_event_rp0;

/**
 * This event is generated in response to an Exchange MTU request (local or from
 * the peer), which can happen only on an unenhaced ATT bearer. See
 * aci_gatt_clt_exchange_config().
 */
typedef PACKED(struct) aci_att_exchange_mtu_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * ATT_MTU value agreed between server and client. This is the minimum of the
 * Client Rx MTU and the Server Rx MTU.
 */
  uint16_t MTU;
} aci_att_exchange_mtu_resp_event_rp0;

/**
 * This event is generated in response to a Find Information Request during a
 * discovery procedure for all the characteristic descriptors. See
 * aci_gatt_clt_disc_all_char_desc() and Find Information Response in Bluetooth
 * Core spec.
 */
typedef PACKED(struct) aci_att_clt_find_info_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Format of the hanndle-uuid pairs
 */
  uint8_t Format;
/**
 * Length of Handle_UUID_Pair in octets
 */
  uint16_t Event_Data_Length;
/**
 * A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for
 * handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle,
 * 16 octets for UUIDs]
 */
  uint8_t Handle_UUID_Pair[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_att_clt_find_info_resp_event_rp0;

/**
 * This event is generated during a "discover service by UUID" procedure. See
 * aci_gatt_clt_disc_primary_service_by_uuid().
 */
typedef PACKED(struct) aci_att_clt_find_by_type_value_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Number of attribute, group handle pairs
 */
  uint8_t Num_of_Handle_Pair;
/**
 * See @ref Attribute_Group_Handle_Pair_t
 */
  packed_Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(packed_Attribute_Group_Handle_Pair_t)];
} aci_att_clt_find_by_type_value_resp_event_rp0;

/**
 * This event is generated in response to a ATT_READ_BY_TYPE_REQ, during a "find
 * included service" procedure or a "discover all characteristics" procedure.
 * See aci_gatt_clt_find_included_services() and
 * aci_gatt_clt_disc_all_char_of_service().
 */
typedef PACKED(struct) aci_att_clt_read_by_type_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The size of each attribute handle-value pair
 */
  uint8_t Handle_Value_Pair_Length;
/**
 * Length of Handle_Value_Pair_Data in octets
 */
  uint16_t Data_Length;
/**
 * Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of
 * handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length
 * - 2 octets) for Attribute Value]
 */
  uint8_t Handle_Value_Pair_Data[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_att_clt_read_by_type_resp_event_rp0;

/**
 * This event is generated in response to a Read Request. See
 * aci_gatt_clt_read().
 */
typedef PACKED(struct) aci_att_clt_read_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * The value of the attribute.
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_resp_event_rp0;

/**
 * This event can be generated during a read long characteristic value
 * procedure. See aci_gatt_clt_read_long().
 */
typedef PACKED(struct) aci_att_clt_read_blob_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * Part of the attribute value.
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_blob_resp_event_rp0;

/**
 * This event is generated in response to a Read Multiple Request. See
 * aci_gatt_clt_read_multiple_char_value().
 */
typedef PACKED(struct) aci_att_clt_read_multiple_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * A set of two or more values. A concatenation of attribute values for each of
 * the attribute handles in the request in the order that they were requested.
 */
  uint8_t Set_Of_Values[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_multiple_resp_event_rp0;

/**
 * This event is generated in response to a Read By Group Type Request, during a
 * "discover all primary services" procedure. See
 * aci_gatt_clt_disc_all_primary_services().
 */
typedef PACKED(struct) aci_att_clt_read_by_group_type_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The size of each attribute data
 */
  uint8_t Attribute_Data_Length;
/**
 * Length of Attribute_Data_List in octets
 */
  uint16_t Data_Length;
/**
 * Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of
 * attribute handle, end group handle, attribute value tuples: [2 octets for
 * Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4
 * octets) for Attribute Value]
 */
  uint8_t Attribute_Data_List[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_att_clt_read_by_group_type_resp_event_rp0;

/**
 * This event is generated in response to an ATT_PREPARE_WRITE_REQ during a
 * write long characteristic value procedure. See aci_gatt_clt_write_long().
 */
typedef PACKED(struct) aci_att_clt_prepare_write_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute to be written
 */
  uint16_t Attribute_Handle;
/**
 * The offset of the first octet to be written.
 */
  uint16_t Offset;
/**
 * Length of Part_Attribute_Value in octets
 */
  uint16_t Part_Attribute_Value_Length;
/**
 * The value of the attribute to be written
 */
  uint8_t Part_Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_att_clt_prepare_write_resp_event_rp0;

/**
 * This event is generated in response to an ATT Execute Write Request, during a
 * write long characteristic value procedure. See aci_gatt_clt_write_long().
 */
typedef PACKED(struct) aci_att_clt_exec_write_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
} aci_att_clt_exec_write_resp_event_rp0;

/**
 * This event is generated when an indication is received from the server.
 */
typedef PACKED(struct) aci_gatt_clt_indication_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute
 */
  uint16_t Attribute_Handle;
/**
 * Length of Attribute_Value in octets
 */
  uint16_t Attribute_Value_Length;
/**
 * The current value of the attribute
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_indication_event_rp0;

/**
 * This event is generated when a notification is received from the server.
 */
typedef PACKED(struct) aci_gatt_clt_notification_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute
 */
  uint16_t Attribute_Handle;
/**
 * Length of Attribute_Value in octets
 */
  uint16_t Attribute_Value_Length;
/**
 * The current value of the attribute
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_notification_event_rp0;

/**
 * This event is generated when a GATT client procedure completes either with
 * error or successfully.
 */
typedef PACKED(struct) aci_gatt_clt_proc_complete_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Error_Code;
} aci_gatt_clt_proc_complete_event_rp0;

/**
 * This event is generated when an Error Response is received from the server.
 * The error response can be given by the server at the end of one of the GATT
 * discovery procedures. This does not mean that the procedure ended with an
 * error, but this error event is part of the procedure itself.
 */
typedef PACKED(struct) aci_gatt_clt_error_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The request that generated this error response
 */
  uint8_t Req_Opcode;
/**
 * The attribute handle that generated this error response
 */
  uint16_t Attribute_Handle;
/**
 * The reason why the request has generated an error response (ATT error codes)
 * Values:
 * - 0x01: Invalid handle
 * - 0x02: Read not permitted
 * - 0x03: Write not permitted
 * - 0x04: Invalid PDU
 * - 0x05: Insufficient authentication
 * - 0x06: Request not supported
 * - 0x07: Invalid offset
 * - 0x08: Insufficient authorization
 * - 0x09: Prepare queue full
 * - 0x0A: Attribute not found
 * - 0x0B: Attribute not long
 * - 0x0C: Insufficient encryption key size
 * - 0x0D: Invalid attribute value length
 * - 0x0E: Unlikely error
 * - 0x0F: Insufficient encryption
 * - 0x10: Unsupported group type
 * - 0x11: Insufficient resources
 */
  uint8_t Error_Code;
} aci_gatt_clt_error_resp_event_rp0;

/**
 * This event can be generated during a "Discover Characteristics By UUID"
 * procedure or a "Read using Characteristic UUID" procedure. During a "Discover
 * Characteristics By UUID" procedure, Attribute_Value is a characteristic
 * declaration as defined in Bluetooth Core spec (vol.3, Part G, ch. 3.3.1),
 * i.e. it is composed by: Characteristic Properties (1 octet), Characteristic
 * Value Handle (2 octets) and Characteristic UUID (2 or 16 octets). During a
 * "Read using Characteristic UUID" procedure, Attribute_Value is the value of
 * the characteristic.
 */
typedef PACKED(struct) aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute
 */
  uint16_t Attribute_Handle;
/**
 * Length of Attribute_Value in octets
 */
  uint8_t Attribute_Value_Length;
/**
 * The attribute value will be a characteristic declaration as defined in
 * Bluetooth Core spec (vol.3, Part G, ch. 3.3.1), when a "Discover
 * Characteristics By UUID" has been started. It will be the value of the
 * Characteristic if a "Read using Characteristic UUID" has been performed.
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0;

/**
 * Each time Bluetooth stack raises the error code
 * BLE_STATUS_INSUFFICIENT_RESOURCES, aci_gatt_tx_pool_available_event() is
 * generated as soon as the available buffer size is greater than maximum ATT
 * MTU.
 */
typedef PACKED(struct) aci_gatt_tx_pool_available_event_rp0_s {
/**
 * Connection handle related to the request
 */
  uint16_t Connection_Handle;
/**
 * Not used.
 */
  uint16_t Available_Buffers;
} aci_gatt_tx_pool_available_event_rp0;

/**
 * This event is generated when the client has sent the confirmation to a
 * previously sent indication.
 */
typedef PACKED(struct) aci_gatt_srv_confirmation_event_rp0_s {
/**
 * Connection handle related to the event.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
} aci_gatt_srv_confirmation_event_rp0;

/**
 * This event is generated when an execute write request is received from the
 * peer. This happens when the client wants to write a long attribute (i.e. an
 * attribute with a size greater than ATT_MTU -3) or more than one attribute in
 * a single operation. The aci_gatt_srv_resp command must be sent to give a
 * response to the peer.
 */
typedef PACKED(struct) aci_att_srv_exec_write_req_event_rp0_s {
/**
 * Handle identifying the connection where the execute write operation has been
 * received.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * If 1, peer wants to execute all the queued writes. If 0, all queued writes
 * must be discarded.
 * Values:
 * - 0x00: FLUSH
 * - 0x01: EXECUTE
 */
  uint8_t Flags;
} aci_att_srv_exec_write_req_event_rp0;

/**
 * This event is generated if authorization is needed to access the attribute
 * value. aci_gatt_srv_authorize_resp_nwk command must be sent in response to
 * this event.
 */
typedef PACKED(struct) aci_gatt_srv_authorize_nwk_event_rp0_s {
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Conn_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 *
 */
  uint16_t Attr_Handle;
/**
 *
 * Values:
 * - 0x00: Read
 * - 0x10: Write Request
 * - 0x11: Write Command or Signed Write Command
 * - 0x12: Prepare Write Request
 */
  uint8_t Operation_Type;
/**
 * Offset from which the value needs to be read or write
 * Values:
 * - 0 ... 511
 */
  uint16_t Attr_Val_Offset;
/**
 * Length of Data field
 */
  uint8_t Data_Length;
/**
 * The data that the client has requested to write
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_srv_authorize_nwk_event_rp0;

/**
 * This event is generated in response to a Read Multiple Variable Request. See
 * aci_gatt_clt_read_multiple_var_len_char_value().
 */
typedef PACKED(struct) aci_att_clt_read_multiple_var_len_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * A set of two or more values. A concatenation of attribute values for each of
 * the attribute handles in the request in the order that they were requested.
 */
  uint8_t Set_Of_Values[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_multiple_var_len_resp_event_rp0;

/**
 * The LE Connection Complete event indicates to both of the Hosts forming the
 * connection that a new connection has been created. Upon the creation of the
 * connection a Connection_Handle shall be assigned by the Controller, and
 * passed to the Host in this event. If the connection establishment fails this
 * event shall be provided to the Host that had issued the LE_Create_Connection
 * command. This event indicates to the Host which issued a LE_Create_Connection
 * command and received a Command Status event if the connection establishment
 * failed or was successful. The Central_Clock_Accuracy parameter is only valid
 * for a peripheral. On a central, this parameter shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_connection_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Role of the local device in the connection.
 * Values:
 * - 0x00: Central
 * - 0x01: Peripheral
 */
  uint8_t Role;
/**
 * The address type of the peer device.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address or Random Device Address of the peer device
 */
  uint8_t Peer_Address[6];
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * Central clock accuracy. Only valid for a Peripheral.
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Central_Clock_Accuracy;
} hci_le_connection_complete_event_rp0;

/**
 * The LE Advertising Report event indicates that a Bluetooth device or multiple
 * Bluetooth devices have responded to an active scan or received some
 * information during a passive scan. The Controller may queue these advertising
 * reports and send information from multiple devices in one LE Advertising
 * Report event.
 */
typedef PACKED(struct) hci_le_advertising_report_event_rp0_s {
/**
 * Number of responses in this event.
 * Values:
 * - 0x01
 */
  uint8_t Num_Reports;
/**
 * See @ref Advertising_Report_t
 */
  packed_Advertising_Report_t Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Advertising_Report_t)];
} hci_le_advertising_report_event_rp0;

/**
 * The LE Connection Update Complete event is used to indicate that the
 * Controller process to update the connection has completed. On a peripheral,
 * if no connection parameters are updated, then this event shall not be issued.
 * On a central, this event shall be issued if the Connection_Update command was
 * sent.
 */
typedef PACKED(struct) hci_le_connection_update_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
} hci_le_connection_update_complete_event_rp0;

/**
 * The LE Read Remote Features Complete event is used to indicate the completion
 * of the process of the Controller obtaining the used features of the remote
 * Bluetooth device specified by the Connection_Handle event parameter.
 */
typedef PACKED(struct) hci_le_read_remote_features_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Bit Mask List of used LE features. For details see LE Link Layer
 * specification.
 */
  uint8_t LE_Features[8];
} hci_le_read_remote_features_complete_event_rp0;

/**
 * The LE Long Term Key Request event indicates that the central device is
 * attempting to encrypt or re-encrypt the link and is requesting the Long Term
 * Key from the Host. (See [Vol 6] Part B, Section 5.1.3).
 */
typedef PACKED(struct) hci_le_long_term_key_request_event_rp0_s {
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * 64-bit random number
 */
  uint8_t Random_Number[8];
/**
 * 16-bit encrypted diversifier
 */
  uint16_t Encrypted_Diversifier;
} hci_le_long_term_key_request_event_rp0;

/**
 * The LE Data Length Change event notifies the Host of a change to either the
 * maximum Payload length or the maximum transmission time of Data Channel PDUs
 * in either direction. The values reported are the maximum that will actually
 * be used on the connection following the change.
 */
typedef PACKED(struct) hci_le_data_length_change_event_rp0_s {
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * The maximum number of payload octets in a Link Layer Data Channel PDU that
 * the local Controller will send on this connection (connEffectiveMaxTxOctets
 * defined in [Vol 6] Part B, Section 4.5.10). Range 0x001B-0x00FB (0x0000 -
 * 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 */
  uint16_t MaxTxOctets;
/**
 * The maximum time that the local Controller will take to send a Link Layer
 * Data Channel PDU on this connection (connEffectiveMaxTx-Time defined in [Vol
 * 6] Part B, Section 4.5.10). Range 0x0148-0x0848 (0x0000 - 0x0127 and 0x0849 -
 * 0xFFFF Reserved for future use)
 */
  uint16_t MaxTxTime;
/**
 * The maximum number of payload octets in a Link Layer Data Channel PDU that
 * the local controller expects to receive on this connection
 * (connEfectiveMaxRxOctets defined in [Vol 6] Part B, Section 4.5.10). Range
 * 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 */
  uint16_t MaxRxOctets;
/**
 * The maximum time that the local Controller expects to take to receive a Link
 * Layer Data Channel PDU on this connection (connEffectiveMax-RxTime defined in
 * [Vol 6] Part B, Section 4.5.10). Range 0x0148-0x0848 (0x0000 - 0x0127 and
 * 0x0849 - 0xFFFF Reserved for future use)
 */
  uint16_t MaxRxTime;
} hci_le_data_length_change_event_rp0;

/**
 * This event is generated when local P-256 key generation is complete.
 */
typedef PACKED(struct) hci_le_read_local_p256_public_key_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Local P-256 public key.
 */
  uint8_t Local_P256_Public_Key[64];
} hci_le_read_local_p256_public_key_complete_event_rp0;

/**
 * This event indicates that LE Diffie Hellman key generation has been completed
 * by the Controller.
 */
typedef PACKED(struct) hci_le_generate_dhkey_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Diffie Hellman Key
 */
  uint8_t DHKey[32];
} hci_le_generate_dhkey_complete_event_rp0;

/**
 * The LE Enhanced Connection Complete event indicates to both of the Hosts
 * forming the connection that a new connection has been created. Upon the
 * creation of the connection a Connection_Handle shall be assigned by the
 * Controller, and passed to the Host in this event. If the connection
 * establishment fails, this event shall be provided to the Host that had issued
 * the LE_Create_Connection command. If this event is unmasked and LE Connection
 * Complete event is unmasked, only the LE Enhanced Connection Complete event is
 * sent when a new connection has been completed. This event indicates to the
 * Host that issued a LE_Create_Connection command and received a Command Status
 * event if the connection establishment failed or was successful. The
 * Central_Clock_Accuracy parameter is only valid for a peripheral. On a
 * central, this parameter shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_enhanced_connection_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Role of the local device in the connection.
 * Values:
 * - 0x00: Central
 * - 0x01: Peripheral
 */
  uint8_t Role;
/**
 * 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
 * Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
 * Identity Address (Corresponds to Resolved Private Address)
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address
 * - 0x03: Random (Static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Resolvable Private Address being used by the local device for this
 * connection. This is only valid when the Own_Address_Type is set to 0x02 or
 * 0x03. For other Own_Address_Type values, the Controller shall return all
 * zeros.
 */
  uint8_t Local_Resolvable_Private_Address[6];
/**
 * Resolvable Private Address being used by the peer device for this connection.
 * This is only valid for Peer_Address_Type 0x02 and 0x03. For other
 * Peer_Address_Type values, the Controller shall return all zeros.
 */
  uint8_t Peer_Resolvable_Private_Address[6];
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * Central clock accuracy. Only valid for a Peripheral.
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Central_Clock_Accuracy;
} hci_le_enhanced_connection_complete_event_rp0;

/**
 * The HCI_LE_Directed_Advertising_Report event indicates that directed
 * advertisements have been received where the advertiser is using a resolvable
 * private address for the TargetA field of the advertising PDU which the
 * Controller is unable to resolve and the Scanning_Filter_Policy is equal to
 * 0x02 or 0x03. Direct_Address_Type and Direct_Address specify the address the
 * directed advertisements are being directed to. Address_Type and Address
 * specify the address of the advertiser sending the directed advertisements.
 * The Controller may queue these advertising reports and send information from
 * multiple advertisers in one HCI_LE_Directed_Advertising_Report event. This
 * event shall only be generated if scanning was enabled using the
 * HCI_LE_Set_Scan_Enable command. It only reports advertising events that used
 * legacy advertising PDUs.
 */
typedef PACKED(struct) hci_le_directed_advertising_report_event_rp0_s {
/**
 * Number of responses in this event.
 * Values:
 * - 0x01
 */
  uint8_t Num_Reports;
/**
 * See @ref Direct_Advertising_Report_t
 */
  packed_Direct_Advertising_Report_t Direct_Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Direct_Advertising_Report_t)];
} hci_le_directed_advertising_report_event_rp0;

/**
 * The LE PHY Update Complete Event is used to indicate that the Controller has
 * changed the transmitter PHY or receiver PHY in use. If the Controller changes
 * the transmitter PHY, the receiver PHY, or both PHYs, this event shall be
 * issued. If an LE_Set_PHY command was sent and the Controller determines that
 * neither PHY will change as a result, it issues this event immediately.
 */
typedef PACKED(struct) hci_le_phy_update_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * The transmitter PHY for the connection
 * Values:
 * - 0x01: The transmitter PHY for the connection is LE 1M
 * - 0x02: The transmitter PHY for the connection is LE 2M
 * - 0x03: The transmitter PHY for the connection is LE Coded
 */
  uint8_t TX_PHY;
/**
 * The receiver PHY for the connection
 * Values:
 * - 0x01: The receiver PHY for the connection is LE 1M
 * - 0x02: The receiver PHY for the connection is LE 2M
 * - 0x03: The receiver PHY for the connection is LE Coded
 */
  uint8_t RX_PHY;
} hci_le_phy_update_complete_event_rp0;

/**
 * The LE Extended Advertising Report event indicates that one or more Bluetooth
 * devices have responded to an active scan or have broadcast advertisements
 * that were received during a passive scan. The Controller may coalesce
 * multiple advertising reports from the same or different advertisers into a
 * single LE Extended Advertising Report event, provided all the parameters from
 * all the advertising reports fit in a single HCI event. This event shall only
 * be generated if scanning was enabled using the LE Set Extended Scan Enable
 * command. It reports advertising events using either legacy or extended
 * advertising PDUs. The Controller may split the data from a single
 * advertisement (whether one PDU or several) into several reports. If so, each
 * report except the last shall have an Event_Type with a data status field of
 * "incomplete, more data to come", while the last shall have the value
 * "complete"; the Address_Type, Address, Advertising_SID, Primary_PHY, and
 * Secondary_PHY fields shall be the same in all the reports. When a scan
 * response is received, bits 0-2 and 4 of the event type shall indicate the
 * properties of the original advertising event. An Event_Type with a data
 * status field of "incomplete, data truncated" indicates that the Controller
 * attempted to receive an AUX_CHAIN_IND PDU but was not successful.
 */
typedef PACKED(struct) hci_le_extended_advertising_report_event_rp0_s {
/**
 * Number of separate reports in the event
 * Values:
 * - 0x01 ... 0x0A
 */
  uint8_t Num_Reports;
/**
 * See @ref Extended_Advertising_Report_t
 */
  packed_Extended_Advertising_Report_t Extended_Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Extended_Advertising_Report_t)];
} hci_le_extended_advertising_report_event_rp0;

/**
 * The LE Periodic Advertising Report event indicates that the Controller has
 * received a Periodic Advertising packet. The Sync_Handle parameter indicates
 * the identifier for the periodic advertisements specified by the Advertising
 * SID subfield of the ADI field in the ADV_EXT_IND PDU. The Controller may
 * split the data from a single periodic advertisement (whether one PDU or
 * several) into several reports. If so, each report except the last shall have
 * a Data_Status of "incomplete, more data to come", while the last shall have
 * the value "complete". A Data_Status of "incomplete, data truncated" indicates
 * that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not
 * successful. The Unused parameter shall be set to 0xFF by the Controller and
 * ignored by the Host.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_established_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Advertising SID subfield in the ADI field of the PDU
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID subfield in the ADI field of the PDU
 * - 0x10 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_SID;
/**
 * Advertising Adress Type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved PrivateAddress)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * Advertiser PHY
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 * - 0x04 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic Advertising Interval Time = N * 1.25 ms Time Range: 7.5 ms to
 * 81.91875 s
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 * - 0x08 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_Clock_Accuracy;
} hci_le_periodic_advertising_sync_established_event_rp0;

/**
 * The LE Periodic Advertising Report event indicates that the Controller has
 * received a Periodic Advertising packet. The Sync_Handle parameter indicates
 * the identifier for the periodic advertisements specified by the Advertising
 * SID subfield of the ADI field in the ADV_EXT_IND PDU. The Controller may
 * split the data from a single periodic advertisement (whether one PDU or
 * several) into several reports. If so, each report except the last shall have
 * a Data_Status of "incomplete, more data to come", while the last shall have
 * the value "complete". A Data_Status of "incomplete, data truncated" indicates
 * that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not
 * successful. The Unused parameter shall be set to 0xFF by the Controller and
 * ignored by the Host.
 */
typedef PACKED(struct) hci_le_periodic_advertising_report_event_rp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * TX Power. Units: dBm
 * Values:
 * - -127 ... 126
 * - 127: NA
 */
  int8_t TX_Power;
/**
 * RSSI value Units: dBm
 * Values:
 * - -127 ... 20: RSSI value
 * - 127: RSSI is not available
 */
  int8_t RSSI;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * - 0xFF: No Constant Tone Extension
 */
  uint8_t CTE_Type;
/**
 * Data Status
 * Values:
 * - 0x00: Data complete
 * - 0x01: Data incomplete, more data to come
 * - 0x02: Data incomplete, data truncated, no more to come
 * - 0x03 ... 0xFF: Reserved for future use
 */
  uint8_t Data_Status;
/**
 * Length of the Data field
 * Values:
 * - 0 ... 247: Length of the Data field
 * - 248 ... 255: Reserved for future use
 */
  uint8_t Data_Length;
/**
 * Data received from a Periodic Advertising packet
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_periodic_advertising_report_event_rp0;

/**
 * The LE Periodic Advertising Sync Lost event indicates that the Controller has
 * not received a Periodic Advertising packet identified by Sync_Handle within
 * the timeout period.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_lost_event_rp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_sync_lost_event_rp0;

/**
 * The LE Advertising Set Terminated event indicates that the Controller has
 * terminated advertising in the advertising sets specified by the
 * Advertising_Handle parameter. This event shall be generated every time
 * connectable advertising in an advertising set results in a connection being
 * created. This event shall only be generated if advertising was enabled using
 * the LE Set Extended Advertising Enable command. The Connection_Handle
 * parameter is only valid when advertising ends because a connection was
 * created. If the Max_Extended_Advertising_Events parameter in the
 * LE_Set_Extended_Advertising_Enable command was non-zero, the
 * Num_Completed_Extended_Advertising_Events parameter shall be set to the
 * number of completed extended advertising events the Controller had
 * transmitted when either the duration elapsed or the maximum number of
 * extended advertising events was reached; otherwise it shall be set to zero.
 * If advertising has terminated as a result of the advertising duration
 * elapsing, the Status parameter shall be set to the error code Advertising
 * Timeout (0x3C). If advertising has terminated because the
 * Max_Extended_Advertising_Events was reached, the Status parameter shall be
 * set to the error code Limit Reached (0x43).
 */
typedef PACKED(struct) hci_le_advertising_set_terminated_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Advertising handle in which advertising has ended
 * Values:
 * - 0x00 ... 0xEF: Advertising_Handle in which advertising has ended
 * - 0xF0 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_Handle;
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * Number of completed extended advertising events transmitted by the Controller
 */
  uint8_t Num_Completed_Extended_Advertising_Events;
} hci_le_advertising_set_terminated_event_rp0;

/**
 * The LE Scan Request Received event indicates that a SCAN_REQ PDU or an
 * AUX_SCAN_REQ PDU has been received by the advertiser. The request contains a
 * device address from a scanner that is allowed by the advertising filter
 * policy. The advertising set is identified by Advertising_Handle. This event
 * shall only be generated if advertising was enabled using the LE Set Extended
 * Advertising Enable command. The Scanner_Address_Type and Scanner_Address
 * indicates the type of the address and the address of the scanner device.
 */
typedef PACKED(struct) hci_le_scan_request_received_event_rp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 * - 0xF0 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_Handle;
/**
 * Scanner address  type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved Private
Address)
 * - 0x04 ... 0xFF: Reserved for future use
 */
  uint8_t Scanner_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the advertising device
 */
  uint8_t Scanner_Address[6];
} hci_le_scan_request_received_event_rp0;

/**
 * The LE Channel Selection Algorithm Event indicates which channel selection
 * algorithm is used on a data channel connection (see [Vol 6] Part B, Section
 * 4.5.8).
 */
typedef PACKED(struct) hci_le_channel_selection_algorithm_event_rp0_s {
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * Channel selection algorithm to be  used on a data channel connection
 * Values:
 * - 0x00: LE Channel Selection Algorithm #1 is used
 * - 0x01: LE Channel Selection Algorithm #2 is used
 * - 0x02 ... 0xFF: Reserved for future use
 */
  uint8_t Channel_Selection_Algorithm;
} hci_le_channel_selection_algorithm_event_rp0;

/**
 * The HCI_LE_Connectionless_IQ_Report event is used by the Controller to report
 * IQ information from the Constant Tone Extension of a received advertising
 * packet forming part of the periodic advertising train identified by
 * Sync_Handle and to report IQ information from the Constant Tone Extension of
 * a received Test Mode packet (see Section 7.8.28). The index of the channel on
 * which the packet was received, the RSSI of the packet (excluding the Constant
 * Tone Extension), the ID of the antenna on which this was measured, the type
 * of Constant Tone Extension, the value of paEventCounter, and the IQ samples
 * of the Constant Tone Extension of the advertisement are reported in the
 * corresponding parameters. For any given sample, either both or neither of
 * I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations parameter
 * specifies the sampling rate used by the Controller. The Packet_Status
 * parameter indicates whether the received packet had a valid CRC and, if not,
 * whether the Controller has determined the position and size of the Constant
 * Tone Extension using the Length and CTETime fields. Note: A Controller is not
 * required to generate this event for packets that have a bad CRC. The Constant
 * Tone Extension format is defined in [Vol 6] Part B, Section 2.5.1. If the PDU
 * contains AdvData, then the HCI_LE_Periodic_Advertising_Report event shall be
 * generated before this event. The Controller is not required to generate this
 * event for a Constant Tone Extension with a type that it does not support.
 * This event is also used by the Controller to report that it has insufficient
 * resources to report IQ samples for all received Constant Tone Extensions and
 * has failed to sample at least once. In this case Packet_Status shall be set
 * to 0xFF and Sample_Count to 0x00.
 */
typedef PACKED(struct) hci_le_connectionless_iq_report_event_rp0_s {
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 * - 0x0FFF: TEST_SYNC_HANDLE
 */
  uint16_t Sync_Handle;
/**
 * 0x25-0x27 can be used only for packets generated during test modes.
 * Values:
 * - 0x00 ... 0x27: The index of the channel on which the packet was received.
 */
  uint8_t Channel_Index;
/**
 * RSSI of the packet. Units: 0.1 dBm.
 * Values:
 * - -1270 ... 200
 */
  int16_t RSSI;
/**
 * Antenna ID
 */
  uint8_t RSSI_Antenna_ID;
/**
 * Type of Constant Tone Extension.
 * Values:
 * - 0x00: AoA_CTE
 * - 0x01: AoD_CTE_1us
 * - 0x02: AoD_CTE_2us
 */
  uint8_t CTE_Type;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 * It indicates whether the received packet had a valid CRC and, if not, whether
 * the Controller has determined the position and size of the Constant Tone
 * Extension using the Length and CTETime fields. 0x00 - CRC was correct;  0x01
 * - CRC was incorrect and the Length and CTETime fields of the packet were used
 * to determine sampling points;  0x02 - CRC was incorrect but the Controller
 * has determined the position and length of the Constant Tone Extension in some
 * other way;  0xFF - Insufficient resources to sample (Channel_Index, CTE_Type,
 * and Slot_Durations invalid).
 * Values:
 * - 0x00: CRC_OK
 * - 0x01: CRC_ERROR_1
 * - 0x02: CRC_ERROR_2
 * - 0xFF: NO_SAMPLES
 */
  uint8_t Packet_Status;
/**
 * The value of paEventCounter (see [Vol 6] Part B, Section 4.4.2.1) for the
 * reported AUX_SYNC_IND PDU
 */
  uint16_t Periodic_Event_Counter;
/**
 * Total number of sample pairs (there shall be the same number of I samples and
 * Q samples). Note: This number is dependent on the switch and sample slot
 * durations used.
 * Values:
 * - 0x00
 * - 0x09 ... 0x52
 */
  uint8_t Sample_Count;
/**
 * See @ref Samples_t
 */
  packed_Samples_t Samples[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(packed_Samples_t)];
} hci_le_connectionless_iq_report_event_rp0;

/**
 * The HCI_LE_Connection_IQ_Report event is used by the Controller to report the
 * IQ samples from the Constant Tone Extension of a received packet (see [Vol 6]
 * Part B, Section 2.4.2.26). The Connection_Handle parameter identifies the
 * connection that corresponds to the reported information. The receiver PHY,
 * the index of the data channel, the RSSI value of the packet (excluding the
 * Constant Tone Extension), the ID of the antenna on which this was measured,
 * the type of Constant Tone Extension, the value of connEventCounter, and the
 * IQ samples of the Constant Tone Extension of the received packet are reported
 * in the corresponding parameters. For any given sample, either both or neither
 * of I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations parameter
 * specifies the sampling rate used by the Controller. The Packet_Status
 * parameter indicates whether the received packet had a valid CRC and, if not,
 * whether the Controller has determined the position and size of the Constant
 * Tone Extension using the Length and CTETime fields. Note: A Controller is not
 * required to generate this event for packets that have a bad CRC. This event
 * is also used by the Controller to report that it has insufficient resources
 * to report IQ samples for all received Constant Tone Extensions and has failed
 * to sample at least once. In this case Packet_Status shall be set to 0xFF and
 * Sample_Count to 0x00. The Constant Tone Extension format is defined in [Vol
 * 6] Part B, Section 2.1.5.
 */
typedef PACKED(struct) hci_le_connection_iq_report_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x01: The receiver PHY for the connection is LE 1M
 * - 0x02: The receiver PHY for the connection is LE 2M
 */
  uint8_t RX_PHY;
/**
 *
 * Values:
 * - 0x00 ... 0x24: The index of the data channel on which the Data Physical Channel PDU was received.
 */
  uint8_t Data_Channel_Index;
/**
 * RSSI of the packet. Units: 0.1 dBm.
 * Values:
 * - -1270 ... 200
 */
  int16_t RSSI;
/**
 * ID of the antenna on which the RSSI is measured
 */
  uint8_t RSSI_Antenna_ID;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t CTE_Type;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 *
 * Values:
 * - 0x00: CRC was correct
 * - 0x01: CRC was incorrect and the Length and CTETime fields of the packet were used to determine sampling points
 * - 0x02: CRC was incorrect but the Controller has determined the position and length of the Constant Tone Extension in some other way
 * - 0xFF: Insufficient resources to sample (Channel_Index, CTE_Type, and Slot_Durations invalid).
 */
  uint8_t Packet_Status;
/**
 * The value of connEventCounter (see [Vol 6] Part B, Section 4.5.1) for the
 * reported PDU
 */
  uint16_t Connection_Event_Counter;
/**
 * Total number of sample pairs.
 * Values:
 * - 0x00
 * - 0x09 ... 0x52
 */
  uint8_t Sample_Count;
/**
 * See @ref Samples_t
 */
  packed_Samples_t Samples[(HCI_MAX_PAYLOAD_SIZE - 13)/sizeof(packed_Samples_t)];
} hci_le_connection_iq_report_event_rp0;

/**
 * This event is used by the Controller to report an issue following a request
 * to a peer device to reply with a packet containing an LL_CTE_RSP PDU and a
 * Constant Tone Extension. It shall be generated if the packet containing the
 * LL_CTE_RSP PDU sent in response did not contain a Constant Tone Extension or
 * if the peer rejected the request. It shall not be generated if the packet
 * containing the LL_CTE_RSP PDU had a CRC error or if the procedure response
 * timeout timer (see [Vol 6] Part B, Section 5.2) expired.
 */
typedef PACKED(struct) hci_le_cte_request_failed_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_cte_request_failed_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is used by the
 * Controller to report that it has received periodic advertising
 * synchronization information from the device referred to by the
 * Connection_Handle parameter and either successfully synchronized to the
 * periodic advertising train or timed out while attempting to synchronize. The
 * Status will be zero if it successfully synchronized and non-zero otherwise.
 * The Service_Data value is provided by the Host of the device sending the
 * information. The Sync_Handle identifies the periodic advertising in
 * subsequent commands and events and shall be assigned by the Controller. The
 * remaining parameters provide information about the periodic advertising (see
 * Section 7.7.65.14). If Status is non-zero, all parameter values are valid
 * except Sync_Handle, which the Host shall ignore. Note: If the Controller is
 * already synchronized to the periodic advertising train described in the
 * received information, no event will be generated.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_received_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * A value provided by the peer device
 */
  uint16_t Service_data;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 *
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID used to advertise the periodic advertising
 */
  uint8_t Advertising_SID;
/**
 *
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved Private Address)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 *
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic advertising interval. Time = N * 1.25 ms; Time Range: 7.5ms to
 * 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 60 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Advertiser_Clock_Accuracy;
} hci_le_periodic_advertising_sync_transfer_received_event_rp0;

/**
 * The HCI_LE_CIS_Established event indicates that a CIS has been established,
 * was considered lost before being established, or (on the Central) was
 * rejected by the Peripheral. It is generated by the Controller in the Central
 * and Peripheral. The Connection_Handle parameter shall be set to the value
 * provided in the HCI_LE_Create_CIS command on the Central and in the
 * HCI_LE_CIS_Request event on the Peripheral. The CIG_Sync_Delay parameter is
 * the maximum time, in microseconds, for transmission of PDUs of all CISes in a
 * CIG event (see [Vol 6] Part B, Section 4.5.14.1). The CIS_Sync_Delay
 * parameter is the maximum time, in microseconds, for transmission of PDUs of
 * the specified CIS in a CIG event (see [Vol 6] Part B, Section 4.5.14.1). The
 * Transport_Latency_C_To_P and Transport_Latency_P_To_C parameters are the
 * actual transport latencies, in microseconds, as described in [Vol 6] Part G,
 * Section 3.2.1 and [Vol 6] Part G, Section 3.2.2. The PHY_C_To_P parameter
 * indicates the PHY selected for packets from the Central to Peripheral. The
 * PHY_P_To_C parameter indicates the PHY selected for packets from the
 * Peripheral to Central. The NSE, BN_C_To_P, BN_P_To_C, FT_C_To_P, FT_P_To_C,
 * Max_PDU_- C_To_P, Max_PDU_P_To_C, and ISO_Interval parameters are the
 * corresponding parameters of the CIS (see [Vol 6] Part B, Section 4.5.13.1).
 * If this event is generated on the Peripheral with a non-zero status, the
 * Controller shall delete the Connection_Handle and any associated ISO data
 * paths.
 */
typedef PACKED(struct) hci_le_cis_established_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The maximum time, in microseconds, for transmission of PDUs of all CISes in a
 * CIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t CIG_Sync_Delay[3];
/**
 * The maximum time, in microseconds, for transmission of PDUs of the specified
 * CIS in a CIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t CIS_Sync_Delay[3];
/**
 * The actual transport latency, in microseconds, from Central to Peripheral.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_C_To_P[3];
/**
 * The actual transport latency, in microseconds, from Peripheral to Central.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_P_To_C[3];
/**
 * The transmitter PHY of packets from the Central.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY_C_To_P;
/**
 * The transmitter PHY of packets from the Peripheral.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY_P_To_C;
/**
 * Maximum number of subevents in each isochronous event.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t NSE;
/**
 * The burst number for Central to Peripheral transmission.
 * Values:
 * - 0x00: No data
 * - 0x01 ... 0x0F
 */
  uint8_t BN_C_To_P;
/**
 * The burst number for Peripheral to Central transmission.
 * Values:
 * - 0x00: No data
 * - 0x01 ... 0x0F
 */
  uint8_t BN_P_To_C;
/**
 * The flush timeout, in multiples of the ISO_Interval for the CIS, for each
 * payload sent from the Central to the Peripheral.
 * Values:
 * - 0x01 ... 0xFF
 */
  uint8_t FT_C_To_P;
/**
 * The flush timeout, in multiples of the ISO_Interval for the CIS, for each
 * payload sent from the Peripheral to the Central.
 * Values:
 * - 0x01 ... 0xFF
 */
  uint8_t FT_P_To_C;
/**
 * Maximum size, in octets, of the payload from Central to Peripheral.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU_C_To_P;
/**
 * Maximum size, in octets, of the payload from Peripheral to Central.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU_P_To_C;
/**
 * The time between two consecutive CIS anchor points. Time = N * 1.25 ms.
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t ISO_Interval;
} hci_le_cis_established_event_rp0;

/**
 * The HCI_LE_CIS_Request event indicates that a Controller has received a
 * request to establish a CIS. If the Controller receives such a request while
 * the HCI_LE_CIS_Request event is masked away, it shall reject it. Otherwise
 * the Controller shall assign a connection handle for the requested CIS and
 * send the handle in the CIS_Connection_Handle parameter of the event. When the
 * Host receives this event it shall respond with either an
 * HCI_LE_Accept_CIS_Request command or an HCI_LE_Reject_CIS_Request command
 * before the timer Connection_Accept_Timeout expires. If it does not, the
 * Controller shall reject the request and generate an HCI_LE_CIS_Established
 * event with the status Connection Accept Timeout Exceeded (0x10). The
 * ACL_Connection_Handle is the connection handle of the ACL connection that is
 * associated with the requested CIS. The CIG_ID parameter contains the
 * identifier of the CIG that contains the requested CIS. This parameter is sent
 * by the Central in the request to establish the CIS. The CIS_ID parameter
 * contains the identifier of the requested CIS. This parameter is sent by the
 * Central in the request to establish the CIS.
 */
typedef PACKED(struct) hci_le_cis_request_event_rp0_s {
/**
 * Connection handle of the ACL.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t ACL_Connection_Handle;
/**
 * Connection handle of the CIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t CIS_Connection_Handle;
/**
 * Identifier of the CIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIG_ID;
/**
 * Identifier of the CIS.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIS_ID;
} hci_le_cis_request_event_rp0;

/**
 * The HCI_LE_Create_BIG_Complete event indicates that the HCI_LE_Create_BIG
 * command has completed.
 */
typedef PACKED(struct) hci_le_create_big_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * The maximum time in microseconds for transmission of PDUs of all BISes in a
 * BIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t BIG_Sync_Delay[3];
/**
 * The maximum delay time, in microseconds, for transmission of SDUs of all
 * BISes in a BIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_BIG[3];
/**
 * The PHY used to create the BIG.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY;
/**
 * The number of subevents in each BIS event in the BIG.
 * Values:
 * - 0x01 ... 0x1E
 */
  uint8_t NSE;
/**
 * The number of new payloads in each BIS event.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * Offset used for pre-transmissions.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * The number of times a payload is transmitted in a BIS event.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Maximum size, in octets, of the payload.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * The time between two consecutive BIG anchor points. Time = N * 1.25 ms.
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t ISO_Interval;
/**
 * Total number of BISes in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * The connection handles of the BISes in the BIG.
 */
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 18)/sizeof(uint16_t)];
} hci_le_create_big_complete_event_rp0;

/**
 * The HCI_LE_Terminate_BIG_Complete event indicates that the transmission of
 * all the BISes in the BIG are terminated.
 */
typedef PACKED(struct) hci_le_terminate_big_complete_event_rp0_s {
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Reason for termination. See Error Codes.
 */
  uint8_t Reason;
} hci_le_terminate_big_complete_event_rp0;

/**
 * The HCI_LE_BIG_Sync_Established event indicates that the
 * HCI_LE_BIG_Create_Sync command has completed.
 */
typedef PACKED(struct) hci_le_big_sync_established_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * The maximum delay time, in microseconds, for transmission of SDUs of all
 * BISes in a BIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_BIG[3];
/**
 * The number of subevents in each BIS event in the BIG.
 * Values:
 * - 0x01 ... 0x1E
 */
  uint8_t NSE;
/**
 * The number of new payloads in each BIS event.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * Offset used for pre-transmissions.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * The number of times a payload is transmitted in a BIS event.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Maximum size, in octets, of the payload.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * The time between two consecutive BIG anchor points. Time = N * 1.25 ms.
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t ISO_Interval;
/**
 * Total number of BISes in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * The connection handles of the BISes in the BIG.
 */
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 14)/sizeof(uint16_t)];
} hci_le_big_sync_established_event_rp0;

/**
 * The HCI_LE_BIG_Sync_Lost event indicates that the Controller has not received
 * any PDUs on a BIG within the timeout period BIG_Sync_Timeout or the BIG has
 * been terminated by the remote device.
 */
typedef PACKED(struct) hci_le_big_sync_lost_event_rp0_s {
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Reason for termination. See Error Codes.
 */
  uint8_t Reason;
} hci_le_big_sync_lost_event_rp0;

/**
 * The HCI_LE_Request_Peer_SCA_Complete event indicates that the
 * HCI_LE_Request_Peer_SCA command has been completed. The Peer_Clock_Accuracy
 * parameter contains the sleep clock accuracy of the peer. The
 * Connection_Handle is the connection handle of the ACL connection in which the
 * HCI_LE_Request_Peer_SCA command is issued.
 */
typedef PACKED(struct) hci_le_request_peer_sca_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the ACL.
 */
  uint16_t Connection_Handle;
/**
 * Sleep clock accuracy of the peer.
 * Values:
 * - 0x00: 251 ppm to 500 ppm
 * - 0x01: 151 ppm to 250 ppm
 * - 0x02: 101 ppm to 150 ppm
 * - 0x03: 76 ppm to 100 ppm
 * - 0x04: 51 ppm to 75 ppm
 * - 0x05: 31 ppm to 50 ppm
 * - 0x06: 21 ppm to 30 ppm
 * - 0x07: 0 ppm to 20 ppm
 */
  uint8_t Peer_Clock_Accuracy;
} hci_le_request_peer_sca_complete_event_rp0;

/**
 * Report a path loss threshold crossing on the ACL connection identified by the
 * Connection_Handle parameter.
 */
typedef PACKED(struct) hci_le_path_loss_threshold_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Current path loss (always zero or positive). Units: dB.
 * Values:
 * - 0 ... 254
 * - 255: NA
 */
  uint8_t Current_Path_Loss;
/**
 * The Zone_Entered parameter indicates which zone was entered.
 * Values:
 * - 0x00: LOW_ZONE
 * - 0x01: MIDDLE_ZONE
 * - 0x02: HIGH_ZONE
 */
  uint8_t Zone_Entered;
} hci_le_path_loss_threshold_event_rp0;

/**
 * Report the transmit power level on the ACL connection identified by the
 * Connection_Handle parameter.
 */
typedef PACKED(struct) hci_le_transmit_power_reporting_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The reason why the event was sent and the device whose transmit power level
 * is being reported. - 0x00: Local transmit power changed - 0x01: Remote
 * transmit power changed - 0x02: HCI_LE_Read_Remote_Transmit_Power_Level
 * command completed
 * Values:
 * - 0x00: LOCAL_TX_POWER_CHANGE
 * - 0x01: REMOTE_TX_POWER_CHANGE
 * - 0x02: READ_REMOTE_TX_POWER_COMPLETE
 */
  uint8_t Reason;
/**
 * PHY associated with the connection  (not necessarily the currently used one).
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 * The transmit power level for the PHY (dBm).
 * Values:
 * - -127 ... 20
 * - 126: POWER_NOT_MANAGED
 * - 127: POWER_NA
 */
  int8_t Transmit_Power_Level;
/**
 * It indicates whether the transmit power level that is being reported has
 * reached its minimum and/or maximum level. Transmit_Power_Level_Flag shall be
 * ignored if the Transmit_Power_Level parameter is set to 0x7E or 0x7F.
 * Flags:
 * - 0x01: MIN_TX_POWER_BIT
 * - 0x02: MAX_TX_POWER_BIT
 */
  uint8_t Transmit_Power_Level_Flag;
/**
 * The Delta parameter is set to the change in power level for the transmitter
 * being reported, whenever it changes its transmit power level. Delta shall be
 * ignored if the Transmit_Power_Level parameter is set to 0x7E.
 * Values:
 * - 0 ... 126
 * - 127: NA
 */
  int8_t Delta;
} hci_le_transmit_power_reporting_event_rp0;

/**
 * The HCI_LE_BIGInfo_Advertising_Report event indicates that the Controller has
 * received an Advertising PDU that contained a BIGInfo field. If the Controller
 * also generates an HCI_LE_Periodic_Advertising_Report event, the
 * HCI_LE_BIGInfo_Advertising_Report event shall immediately follow that event.
 * An HCI_LE_BIGInfo_Advertising_Report event shall be generated even if the
 * Controller is already synchronized to the BIG. The Sync_Handle parameter
 * shall identify the periodic advertising train containing the BIGInfo field
 * and shall be the same as the corresponding field in the
 * HCI_LE_Periodic_Advertising_Report event if one is generated. The Num_BIS,
 * NSE, ISO_Interval, BN, PTO, IRC, Max_PDU, SDU_Interval, Max_SDU, PHY, and
 * Framing parameters correspond to the associated fields in the BIGInfo field
 * of the Advertising PDU. If the BIGInfo field indicates that the corresponding
 * BIG is encrypted, the Encryption parameter shall be set to 0x01. Otherwise,
 * the Encryption parameter shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_biginfo_advertising_report_event_rp0_s {
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Value of the Num_BIS subfield of the BIGInfo field.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * Value of the NSE subfield of the BIGInfo field.
 */
  uint8_t NSE;
/**
 * Value of the ISO_Interval subfield of the BIGInfo field.
 */
  uint16_t ISO_Interval;
/**
 * Value of the BN subfield of the BIGInfo field.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * Value of the PTO subfield of the BIGInfo field.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * Value of the IRC subfield of the BIGInfo field.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Value of the Max_PDU subfield of the BIGInfo.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * Value of the SDU_Interval subfield of the BIGInfo field.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval[3];
/**
 * Value of the Max_SDU subfield of the BIGInfo field in the Advertising PDU.
 * Values:
 * - 0x0001 ... 0x0FFF
 */
  uint16_t Max_SDU;
/**
 * The PHY on which the BIG is transmitted.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY;
/**
 * If BIG carries encrypted (1) or unencrypted (0) data.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Framing;
/**
 * If BIG carries encrypted (1) or unencrypted (0) data.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Encryption;
} hci_le_biginfo_advertising_report_event_rp0;

/**
 * The HCI_LE_Subrate_Change event is used to indicate that a Connection Subrate
 * Update procedure has completed and some parameters of the specified
 * connection have changed. This event shall be issued if the
 * HCI_LE_Subrate_Request command was issued by the Host or the parameters are
 * updated successfully following a request from the peer device. If no
 * parameters are updated following a request from the peer device or the
 * parameters were changed using the Connection Update procedure, then this
 * event shall not be issued.
 */
typedef PACKED(struct) hci_le_subrate_change_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle identifing the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * New subrate factor applied to the specified underlying connection interval.
 * Values:
 * - 0x0001 ... 0x01F4
 */
  uint16_t Subrate_Factor;
/**
 * New Peripheral latency for the connection in number of subrated connection
 * events,
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Number of underlying connection events to remain active after a packet
 * containing a Link Layer PDU with a non-zero Length field is sent or received.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Continuation_Number;
/**
 * New supervision timeout for this connection. Time = N x 10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
} hci_le_subrate_change_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Sync_Established event indicates that the
 * Controller has received the first periodic advertising packet from an
 * advertiser after the HCI_LE_Periodic_Advertising_Create_Sync command has been
 * sent to the Controller. The Sync_Handle parameter identifies the periodic
 * advertising train in subsequent commands and events and shall be assigned by
 * the Controller. The Advertising_SID parameter is set to the value of the
 * Advertising SID subfield in the ADI field of the advertising PDU referring to
 * the periodic advertising train. The Advertiser_Address_Type and
 * Advertiser_Address parameters specify the address of the periodic advertiser.
 * The Advertiser_PHY parameter specifies the PHY used for the periodic
 * advertising. The Periodic_Advertising_Interval parameter specifies the
 * interval between the periodic advertising events. The
 * Advertiser_Clock_Accuracy parameter specifies the accuracy of the periodic
 * advertiser's clock. If the periodic advertising has subevents or response
 * slots, then the Num_- Subevents, Subevent_Interval, Response_Slot_Delay, and
 * Response_Slot_- Spacing specify the parameters for these subevents, otherwise
 * these values shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_established_v2_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Advertising SID subfield in the ADI field of the PDU
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID subfield in the ADI field of the PDU
 * - 0x10 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_SID;
/**
 * Advertising Adress Type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved PrivateAddress)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * Advertiser PHY
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 * - 0x04 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic Advertising Interval Time = N * 1.25 ms Time Range: 7.5 ms to
 * 81.91875 s
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 * - 0x08 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_Clock_Accuracy;
/**
 * Number of subevents.
 * Values:
 * - 0x00 ... 0x80
 */
  uint8_t Num_Subevents;
/**
 * Subevent interval. Time = N x 1.25 ms.
 * Values:
 * - 0x00 (NaN) : No subevents
 * - 0x06 (7.50 ms)  ... 0xFF (318.75 ms) 
 */
  uint8_t Subevent_Interval;
/**
 * Response slot delay. Range: 0x01 to 0xFE. Time = N x 1.25 ms
 * Values:
 * - 0x00 (NaN) : No response slots
 * - 0x01 (1.25 ms)  ... 0xFE (317.50 ms) 
 */
  uint8_t Response_Slot_Delay;
/**
 * Response slot spacing Range: 0x02 to 0xFF Time = N x 0.125 ms
 * Values:
 * - 0x00 (0.000 ms) : No response slots
 * - 0x02 (0.250 ms)  ... 0xFF (31.875 ms) 
 */
  uint8_t Response_Slot_Spacing;
} hci_le_periodic_advertising_sync_established_v2_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Report event indicates that the Controller
 * has received a periodic advertisement or has failed to receive an
 * AUX_SYNC_SUBEVENT_IND PDU. The Sync_Handle parameter identifies the periodic
 * advertising train that the report relates to. The RSSI parameter contains the
 * RSSI value, excluding any Constant Tone Extension. If the Controller supports
 * the Connectionless CTE Receiver feature, RSSI shall not be set to 0x7F. When
 * multiple advertising packets are used to complete a periodic advertising
 * report (e.g., a packet containing an AUX_SYNC_IND PDU combined with one
 * containing an AUX_CHAIN PDU), the RSSI event parameter shall be set based on
 * the last packet received and the TX_Power event parameter shall be set based
 * on the AUX_SYNC_IND PDU. However, the second or subsequent events for the
 * same periodic advertisement may instead have a TX_Power value of 0x7F. The
 * Controller may split the data from a single periodic advertisement (whether
 * one PDU or several) into several reports. If so, each report except the last
 * shall have a Data_Status of "incomplete, more data to come", while the last
 * shall have the value "complete". No further reports shall be sent for a given
 * periodic advertisement after one with a Data_Status other than "incomplete,
 * more data to come". A Data_Status of "incomplete, data truncated" indicates
 * that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not
 * successful or received it but was unable to store the data. The CTE_Type
 * parameter indicates the type of Constant Tone Extension in the periodic
 * advertising packets. The Periodic_Event_Counter parameter indicates the
 * periodic advertising event counter (paEventCounter) of the event that the
 * periodic advertising packet was received in. The Subevent parameter indicates
 * the Periodic Advertising with Responses subevent that the periodic
 * advertising packet was received in. If the Periodic Advertising does not have
 * subevents, then Subevent shall be set to 0xFF. If the Controller receives an
 * AUX_CHAIN_IND PDU with no AdvData, it should send the report (or the last
 * report if it has split the data) immediately without waiting for any
 * subsequent AUX_CHAIN_IND PDUs.
 */
typedef PACKED(struct) hci_le_periodic_advertising_report_v2_event_rp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * TX Power. Units: dBm
 * Values:
 * - -127 ... 126
 * - 127: NA
 */
  int8_t TX_Power;
/**
 * RSSI value Units: dBm
 * Values:
 * - -127 ... 20: RSSI value
 * - 127: RSSI is not available
 */
  int8_t RSSI;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * - 0xFF: No Constant Tone Extension
 */
  uint8_t CTE_Type;
/**
 * The value of paEventCounter (see [Vol 6] Part B, Section 4.4.2.1) for the
 * reported periodic advertising packet.
 */
  uint16_t Periodic_Event_Counter;
/**
 * The subevent number.
 * Values:
 * - 0x00 ... 0x7F
 * - 0xFF: No subevents
 */
  uint8_t Subevent;
/**
 * Data Status
 * Values:
 * - 0x00: Data complete
 * - 0x01: Data incomplete, more data to come
 * - 0x02: Data incomplete, data truncated, no more to come
 * - 0xFF: Failed to receive an AUX_SYNC_SUBEVENT_IND PDU
 */
  uint8_t Data_Status;
/**
 * Length of the Data field
 * Values:
 * - 0 ... 247: Length of the Data field
 * - 248 ... 255: Reserved for future use
 */
  uint8_t Data_Length;
/**
 * Data received from a Periodic Advertising packet
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} hci_le_periodic_advertising_report_v2_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is used by the
 * Controller to report that it has received periodic advertising
 * synchronization information from the device referred to by the
 * Connection_Handle parameter and either successfully synchronized to the
 * periodic advertising train or timed out while attempting to synchronize. The
 * Status will be zero if it successfully synchronized and non-zero otherwise.
 * The Service_Data value is provided by the Host of the device sending the
 * information. The Sync_Handle identifies the periodic advertising in
 * subsequent commands and events and shall be assigned by the Controller. The
 * remaining parameters provide information about the periodic advertising (see
 * Section 7.7.65.14). If there are no subevents or response slots, then the
 * Controller shall set the Num_Subevents parameter to zero and the Host shall
 * ignore the Subevent_Interval, Response_Slot_Delay, and Response_Slot_-
 * Spacing parameters. If Status is non-zero, all parameter values are valid
 * except Sync_Handle, which the Host shall ignore. Note: If the Controller is
 * already synchronized to the periodic advertising train described in the
 * received information, no event will be generated.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_received_v2_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * A value provided by the peer device
 */
  uint16_t Service_data;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 *
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID used to advertise the periodic advertising
 */
  uint8_t Advertising_SID;
/**
 *
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved Private Address)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 *
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic advertising interval. Time = N * 1.25 ms; Time Range: 7.5ms to
 * 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 60 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Advertiser_Clock_Accuracy;
/**
 * Number of subevents.
 * Values:
 * - 0x00 ... 0x80
 */
  uint8_t Num_Subevents;
/**
 * Subevent interval. Time = N x 1.25 ms.
 * Values:
 * - 0x00 (NaN) : No subevents
 * - 0x06 (7.50 ms)  ... 0xFF (318.75 ms) 
 */
  uint8_t Subevent_Interval;
/**
 * Response slot delay. Range: 0x01 to 0xFE. Time = N x 1.25 ms
 * Values:
 * - 0x00 (NaN) : No response slots
 * - 0x01 (1.25 ms)  ... 0xFE (317.50 ms) 
 */
  uint8_t Response_Slot_Delay;
/**
 * Response slot spacing Range: 0x02 to 0xFF Time = N x 0.125 ms
 * Values:
 * - 0x00 (0.000 ms) : No response slots
 * - 0x02 (0.250 ms)  ... 0xFF (31.875 ms) 
 */
  uint8_t Response_Slot_Spacing;
} hci_le_periodic_advertising_sync_transfer_received_v2_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Subevent_Data_Request event is used to allow
 * the Controller to indicate that it is ready to transmit one or more subevents
 * and is requesting the advertising data for these subevents. The
 * Subevent_Data_Count parameter shall be less than or equal to the number of
 * subevents. The Subevent_Start parameter is the first subevent being requested
 * and the Subevent_Data_Count parameter determines the subsequent subevents
 * being requested. The subevent numbers wrap from one less than the number of
 * subevents to zero. This event should be sent from the Controller when it has
 * no data for upcoming subevents. The Controller should request data for as
 * many subevents as it has memory to accept to minimize the number of events
 * generated by the Controller.
 */
typedef PACKED(struct) hci_le_periodic_advertising_subevent_data_request_event_rp0_s {
/**
 * Used to identify a periodic advertising train.
 */
  uint8_t Advertising_Handle;
/**
 * The first subevent that data is requested for.
 * Values:
 * - 0x00 ... 0x7F
 */
  uint8_t Subevent_Start;
/**
 * The number of subevents that data is requested for.
 * Values:
 * - 0x01 ... 0x80
 */
  uint8_t Subevent_Data_Count;
} hci_le_periodic_advertising_subevent_data_request_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Response_Report event indicates that one or
 * more Bluetooth devices have responded to a periodic advertising subevent
 * during a PAwR train. The Controller may queue these advertising reports and
 * send information from multiple devices in one HCI_LE_Periodic_Advertising_-
 * Response_Report event. The Controller may fail to transmit the
 * synchronization packet required to enable the response packets to be sent. If
 * this happens, the Controller can report this to the Host using the Tx_Status
 * parameter. The Controller may split the data from a single response into
 * several reports. If so, each report except the last shall have a Data_Status
 * of "incomplete, more data to come", while the last shall have the value
 * "complete". No further reports shall be sent for a given periodic
 * advertisement after one with a Data_Status other than "incomplete, more data
 * to come".
 */
typedef PACKED(struct) hci_le_periodic_advertising_response_report_event_rp0_s {
/**
 * Used to identify a periodic advertising train.
 */
  uint8_t Advertising_Handle;
/**
 * The subevent number.
 */
  uint8_t Subevent;
/**
 * If AUX_SYNC_SUBEVENT_IND was transmitted or not.
 */
  uint8_t Tx_Status;
/**
 * Number of responses in event.
 * Values:
 * - 0x00 ... 0x19
 */
  uint8_t Num_Responses;
/**
 * See @ref Periodic_Advertising_Response_t
 */
  packed_Periodic_Advertising_Response_t Periodic_Advertising_Response[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(packed_Periodic_Advertising_Response_t)];
} hci_le_periodic_advertising_response_report_event_rp0;

/**
 * The HCI_LE_Enhanced_Connection_Complete event indicates to both of the Hosts
 * forming the connection that a new connection has been created. Upon the
 * creation of the connection a Connection_Handle shall be assigned by the
 * Controller, and passed to the Host in this event. If the connection creation
 * fails, this event shall be provided to the Host that had issued the
 * HCI_LE_Create_- Connection or HCI_LE_Extended_Create_Connection command. If
 * this event is unmasked and the HCI_LE_Connection_Complete event is unmasked,
 * only the HCI_LE_Enhanced_Connection_Complete event is sent when a new
 * connection has been created. This event indicates to the Host that issued an
 * HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection command and
 * received an HCI_Command_Status event if the connection creation failed or was
 * successful. The Peer_Address, Peer_Resolvable_Private_Address, and Local_-
 * Resolvable_Private_Address shall always reflect the most recent packet sent
 * and received on air. The Central_Clock_Accuracy parameter is only valid for a
 * Peripheral. On a Central, this parameter shall be set to 0x00. If the
 * connection is established from periodic advertising with responses and Role
 * is 0x00, then the Advertising_Handle parameter shall be set according to the
 * periodic advertising train the connection was established from. If the
 * connection is established from periodic advertising with responses and Role
 * is 0x01, then the Sync_Handle parameter shall be set according to the
 * periodic advertising train the connection was established from. In all other
 * circumstances, Advertising_Handle and Sync_Handle shall be set to No
 * Advertising_Handle and No Sync_Handle and shall be ignored by the Host.
 */
typedef PACKED(struct) hci_le_enhanced_connection_complete_v2_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Role of the local device in the connection.
 * Values:
 * - 0x00: Central
 * - 0x01: Peripheral
 */
  uint8_t Role;
/**
 * 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
 * Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
 * Identity Address (Corresponds to Resolved Private Address)
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address
 * - 0x03: Random (Static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Resolvable Private Address being used by the local device for this
 * connection. This is only valid when the Own_Address_Type is set to 0x02 or
 * 0x03. For other Own_Address_Type values, the Controller shall return all
 * zeros.
 */
  uint8_t Local_Resolvable_Private_Address[6];
/**
 * Resolvable Private Address being used by the peer device for this connection.
 * This is only valid for Peer_Address_Type 0x02 and 0x03. For other
 * Peer_Address_Type values, the Controller shall return all zeros.
 */
  uint8_t Peer_Resolvable_Private_Address[6];
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 */
  uint16_t Supervision_Timeout;
/**
 * Central clock accuracy. Only valid for a Peripheral.
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Central_Clock_Accuracy;
/**
 * Used to identify an advertising set.
 */
  uint8_t Advertising_Handle;
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 * - 0xFFFF: No Sync_Handle
 */
  uint16_t Sync_Handle;
} hci_le_enhanced_connection_complete_v2_event_rp0;


#endif /* _STM32WB05N_TYPES_H_ */
